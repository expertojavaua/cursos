<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Tema 4: Desarrollo de aplicaciones con J2ME</title>
<link rel="stylesheet" href="../../apuntes.css" type="text/css">
</head>
<body>

<h1> 4. Desarrollo de aplicaciones MIDP</h1>
             
<p>Hasta ahora hemos visto la parte b&aacute;sica del lenguaje Java que podemos 
  utilizar en los dispositivos m&oacute;viles. Esta parte de la API est&aacute; 
  basada en la API b&aacute;sica de J2SE, reducida y optimizada para su utilizaci&oacute;n 
  en dispositivos de baja capacidad. Esta es la base que necesitaremos para programar 
  cualquier tipo de dispositivo, sin embargo con ella por si sola no podemos acceder 
  a las caracter&iacute;sticas propias de los m&oacute;viles, como su pantalla, 
  su teclado, reproducir tonos, etc.</p>
<p>Vamos a ver ahora las APIs propias para el desarrollo de aplicaciones m&oacute;viles. 
  Estas APIs ya no est&aacute;n basadas en APIs existentes en J2SE, sino que se 
  han desarrollado espec&iacute;ficamente para la programaci&oacute;n en estos 
  dispositivos. Todas ellas pertenecen al paquete <code>javax.microedition</code>.</p>
<h2>4.1. MIDlets</h2>
<p>Los MIDlets son las aplicaciones para MIDs, realizadas con la API de MIDP. 
  La clase principal de cualquier aplicaci&oacute;n MIDP deber&aacute; ser un 
  MIDlet. Ese MIDlet podr&aacute; utilizar cualquier otra clase Java y la API 
  de MIDP para realizar sus funciones.</p>
<p>Para crear un MIDlet deberemos heredar de la clase <code>MIDlet</code>. Esta 
  clase define una serie de m&eacute;todos abstractos que deberemos definir en 
  nuestros MIDlets, introduciendo en ellos el c&oacute;digo propio de nuestra 
  aplicaci&oacute;n:</p>
<pre class="codigo">protected abstract void <strong>startApp</strong>();<br>protected abstract void <strong>pauseApp</strong>();
protected abstract void <strong>destroyApp</strong>(boolean incondicional);</pre>
<p>A continuaci&oacute;n veremos con m&aacute;s detalle qu&eacute; deberemos introducir 
  en cada uno de estos m&eacute;todos.</p>
<h3>4.1.1. Componentes y contenedores</h3>
<p>Numerosas veces encontramos dentro de las tecnolog&iacute;as Java el concepto 
  de componentes y contenedores. Los componentes son elementos que tienen una 
  determinada interfaz, y los contenedores son la infraestructura que da soporte 
  a estos componentes. </p>
<p>Por ejemplo, podemos ver los <em>applets</em> como un tipo de componente, que 
  para poderse ejecutar necesita un navegador web que haga de contenedor y que 
  lo soporte. De la misma forma, los <em>servlets</em> son componentes que encapsulan 
  el mecanismo petici&oacute;n/respuesta de la web, y el servidor web tendr&aacute; 
  un contenedor que de soporte a estos componentes, para ejecutarlos cuando se 
  produzca una petici&oacute;n desde un cliente. De esta forma nosotros podemos 
  deberemos definir s&oacute;lo el componente, con su correspondiente interfaz, 
  y ser&aacute; el contenedor quien se encargue de controlar su ciclo de vida 
  (instanciarlo, ejecutarlo, destruirlo).</p>
<p>Cuando desarrollamos componentes, no deberemos crear el m&eacute;todo <code>main</code>, 
  ya que estos componentes no se ejecutan como una aplicaci&oacute;n independiente 
  (<em>stand-alone</em>), sino que son ejecutados dentro de una aplicaci&oacute;n 
  ya existente, que ser&aacute; el contenedor. </p>
<p>El contenedor que da soporte a los MIDlets recibe el nombre de <em>Application 
  Management Software</em> (AMS). El AMS adem&aacute;s de controlar el ciclo de 
  vida de la ejecuci&oacute;n MIDlets (inicio, pausa, destrucci&oacute;n), controlar&aacute; 
  el ciclo de vida de las aplicaciones que se instalen en el m&oacute;vil (instalaci&oacute;n, 
  actualizaci&oacute;n, ejecuci&oacute;n, desinstalaci&oacute;n).</p>
<h3>4.1.2. Ciclo de vida</h3>
<p>Durante su ciclo de vida un MIDlet puede estar en los siguientes estados:</p>
<ul>
  <li><strong>Activo</strong>: El MIDlet se est&aacute; ejecutando actualmente.<br>
  </li>
  <li><strong>Pausado</strong>: El MIDlet se encuentra a mitad de una ejecuci&oacute;n 
    pero est&aacute; pausado. La ejecuci&oacute;n podr&aacute; reanudarse, pasando 
    de nuevo a estado activo. <br>
  </li>
  <li><strong>Destruido</strong>: El MIDlet ha terminado su ejecuci&oacute;n y 
    ha liberado todos los recursos, por lo que ya no se puede volver a estado 
    activo. La aplicaci&oacute;n est&aacute; cerrada, por lo que para volver a 
    ponerla en marcha tendr&iacute;amos que volver a ejecutarla.</li>
</ul>
<p>Ser&aacute; el AMS qui&eacute;n se encargue de controlar este ciclo de vida, 
  es decir, qui&eacute;n realice las transiciones de un estado a otro. Nosotros 
  podremos saber cuando hemos entrado en cada uno de estos estados porque el AMS 
  invocar&aacute; al m&eacute;todo correspondiente dentro de la clase del MIDlet. 
  Estos m&eacute;todos son los que se muestran en el siguiente esqueleto de un 
  MIDlet:</p>
<pre class="codigo">import javax.microedition.midlet.*;
<br>public class MiMIDlet extends <strong>MIDlet</strong> {<br><br>    protected void <strong>startApp</strong>() <br>            throws MIDletStateChangeException {
		// Estado activo -&gt; comenzar
    }<br><br>    protected void <strong>pauseApp</strong>() {
        // Estado pausa -&gt; detener hilos<br>    }<br><br>    protected void <strong>destroyApp</strong>(boolean incondicional) <br>            throws MIDletStateChangeException {
        // Estado destruido -&gt; liberar recursos<br>    }<br>}</pre>
<p>Deberemos definir los siguientes m&eacute;todos para controlar el ciclo de 
  vida del MIDlet:</p>
<ul>
  <li><strong><code>startApp()</code></strong>: Este m&eacute;todo se invocar&aacute; 
    cuando el MIDlet pase a estado activo. Es aqu&iacute; donde insertaremos el 
    c&oacute;digo correspondiente a la tarea que debe realizar dicho MIDlet. </li>
</ul>
<blockquote> 
  <p>Si ocurre un error que impida que el MIDlet empiece a ejecutarse deberemos 
    notificarlo. Podemos distinguir entre errores pasajeros o errores permanentes. 
    Los errores pasajeros impiden que el MIDlet se empiece a ejecutar ahora, pero 
    podr&iacute;a hacerlo m&aacute;s tarde. Los permanentes se dan cuando el MIDlet 
    no podr&aacute; ejecutarse nunca. </p>
  <p><strong>Pasajero</strong>: En el caso de que el error sea pasajero, lo notificaremos 
    lanzando una excepci&oacute;n de tipo <code>MIDletStateChangeException</code>, 
    de modo que el MIDlet pasar&aacute; a estado pausado, y se volver&aacute; 
    intentar activar m&aacute;s tarde.</p>
  <p><strong>Permanente</strong>: Si por el contrario el error es permanente, 
    entonces deberemos destruir el MIDlet llamando a <code>notifyDestroyed</code> 
    porque sabemos que nunca podr&aacute; ejecutarse correctamente. Si se lanza 
    una excepci&oacute;n de tipo <code>RuntimeException</code> dentro del m&eacute;todo 
    <code>startApp</code> tendremos el mismo efecto, se destruir&aacute; el MIDlet. 
  </p>
</blockquote>
<ul>
  <li><strong><code>pauseApp()</code></strong>: Se invocar&aacute; cuando se pause 
    el MIDlet. En &eacute;l deberemos detener las actividades que est&eacute; 
    realizando nuestra aplicaci&oacute;n.</li>
</ul>
<blockquote> 
  <p>Igual que en el caso anterior, si se produce una excepci&oacute;n de tipo 
    <code>RuntimeException</code> durante la ejecuci&oacute;n de este m&eacute;todo, 
    el MIDlet se destruir&aacute;.</p>
</blockquote>
<ul>
  <li><strong><code>destroyApp(boolean incondicional)</code></strong>: Se invocar&aacute; 
    cuando se vaya a destruir la aplicaci&oacute;n. En &eacute;l deberemos incluir 
    el c&oacute;digo para liberar todos los recursos que estuviese usando el MIDlet. 
    Con el <em>flag</em> que nos proporciona como par&aacute;metro indica si la 
    destrucci&oacute;n es incondicional o no. Es decir, si <code>incondicional</code> 
    es <code>true</code>, entonces se destruir&aacute; siempre. En caso de que 
    sea <code>false</code>, podemos hacer que no se destruya lanzando la excepci&oacute;n 
    <code>MIDletStateChangeException</code> desde dentro de este m&eacute;todo.</li>
</ul>
<div align="center"><img src="imagenes/midlet/ciclo.gif" width="400" height="174"> 
</div>
<p class="caption">Figura 1. Ciclo de vida de un MIDlet</p>
<p>Hemos visto que el AMS es quien realiza las transiciones entre distintos estados. 
  Sin embargo, nosotros podremos forzar a que se produzcan transiciones a los 
  estados pausado o destruido:</p>
<ul>
  <li><strong><code>notifyDestroyed()</code></strong>: Destruye el MIDlet. Utilizaremos 
    este m&eacute;todo cuando queramos finalizar la aplicaci&oacute;n. Por ejemplo, 
    podemos ejecutar este m&eacute;todo como respuesta a la pulsaci&oacute;n del 
    bot&oacute;n <em>&quot;Salir&quot;</em> por parte del usuario.</li>
</ul>
<blockquote> 
  <p>NOTA: La llamada a este m&eacute;todo notifica que el MIDlet ha sido destruido, 
    pero no invoca el m&eacute;todo <code>destroyApp</code> para liberar los recursos, 
    por lo que tendremos que invocarlo nosotros manualmente antes de llamar a 
    <code>notifyDestroyed</code>.</p>
</blockquote>
<ul>
  <li><strong><code>notifyPause()</code></strong>: Notifica al AMS de que el MIDlet 
    ha entrado en modo pausa. Despu&eacute;s de esto, el AMS podr&aacute; realizar 
    una llamada a <code>startApp</code> para volverlo a poner en estado activo.<br>
  </li>
  <li><strong><code>resumeRequest()</code></strong>: Solicita al AMS que el MIDlet 
    vuelva a ponerse activo. De esta forma, si el AMS tiene varios MIDlets candidatos 
    para activar, elegir&aacute; alguno de aquellos que lo hayan solicitado. Este 
    m&eacute;todo no fuerza a que se produzca la transici&oacute;n como en los 
    anteriores, simplemente lo solicita al AMS y ser&aacute; &eacute;ste qui&eacute;n 
    decida.</li>
</ul>
<h3>4.1.3. Cerrar la aplicaci&oacute;n</h3>
<p>La aplicaci&oacute;n puede ser cerrada por el AMS, por ejemplo si desde el 
  sistema operativo del m&oacute;vil hemos forzado a que se cierre. En ese caso, 
  el AMS invocar&aacute; el m&eacute;todo <code>destroyApp</code> que nosotros 
  habremos definido para liberar los recursos, y pasar&aacute; a estado <strong>destruido</strong>.</p>
<p>Si queremos hacer que la aplicaci&oacute;n termine de ejecutarse desde dentro 
  del c&oacute;digo, nunca utilizaremos el m&eacute;todo <code>System.exit</code> 
  (o <code>Runtime.exit</code>), ya que estos m&eacute;todos se utilizan para 
  salir de la m&aacute;quina virtual. En este caso, como se trata de un componente, 
  si ejecut&aacute;semos este m&eacute;todo cerrar&iacute;amos toda la aplicaci&oacute;n, 
  es decir, el AMS. Por esta raz&oacute;n esto no se permite, si intent&aacute;semos 
  hacerlo obtendr&iacute;amos una excepci&oacute;n de seguridad. </p>
<p>La &uacute;nica forma de salir de una aplicaci&oacute;n MIDP es haciendo pasar 
  el componente a estado destruido, como hemos visto en el punto anterior, para 
  que el contenedor pueda eliminarlo. Esto lo haremos invocando <code>notifyDestroyed</code> 
  para cambiar el estado a destruido. Sin embargo, si hacemos esto no se invocar&aacute; 
  autom&aacute;ticamente el m&eacute;todo <code>destroyApp</code> para liberar 
  los recursos, por lo que deberemos ejecutarlo nosotros manualmente antes de 
  marcar la aplicaci&oacute;n como destruida:</p>
<pre class="codigo">public void salir() {

    destroyApp(true);

    notifyDestroyed();

}</pre>
<p>Si queremos implementar una salida condicional, para que el m&eacute;todo <code>destroyApp</code> 
  pueda decidir si permitir que se cierre o no la aplicaci&oacute;n, podemos hacerlo 
  de la siguiente forma:</p>
<pre class="codigo">public void salir_cond() {
    try {

        destroyApp(false);

        notifyDestroyed();
    } catch(MIDletStateChangeException e) {
    }

}</pre>
<h3>4.1.4. Parametrizaci&oacute;n de los MIDlets</h3>
<p>Podemos a&ntilde;adir una serie de propiedades en el fichero descriptor de 
  la aplicaci&oacute;n (JAD), que podr&aacute;n ser le&iacute;das desde el MIDlet. 
  De esta forma, podremos cambiar el valor de estas propiedades sin tener que 
  rehacer el fichero JAR. </p>
<p>Cada propiedad consistir&aacute; en una clave (<em>key</em>) y en un valor. 
  La clave ser&aacute; el nombre de la propiedad. De esta forma tendremos un conjunto 
  de par&aacute;metros de configuraci&oacute;n (claves) con un valor asignado 
  a cada una. Podremos cambiar f&aacute;cilmente estos valores editando el fichero 
  JAD con cualquier editor de texto.</p>
<p>Para leer estas propiedades desde el MIDlet utilizaremos el m&eacute;todo:</p>
<pre class="codigo">String valor = <strong>getAppProperty</strong>(String key)</pre>
<p>Que nos devolver&aacute; el valor asignado a la clave con nombre <em>key</em>.</p>
</body>
</html>
