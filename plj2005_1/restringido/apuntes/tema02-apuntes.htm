<html>
<head>
<title>Tema 2: Caracter&iacute;sticas b&aacute;sicas</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../../apuntes.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<!-- OneStat -->
<!--ONESTAT SCRIPTCODE START-->
<script type="text/javascript">
<!--
// Account ID : 221957
// Website URL: http://www.jtech.ua.es
// Copyright (C) 2002-2005 OneStat.com All Rights Reserved
function OneStat_Pageview()
{
    var d=document;
    var sid="221957";
    var CONTENTSECTION="";
    var CUSTOMDATA="";
    var osp_URL=d.URL;
    var osp_Title=d.title;
    var t=new Date();
    var p="http"+(d.URL.indexOf('https:')==0?'s':'')+"://stat.onestat.com/stat.aspx?tagver=2&sid="+sid;
    p+="&url="+escape(osp_URL);
    p+="&ti="+escape(osp_Title);
    p+="&section="+escape(CONTENTSECTION);
    p+="&custom="+escape(CUSTOMDATA);
    p+="&rf="+escape(parent==self?window.document.referrer:top.document.referrer);
    p+="&tz="+escape(t.getTimezoneOffset());
    p+="&ch="+escape(t.getHours());
    p+="&js=1";
    p+="&ul="+escape(navigator.appName=="Netscape"?navigator.language:navigator.userLanguage);
    if(osp_URL!=d.URL) p+="&ol="+escape(d.URL);
    if(typeof(screen)=="object"){
       p+="&sr="+screen.width+"x"+screen.height;p+="&cd="+screen.colorDepth;
       p+="&jo="+(navigator.javaEnabled()?"Yes":"No");
    }
    d.write('<img id="ONESTAT_TAG" border="0" width="1" height="1" src="'+p+'" />');
}

OneStat_Pageview();
//-->
</script>
<noscript>
<a href="http://www.onestat.com"><img border="0" width="1" height="1" src="http://stat.onestat.com/stat.aspx?tagver=2&amp;sid=221957&amp;js=No&amp;" ALT="OneStat Web Analytics"></a>
</noscript>
<!--ONESTAT SCRIPTCODE END-->
<h1>2. Caracter&iacute;sticas b&aacute;sicas</h1>
<h2>&nbsp; </h2>
<h2><span class="section">2.1. Excepciones </span> </h2>
<p>Las excepciones son eventos que ocurren durante la ejecuci&oacute;n de un programa 
  y hacen que &eacute;ste salga de su flujo normal de instrucciones. Este mecanismo 
  permite tratar los errores de una forma elegante, ya que separa el c&oacute;digo 
  para el tratamiento de errores del c&oacute;digo normal del programa. Se 
  dice que una excepci&oacute;n es <i>lanzada</i> cuando se produce un error, 
  y esta excepci&oacute;n puede ser <i>capturada</i> para tratar dicho error.</p>
<h3 class="subsection">2.1.1. Tipos de excepciones</h3>
<p>Tenemos diferentes tipos de excepciones dependiendo del tipo de error que representen. 
  Todas ellas descienden de la clase <b>Throwable</b>, la cual tiene dos descendientes 
  directos:</p>
<ul>
  <li> <b>Error</b>: Se refiere a errores graves en la m&aacute;quina virtual de Java, 
    como por ejemplo fallos al enlazar con alguna librer&iacute;a. Normalmente en los programas 
    Java no se tratar&aacute;n este tipo de errores.</li>
  <li><b>Exception</b>: Representa errores que no son críticos y por lo tanto pueden ser 
    tratados y continuar la ejecuci&oacute;n de la aplicaci&oacute;n. La mayor&iacute;a 
    de los programas Java utilizan estas excepciones para el tratamiento de los 
    errores que puedan ocurrir durante la ejecuci&oacute;n del c&oacute;digo.</li>
</ul>
<p>Dentro de <b>Exception</b>, cabe destacar una subclase especial de excepciones 
  denominada <b>RuntimeException</b>, de la cual derivar&aacute;n todas aquellas 
  excepciones referidas a los errores que com&uacute;nmente se pueden producir 
  dentro de cualquier fragmento de c&oacute;digo, como por ejemplo hacer una referencia 
  a un puntero <i>null</i>, o acceder fuera de los l&iacute;mites de un <i>array</i>. 
</p>
<p>Estas <b>RuntimeException</b> se diferencian del resto de excepciones en que 
  no son de tipo <i>checked</i>. Una excepci&oacute;n de tipo <i>checked</i> debe 
  ser capturada o bien especificar que puede ser lanzada de forma obligatoria, 
  y si no lo hacemos obtendremos un error de compilaci&oacute;n. Dado que las 
  <b>RuntimeException</b> pueden producirse en cualquier fragmento de c&oacute;digo, 
  ser&iacute;a impensable tener que a&ntilde;adir manejadores de excepciones y 
  declarar que &eacute;stas pueden ser lanzadas en todo nuestro c&oacute;digo.</p>
<div align="center"><img src="imagenes/basico/excepcion.png" width="491" height="254"></div>
<p align="center" class="caption">Figura 1. Tipos de excepciones</p>
<p>Dentro de estos grupos principales de excepciones podremos encontrar tipos 
  concretos de excepciones o bien otros grupos que a su vez pueden contener m&aacute;s 
  subgrupos de excepciones, hasta llegar a tipos concretos de ellas. Cada tipo 
  de excepci&oacute;n guardar&aacute; informaci&oacute;n relativa al tipo de error 
  al que se refiera, adem&aacute;s de la informaci&oacute;n com&uacute;n a todas 
  las excepciones. Por ejemplo, una <b>ParseException</b>  se suele utilizar al
procesar un fichero. Adem&aacute;s de almacenar 
  un mensaje de error, guardar&aacute; la l&iacute;nea en la que el <i>parser</i> 
  encontr&oacute; el error.</p>
<h3 class="subsection">2.1.2. Captura de excepciones</h3>
<p>Cuando un fragmento de c&oacute;digo sea susceptible de lanzar una excepci&oacute;n 
  y queramos tratar el error producido o bien por ser una excepci&oacute;n de 
  tipo <i>checked</i> debamos capturarla, podremos hacerlo mediante la estructura 
  <i>try-catch-finally</i>, que consta de tres bloques de c&oacute;digo:</p>
<ul>
  <li> Bloque <i>try</i>: Contiene el c&oacute;digo regular de nuestro programa 
    que puede producir una excepci&oacute;n en caso de error.</li>
  <li>Bloque <i>catch</i>: Contiene el c&oacute;digo con el que trataremos el 
    error en caso de producirse.</li>
  <li>Bloque <i>finally</i>: Este bloque contiene el c&oacute;digo que se ejecutar&aacute; 
    al final tanto si se ha producido una excepci&oacute;n como si no lo ha hecho. 
    Este bloque se utiliza para, por ejemplo, cerrar alg&uacute;n fichero que 
    haya podido ser abierto dentro del c&oacute;digo regular del programa, de 
    manera que nos aseguremos que tanto si se ha producido un error como si no 
    este fichero se cierre. </li>
</ul>
<p>Notar que podemos poner un bloque <em>try</em> sin <em>catch</em> pero con <em>finally</em> (cuando por ejemplo no queremos capturar la excepci&oacute;n, pero s&iacute; que hay cosas que queremos hacer tanto si se produce como si no), o podemos poner un bloque <em>try</em> con <em>catch</em> y sin <em>finally</em> (cuando queremos capturar la excepci&oacute;n, y no hay ning&uacute;n c&oacute;digo que necesitemos que se ejecute inexorablemente). </p>
<p>Para el bloque <i>catch</i> adem&aacute;s deberemos especificar el tipo o grupo 
  de excepciones que tratamos en dicho bloque, pudiendo incluir varios bloques <i>catch</i>, cada uno de ellos para un tipo/grupo de excepciones distinto. 
  La forma de hacer esto ser&aacute; la siguiente:</p>
<pre class="codigo"><b><span class="codigo">try</span></b><span class="codigo"> {
	// Código regular del programa
	// Puede producir excepciones
} <b>catch(TipoDeExcepcion1 e1)</b> {
	// Código que trata las excepciones de tipo 
	// TipoDeExcepcion1 o subclases de ella.
	// Los datos sobre la excepción los encontraremos 
	// en el objeto e1.
} <b>catch(TipoDeExcepcion2 e2)</b> {
</span><span class="codigo">	// Código que trata las excepciones de tipo 
	// TipoDeExcepcion2 o subclases de ella.
	// Los datos sobre la excepción los encontraremos 
	// en el objeto e2.
...
} <b>catch(TipoDeExcepcionN eN)</b> {
</span><span class="codigo">	// Código que trata las excepciones de tipo 
	// TipoDeExcepcionN o subclases de ella.
	// Los datos sobre la excepción los encontraremos 
	// en el objeto eN.
} <b>finally</b> {
	// Código de finalización (opcional)
}</span></pre>
<p>
Si como tipo de excepci&oacute;n especificamos un grupo de excepciones este 
  bloque se encargar&aacute; de la captura de todos los subtipos de excepciones 
  de este grupo. Por lo tanto, si especificamos <b>Exception</b> capturaremos 
  cualquier excepci&oacute;n, ya que est&aacute; es la superclase com&uacute;n 
  de todas las excepciones.

</p>
<p>
En el bloque <i>catch</i> pueden ser útiles algunos métodos de la excepción
(que podemos ver en la API de la clase padre <i>Exception</i>):

</p>
  <pre class="codigo">String getMessage()
void printStackTrace()</pre>
<p>con <b>getMessage()</b> obtenemos una cadena descriptiva del error (si la
hay). Con <b>printStackTrace()</b> se muestra por la salida estándar la traza
de errores que se han producido (en ocasiones la traza es muy larga y no puede
seguirse toda en pantalla con algunos sistemas operativos).

</p>
<p>Un ejemplo de uso:

</p>
<pre class="codigo">try
{
	... // Aqui va el codigo que puede lanzar una excepcion
} catch (Exception e) {
	System.out.println (&quot;El error es: &quot; + e.getMessage());
	e.printStackTrace();
}</pre>
<h3 class="subsection">2.1.3. Lanzamiento de excepciones</h3>
<p>Hemos visto cómo capturar excepciones que se produzcan en el c&oacute;digo, 
  pero en lugar de capturarlas tambi&eacute;n podemos hacer que se propaguen al 
  m&eacute;todo de nivel superior (desde el cual se ha llamado al método actual). Para esto,
en el método donde se vaya a lanzar la excepción, se siguen 2 pasos:</p>
<ul>
  <li>Indicar en el m&eacute;todo que determinados tipos 
  de excepciones o grupos de ellas pueden ser lanzados, cosa que haremos de la siguiente
    forma, por ejemplo:</li>
</ul>
<blockquote>
  <pre class="codigo">public void lee_fichero() <b>
throws </b>IOException, FileNotFoundException
{
    // Cuerpo de la función
}</pre>
<p>Podremos indicar tantos tipos de excepciones como queramos en la claúsula <i><b>throws</b></i>. 
  Si alguna de estas clases de excepciones tiene subclases, tambi&eacute;n se 
  considerar&aacute; que puede lanzar todas estas subclases.</p>
</blockquote>
<ul>
  <li> Para lanzar la excepci&oacute;n utilizamos la instrucci&oacute;n <i><b>throw</b></i>, proporcion&aacute;ndole un objeto correspondiente 
  al tipo de excepci&oacute;n que deseamos lanzar. Por ejemplo:</li>
</ul><blockquote>
  <pre class="codigo"><b>throw</b> new IOException(mensaje_error);</pre>
</blockquote>
<ul>
  <li>Juntando estos dos pasos:</li>
</ul>
<blockquote>
  <pre class="codigo">public void lee_fichero() <b>
throws </b>IOException, FileNotFoundException
{
    ...
    throw new IOException(mensaje_error);
    ...
}</pre>
</blockquote>
<p>Podremos lanzar así excepciones en nuestras funciones para indicar 
  que algo no es como debiera ser a las funciones llamadoras. Por ejemplo, si
estamos procesando un fichero que debe tener un determinado formato, ser&iacute;a 
  buena idea lanzar excepciones de tipo <b> ParseException</b> en caso de que la sintaxis 
  del fichero de entrada no sea correcta.&nbsp;</p>
<pre class="codigo">public void leeFich() <b>
throws </b>ParseException
{
    ...
    throw new ParseException(&quot;Error al procesar el fichero&quot;);
    ...
}

...

public void otroMetodo()
{
    try
    {
        leeFich();
    } catch (ParseException e) {
        System.out.println (&quot;Se ha producido un error al leer el fichero&quot;);
        System.out.println (&quot;El mensaje es: &quot; + e.getMessage());
    }
}</pre>
<p>NOTA: para las excepciones que no son de tipo <i> checked</i> no har&aacute; falta
la cláusula <i>throws</i> en la declaración del método, pero seguir&aacute;n el mismo comportamiento que el resto, si 
  no son capturadas pasar&aacute;n al método de nivel superior, y seguir&aacute;n 
  as&iacute; hasta llegar a la funci&oacute;n principal, momento en el que si 
  no se captura provocar&aacute; el error 
  correspondiente.</p>
<h3> <span class="subsection">2.1.4. Creaci&oacute;n de nuevas excepciones</span></h3>
<p>Adem&aacute;s de utilizar los tipos de excepciones contenidos en la distribuci&oacute;n 
  de Java, podremos crear nuevos tipos que se adapten a nuestros problemas.</p>
<p>Para crear un nuevo tipo de excepciones simplemente deberemos crear una clase 
  que herede de <b> Exception</b> o cualquier otro subgrupo de excepciones existente. 
  En esta clase podremos a&ntilde;adir m&eacute;todos y propiedades para almacenar 
  informaci&oacute;n relativa a nuestro tipo de error. Por ejemplo:</p>
<pre class="codigo">public class MiExcepcion extends Exception
{
	public MiExcepcion (String mensaje)
	{
		super(mensaje);
	}
}</pre>
<p>Adem&aacute;s podremos crear subclases de nuestro nuevo tipo de excepci&oacute;n, 
  creando de esta forma grupos de excepciones. Para utilizar estas excepciones
(capturarlas y/o lanzarlas) hacemos lo mismo que lo explicado antes para las
excepciones que se tienen definidas en Java. Por ejemplo:</p>

<pre class="codigo">public void unMetodo() <b>
throws MiException</b>
{
    ...
    throw new MiException(&quot;Error en el metodo&quot;);
    ...
}

...

public void otroMetodo()
{
    try
    {
        unMetodo();
    } catch (<b>MiException e</b>) {
        ...
    }
}</pre>
<p>&nbsp;</p>

<h2>2.2. Hilos</h2>
<p>Un hilo es un flujo de control dentro de un programa que permite realizar una
tarea separada. Es decir, creando varios hilos 
  podremos realizar varias tareas simult&aacute;neamente. Cada hilo tendr&aacute; 
  s&oacute;lo un contexto de ejecuci&oacute;n (contador de programa, pila de ejecuci&oacute;n). 
  Es decir, a diferencia de los procesos UNIX, no tienen su propio espacio de 
  memoria sino que acceden todos al mismo espacio de memoria com&uacute;n, por 
  lo que ser&aacute; importante su sincronizaci&oacute;n cuando tengamos varios 
  hilos accediendo a los mismos objetos.</p>
<h3 class="subsection">2.2.1. Creaci&oacute;n de hilos</h3>
<p>En Java los hilos est&aacute;n encapsulados en la clase <b>Thread</b>. Para 
  crear un hilo tenemos dos posibilidades:</p>
<ul>
  <li>Heredar de <b> Thread</b> redefiniendo el m&eacute;todo <i>run()</i>.</li>
  <li>Crear una clase que implemente la interfaz <b> Runnable</b> que nos obliga 
    a definir el m&eacute;todo <i>run()</i>.</li>
</ul>
<p>En ambos casos debemos definir un m&eacute;todo <i> run()</i> que ser&aacute; 
  el que contenga el c&oacute;digo del hilo. Desde dentro de este m&eacute;todo 
  podremos llamar a cualquier otro m&eacute;todo de cualquier objeto, pero este 
  m&eacute;todo <i> run()</i> ser&aacute; el m&eacute;todo que se invoque cuando 
  iniciemos la ejecuci&oacute;n de un hilo. El hilo terminar&aacute; su ejecuci&oacute;n 
  cuando termine de ejecutarse este m&eacute;todo <i>run()</i>.</p>
<p>Para crear nuestro hilo mediante herencia haremos lo siguiente:</p>
<pre class="codigo">public class EjemploHilo extends <strong>Thread</strong>
{
    public void <strong>run</strong>() {
        // Código del hilo
    }
}</pre>
<p>Una vez definida la clase de nuestro hilo deberemos instanciarlo y ejecutarlo 
  de la siguiente forma:</p>
<pre class="codigo"><strong>Thread</strong> t = new EjemploHilo();
t.<strong>start</strong>();</pre>
<p>Al llamar al método <i>start </i>del hilo, comenzará ejecutarse su método <i>run</i>.
Crear un hilo heredando de <b> Thread</b> tiene el problema de que al no haber 
  herencia m&uacute;ltiple en Java, si heredamos de <b> Thread</b> no podremos 
  heredar de ninguna otra clase, y por lo tanto un hilo no podr&iacute;a heredar 
  de ninguna otra clase.</p>
<p>Este problema desaparece si utilizamos la interfaz <b> Runnable</b> para crear 
  el hilo, ya que una clase puede implementar varios interfaces. Definiremos la 
  clase que contenga el hilo como se muestra a continuaci&oacute;n:</p>
<pre class="codigo">public class EjemploHilo implements <strong>Runnable</strong>
{
    public void <strong>run</strong>() {
        // Código del hilo
    }
}</pre>
<p>Para instanciar y ejecutar un hilo de este tipo deberemos hacer lo siguiente:</p>
<pre class="codigo"><strong>Thread</strong> t = new <strong>Thread</strong>(new EjemploHilo());
t.<strong>start</strong>();</pre>
<p>Esto es as&iacute; debido a que en este caso <b> EjemploHilo</b> no deriva 
  de una clase <b>Thread</b>, por lo que no se puede considerar un hilo, lo &uacute;nico 
  que estamos haciendo implementando la interfaz es asegurar que vamos a tener 
  definido el m&eacute;todo <i>run()</i>. Con esto lo que haremos ser&aacute; 
  proporcionar esta clase al constructor de la clase <b>Thread</b>, para que el 
  objeto <b> Thread</b> que creemos llame al m&eacute;todo <i>run()</i> de la 
  clase que hemos definido al iniciarse la ejecuci&oacute;n del hilo, ya que implementando 
  la interfaz le aseguramos que esta funci&oacute;n existe.</p>
<h3 class="subsection">2.2.2. Estado y propiedades de los hilos</h3>
<p>Un hilo pasar&aacute; por varios estados durante su ciclo de vida. </p>
<pre class="codigo"><strong>Thread</strong> t = new Thread(this);</pre>
<p>Una vez se ha instanciado el objeto del hilo, diremos que est&aacute; en estado 
  de <i> Nuevo hilo</i>.</p>
<pre class="codigo">t.<strong>start</strong>();</pre>
<p>Cuando invoquemos su m&eacute;todo <i>start()</i> el hilo pasar&aacute; a ser 
  un hilo <i>vivo</i>, comenz&aacute;ndose a ejecutar su m&eacute;todo <i>run()</i>. 
  Una vez haya salido de este m&eacute;todo pasar&aacute; a ser un hilo <i>muerto</i>.</p>
<p>La &uacute;nica forma de parar un hilo es hacer que salga del m&eacute;todo 
  <i>run()</i> de forma natural. Podremos conseguir esto haciendo que se cumpla
una condici&oacute;n de salida de <i>run() </i>(lógicamente, la condición que
se nos ocurra dependerá del tipo de programa que estemos haciendo). 
  Las funciones para parar, pausar y reanudar hilos est&aacute;n desaprobadas 
  en las versiones actuales de Java.</p>
<p>Mientras el hilo est&eacute; <i>vivo</i>, podr&aacute; encontrarse en dos estados: 
  <i> Ejecutable</i> y <i> No ejecutable</i>. El hilo pasar&aacute; de <i> Ejecutable</i> 
  a <i> No ejecutable</i> en los siguientes casos:</p>
<ul>
  <li>Cuando se encuentre dormido por haberse llamado al m&eacute;todo <i>sleep()</i>, 
    permanecer&aacute; <i> No ejecutable</i> hasta haber transcurrido el n&uacute;mero 
    de milisegundos especificados.</li>
  <li>Cuando se encuentre bloqueado en una llamada al m&eacute;todo <i>wait()</i> 
    esperando que otro hilo lo desbloquee llamando a <i>notify()</i> o <i>notifyAll()</i>.
    Veremos cómo utilizar estos métodos más adelante.</li>
  <li>Cuando se encuentre bloqueado en una petici&oacute;n de E/S, hasta que se 
    complete la operaci&oacute;n de E/S.</li>
</ul>
<div align="center"><img border="0" src="imagenes/basico/3-2.gif" width="405" height="154"></div>
<p align="center" class="caption">Figura 2. Ciclo de vida de los hilos</p>
<p>Lo &uacute;nico que podremos saber es si un hilo se encuentra vivo o no, llamando 
  a su m&eacute;todo <i>isAlive()</i>.</p>
<p><b>Prioridades de los hilos</b></p>
<p>Adem&aacute;s, una propiedad importante de los hilos ser&aacute; su prioridad. 
  Mientras el hilo se encuentre vivo, el <i> scheduler</i> de la m&aacute;quina 
  virtual Java le asignar&aacute; o lo sacar&aacute; de la CPU, coordinando as&iacute; 
  el uso de la CPU por parte de todos los hilos activos bas&aacute;ndose en su 
  prioridad. Se puede forzar la salida de un hilo de la CPU llamando a su m&eacute;todo 
  <i>yield()</i>. Tambi&eacute;n se sacar&aacute; un hilo de la CPU cuando un 
  hilo de mayor prioridad se haga <i>Ejecutable</i>, o cuando el tiempo que se 
  le haya asignado expire.</p>
<p>Para cambiar la prioridad de un hilo se utiliza el m&eacute;todo <i>setPriority()</i>, 
  al que deberemos proporcionar un valor de prioridad entre <i> MIN_PRIORITY</i> 
  y <i>MAX_PRIORITY</i> (tenéis constantes de prioridad disponibles dentro de
la clase <i>Thread</i>, consultad el API de Java para ver qué valores de
constantes hay).</p>
<p><b>Hilo actual</b></p>
<p>En cualquier parte de nuestro código Java podemos llamar al método <i>currentThread</i>
de la clase <i>Thread</i>, que nos devuelve un objeto hilo con el hilo que se
encuentra actualmente ejecutando el código donde está introducido ese método.
Por ejemplo, si tenemos un código como:</p>
<pre class="codigo">public class EjemploHilo implements Runnable
{
    public EjemploHilo()
    {
        ...
        int i = 0;
        Thread t = Thread.currentThread();
		t.sleep(1000);
    }
}</pre>
<p>La llamada a <i>currentThread</i> dentro del constructor de la clase nos
devolverá el hilo que corresponde con el programa principal (puesto que no
hemos creado ningún otro hilo, y si lo creáramos, no ejecutaría nada que no
estuviese dentro de un método <i>run.</i></p>
<p>Sin embargo, en este otro caso:</p>
<pre class="codigo">public class EjemploHilo implements Runnable
{
    public EjemploHilo()
    {
        Thread t1 = new Thread(this);
        Thread t2 = new Thread(this);
        t1.start();
        t2.start();
    }

    public void run()
    {
        int i = 0;
        Thread t = Thread.currentThread();
		t.sleep(1000);
    }
}</pre>
<p>Lo que hacemos es crear dos hilos auxiliares, y la llamada a <i>currentThread</i>
se produce dentro del <i>run</i>, con lo que se aplica a los hilos auxiliares,
que son los que ejecutan el <i>run: </i>primero devolverá un hilo auxiliar (el
que primero entre, t1 o t2), y luego el otro (t2 o t1).</p>
<p><b>Dormir hilos</b></p>
<p>Como hemos visto en los ejemplos anteriores, una vez obtenemos el hilo que
queremos, el método <i>sleep</i> nos sirve para dormirlo, durante los
milisegundos que le pasemos como parámetro (en los casos anteriores, dormían
durante 1 segundo). El tiempo que duerme el hilo, deja libre el procesador para
que lo ocupen otros hilos. Es una forma de no sobrecargar mucho de trabajo a la
CPU con muchos hilos intentando entrar sin descanso.</p>
<h3 class="subsection">2.2.3. Sincronizaci&oacute;n de hilos</h3>
<p>Muchas veces los hilos deber&aacute;n trabajar de forma coordinada, por lo 
  que es necesario un mecanismo de sincronizaci&oacute;n entre ellos.</p>
<p>Un primer mecanismo de comunicaci&oacute;n es la variable cerrojo incluida 
  en todo objeto <b>Object</b>, que permitir&aacute; evitar que m&aacute;s de 
  un hilo entre en la secci&oacute;n cr&iacute;tica para un objeto determinado. Los m&eacute;todos declarados 
  como <i> synchronized</i> utilizan el cerrojo del objeto al que pertenecen 
  evitando que m&aacute;s de un hilo entre en ellos al mismo tiempo.</p>
<pre class="codigo">public <strong>synchronized</strong> void seccion_critica()
{
    // Código sección crítica
}</pre>
<p>Todos los métodos <i>synchronized</i> de un mismo objeto (no clase, sino
objeto de esa clase), comparten el mismo cerrojo, y es distinto al cerrojo de
otros objetos (de la misma clase, o de otras).</p>
<p>Tambi&eacute;n podemos utilizar cualquier otro objeto para la sincronizaci&oacute;n 
  dentro de nuestro m&eacute;todo de la siguiente forma:</p>
<pre class="codigo"><strong>synchronized</strong> (objeto_con_cerrojo) 
{
    // Código sección crítica
}</pre>
<p>de esta forma sincronizaríamos el código que escribiésemos dentro, con el
código <i>synchronized</i> del objeto <i>objeto_con_cerrojo</i>. </p>
<p>Adem&aacute;s podemos hacer que un hilo quede bloqueado a la espera de que 
  otro hilo lo desbloquee cuando suceda un determinado evento. Para bloquear un 
  hilo usaremos la funci&oacute;n <i>wait()</i>, para lo cual el hilo que llama 
  a esta funci&oacute;n debe estar en posesi&oacute;n del monitor, cosa que ocurre 
  dentro de un m&eacute;todo <i>synchronized</i>, por lo que s&oacute;lo podremos 
  bloquear a un proceso dentro de estos m&eacute;todos. </p>
<p>Para desbloquear a los hilos que haya bloqueados se utilizar&aacute; <i>notifyAll()</i>, 
  o bien <i>notify()</i> para desbloquear s&oacute;lo uno de ellos aleatoriamente. 
  Para invocar estos m&eacute;todos ocurrir&aacute; lo mismo, el hilo deber&aacute; 
  estar en posesi&oacute;n del monitor.</p>
<p>Cuando un hilo queda bloqueado liberar&aacute; el cerrojo para que otro hilo 
  pueda entrar en la secci&oacute;n cr&iacute;tica del objeto y desbloquearlo.</p>
<p>Por &uacute;ltimo, puede ser necesario esperar a que un determinado hilo haya 
  finalizado su tarea para continuar. Esto lo podremos hacer llamando al m&eacute;todo 
  <i>join()</i> de dicho hilo, que nos bloquear&aacute; hasta que el hilo haya 
  finalizado.</p>
<h3 class="subsection">2.2.4. Grupos de hilos</h3>
<p>Los grupos de hilos nos permitir&aacute;n crear una serie de hilos y manejarlos 
  todos a la vez como un &uacute;nico objeto. Si al crear un hilo no se especifica 
  ning&uacute;n grupo de hilos, el hilo creado pertenecer&aacute; al grupo de 
  hilos por defecto.</p>
<p>Podemos crearnos nuestro propio grupo de hilos instanciando un objeto de la 
  clase <b>ThreadGroup</b>. Para crear hilos dentro de este grupo deberemos pasar 
  este grupo al constructor de los hilos que creemos.</p>
<pre class="codigo"><strong>ThreadGroup</strong> grupo = new <strong>ThreadGroup</strong>(&quot;Grupo de hilos&quot;);
<strong>Thread</strong> t = new <strong>Thread</strong>(grupo,new EjemploHilo());</pre>
<h2>&nbsp;</h2>
<h2>2.3. Entrada/salida</h2>
<p>Los programas muy a menudo necesitan enviar datos a un determinado destino, 
  o bien leerlos de una determinada fuente externa, como por ejemplo puede ser 
  un fichero para almacenar datos de forma permanente, o bien enviar datos a través 
  de la red, a memoria, o a otros programas. Esta entrada/salida de datos en Java 
  la realizaremos por medio de <i>flujos (streams)</i> de datos, a través de los 
  cuales un programa podrá recibir o enviar datos en serie.&nbsp;</p>
<h3 class="subsection">2.3.1 Flujos de datos de entrada/salida</h3>
<p>Existen varios objetos que hacen de flujos de datos, y que se distinguen por 
  la finalidad del flujo de datos y por el tipo de datos que viajen a través de 
  ellos. Según el tipo de datos&nbsp; que transporten podemos distinguir:</p>
<ul>
  <li>Flujos de caracteres</li>
  <li>Flujos de bytes</li>
</ul>
<p>Dentro de cada uno de estos grupos tenemos varios pares de objetos, de los 
  cuales uno nos servirá para leer del flujo y el otro para escribir en él. Cada 
  par de objetos será utilizado para comunicarse con distintos elementos (memoria, 
  ficheros, red u otros programas). Estas clases, según sean de entrada o salida 
  y según sean de caracteres o de bytes llevarán distintos sufijos, según se muestra 
  en la siguiente tabla:</p>
<table border="1" width="100%">
  <tr> 
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Flujo de entrada / lector</b></td>
    <td width="34%"><b>Flujo de salida / escritor</b></td>
  </tr>
  <tr> 
    <td width="33%"><b>Caracteres</b></td>
    <td width="33%">XXXXReader</td>
    <td width="34%">XXXXWriter</td>
  </tr>
  <tr> 
    <td width="33%"><b>Bytes</b></td>
    <td width="33%">XXXXInputStream</td>
    <td width="34%">XXXXOutputStream</td>
  </tr>
</table>
<p>Donde XXXX se referirá a la fuente o sumidero de los datos. Puede tomar 
  valores como los que se muestran a continuación:</p>
<table border="1" width="100%">
  <tr> 
    <td width="18%"><b>File</b></td>
    <td width="82%">Acceso a ficheros</td>
  </tr>
  <tr> 
    <td width="18%"><b>Piped</b></td>
    <td width="82%">Comunicación entre programas mediante tuberías (pipes)</td>
  </tr>
  <tr> 
    <td width="18%"><b>String</b></td>
    <td width="82%">Acceso a una cadena en memoria (solo caracteres)</td>
  </tr>
  <tr> 
    <td width="18%"><b>CharArray</b></td>
    <td width="82%">Acceso a un array de caracteres en memoria (solo caracteres)</td>
  </tr>
  <tr> 
    <td width="18%"><b>ByteArray</b></td>
    <td width="82%">Acceso a un array de bytes en memoria (solo bytes)</td>
  </tr>
</table>
<p>Además podemos distinguir los flujos de datos según su propósito, pudiendo 
  ser:</p>
<ul>
  <li>Canales de datos, simplemente para leer o escribir datos directamente en 
    una fuente o sumidero externo.</li>
  <li>Flujos de procesamiento, que además de enviar o recibir datos realizan algún 
    procesamiento con ellos. Tenemos por ejemplo flujos que realizan un filtrado 
    de los datos que viajan a través de ellos (con prefijo Filter), conversores 
    datos (con prefijo Data), bufferes de datos (con prefijo Buffered), preparados 
    para la impresión de elementos (con prefijo Print), etc.</li>
</ul>
<p>Un tipo de filtros de procesamiento a destacar son aquellos que nos permiten 
  convertir un flujo de bytes a flujo de caracteres. Estos objetos son <b>InputStreamReader</b> 
  y <b>OutputStreamWriter</b>. Como podemos ver en su sufijo, son flujos de caracteres, 
  pero se construyen a partir de flujos de bytes, permitiendo de esta manera acceder 
  a nuestro flujo de bytes como si fuese un flujo de caracteres.</p>
<p>Para cada uno de los tipos básicos de flujo que hemos visto existe una superclase, 
  de la que heredaran todos sus subtipos, y que contienen una serie de métodos 
  que serán comunes a todos ellos. Entre estos métodos encontramos los métodos 
  básicos para leer o escribir caracteres o bytes en el flujo a bajo nivel. En 
  la siguiente tabla se muestran los métodos más importantes de cada objeto:</p>
<table border="1" width="100%">
  <tr> 
    <td width="29%"><b>InputStream</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>available</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>OutputStream</b></td>
    <td width="71%"><b>write</b>(int b), <b>flush</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>Reader</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>Writer</b></td>
    <td width="71%"><b>write</b>(int c), <b>flush</b>(), <b>close</b>()</td>
  </tr>
</table>
<p>Aparte de estos métodos podemos encontrar variantes de los métodos de lectura 
  y escritura, otros métodos, y además cada tipo específico de flujo contendrá 
  sus propios métodos. Todas estas clases se encuentran en el paquete <b>java.io</b>. 
  Para más detalles sobre ellas se puede consultar la especificación de la API 
  de Java.</p>
<h3 class="subsection">2.3.2. Entrada, salida y salida de error estándar</h3>
<p>Al igual que en C, en Java también existen los conceptos de entrada, salida, 
  y salida de error estándar. La entrada estándar normalmente se refiere a lo 
  que el usuario escribe en la consola, aunque el sistema operativo puede hacer 
  que se tome de otra fuente. De la misma forma la salida y la salida de error 
  estándar lo que hacen normalmente es mostrar los mensajes y los errores del 
  programa respectivamente en la consola, aunque el sistema operativo también 
  podrá redirigirlas a otro destino.</p>
<p>En Java esta entrada, salida y salida de error estándar se tratan de la misma 
  forma que cualquier otro flujo de datos, estando estos tres elementos encapsulados 
  en tres objetos de flujo de datos que se encuentran como propiedades estáticas 
  de la clase <b>System</b>:</p>
<table border="1" width="61%">
  <tr> 
    <td width="52%">&nbsp;</td>
    <td width="23%"><b>Tipo</b></td>
    <td width="25%"><b>Objeto</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Entrada estándar</b></td>
    <td width="23%">InputStream</td>
    <td width="25%">System.<b>in</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Salida estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>out</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Salida de error estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>err</b></td>
  </tr>
</table>
<p>Para la entrada estándar vemos que se utiliza un objeto <b>InputStream</b> 
  básico, sin embargo para la salida se utilizan objetos <b>PrintWriter</b> que 
  facilitan la impresión de texto ofreciendo a parte del método común de bajo 
  nivel <i>write(int b)</i> <b> </b>para escribir bytes, dos métodos más: <i>print(s)</i> 
  <b> </b>y <i>println(s)</i>. Estas funciones nos permitirán escribir cualquier 
  cadena, tipo básico, o bien cualquier objeto que defina el método <i>toString()</i> 
  que devuelva una representación del objeto en forma de cadena. La única diferencia 
  entre los dos métodos es que el segundo añade automáticamente un salto de línea 
  al final del texto impreso, mientras que en el primero deberemos especificar 
  explícitamente este salto.</p>
<p>Para escribir texto en la consola normalmente utilizaremos:</p>
<pre class="codigo">System.out.println(&quot;Hola mundo&quot;);</pre>
<p>En el caso de la impresión de errores por la salida de error de estándar, deberemos 
  utilizar:&nbsp;</p>
<pre class="codigo">System.err.println(&quot;Error: Se ha producido un error&quot;);</pre>
<p>Además la clase <b>System</b> nos permite sustituir estos flujos por defecto 
  por otros flujos, cambiando de esta forma la entrada, salida y salida de error 
  estándar.</p>
<h3 class="subsection">2.3.3. Acceso a ficheros</h3>
<p>Podremos acceder a ficheros bien por caracteres, o bien de forma binaria (por 
  bytes). Las clases que utilizaremos en cada caso son:</p>
<table border="1" width="100%">
  <tr> 
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Lectura</b></td>
    <td width="34%"><b>Escritura</b></td>
  </tr>
  <tr> 
    <td width="33%"><b>Caracteres</b></td>
    <td width="33%">FileReader</td>
    <td width="34%">FileWriter</td>
  </tr>
  <tr> 
    <td width="33%"><b>Binarios</b></td>
    <td width="33%">FileInputStream</td>
    <td width="34%">FileOutputStream</td>
  </tr>
</table>
<p>Para crear un lector o escritor de ficheros deberemos proporcionar al constructor 
  el fichero del que queremos leer o en el que queramos escribir. Podremos proporcionar 
  esta información bien como una cadena de texto con el nombre del fichero, o 
  bien construyendo un objeto <b>File</b> representando al fichero al que queremos 
  acceder. Este objeto nos permitirá obtener información adicional sobre el fichero, 
  a parte de permitirnos realizar operaciones sobre el sistema de ficheros.</p>
<p>A continuación vemos un ejemplo simple de la copia de un fichero carácter a 
  carácter:</p>
<pre class="codigo">public void copia_fichero() {
&nbsp;&nbsp;&nbsp; int c;
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>FileReader</b> in = new <b>FileReader</b>(&quot;fuente.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp; <b>&nbsp;&nbsp;&nbsp;FileWriter</b> out = new <b>FileWriter</b>(&quot;destino.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = in.<b>read</b>()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.write(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in.<b>close</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.<b>close</b>();
&nbsp;&nbsp;&nbsp; } catch(<b>FileNotFoundException</b> e1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(&quot;Error: No se encuentra el fichero&quot;);
&nbsp;&nbsp;&nbsp; } catch(<b>IOException</b> e2) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
        System.err.println(&quot;Error leyendo/escribiendo fichero&quot;);
&nbsp;&nbsp;&nbsp; }
}</pre>
<p> En el ejemplo podemos ver que para el acceso a un fichero es necesario capturar 
  dos excepciones, para el caso de que no exista el fichero al que queramos acceder 
  y por si se produce un error en la E/S.</p>
<p>Para la escritura podemos utilizar el método anterior, aunque muchas veces 
  nos resultará mucho más cómodo utilizar un objeto <b>PrintWriter </b>con el 
  que podamos escribir directamente líneas de texto:</p>
<pre class="codigo">public void escribe_fichero() {
&nbsp;&nbsp;&nbsp; <b>FileWriter</b> out = null;
&nbsp;&nbsp;&nbsp; <b>PrintWriter</b> p_out = null;
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out = new <b>FileWriter</b>(&quot;result.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out = new <b>PrintWriter</b>(out);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out.<b>println</b>(&quot;Este texto será escrito en el fichero de salida&quot;);
&nbsp;&nbsp;&nbsp; } catch(<b>IOException</b> e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(&quot;Error al escribir en el fichero&quot;);
&nbsp;&nbsp;&nbsp; } finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out.<b>close</b>();
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>Observad también el uso del bloque <i>finally</i>, para cerrar el fichero
tanto si se produce un error al escribir en él como si no.</p>
<p><b>Un caso particular: ficheros de propiedades</b></p>
<p>La clase <b>java.util.Properties</b> permite manejar de forma muy sencilla lo
que se conoce como <i>ficheros de propiedades</i>. Dichos ficheros permiten
almacenar una serie de pares <i>nombre=valor</i>, de forma que tendría una
apariencia como esta:</p>
<pre class="codigo">#Comentarios
elemento1=valor1
elemento2=valor2
...
elementoN=valorN</pre>
<p>Para leer un fichero de este tipo, basta con crear un objeto <i>Properties</i>,
y llamar a su método <i>load()</i>, pasándole como parámetro el fichero que
queremos leer, en forma de flujo de entrada (<i>InputStream</i>):</p>
<pre class="codigo">Properties p = new Properties();
p.load(new FileInputStream(&quot;datos.txt&quot;);</pre>
<p align="left">Una vez leído, podemos acceder a todos los elementos del
fichero desde el objeto <i>Properties</i> cargado. Tenemos los métodos <i>getProperty</i>
y <i>setProperty</i> para acceder a y modificar valores:</p>
<pre class="codigo">String valorElem1 = p.getProperty(&quot;elemento1&quot;);
p.setProperty(&quot;elemento2&quot;, &quot;otrovalor&quot;);</pre>
<p align="left">También podemos obtener todos los nombres de elementos que hay,
y recorrerlos, mediante el método <i>propertyNames()</i>, que nos devuelve una <i>Enumeration</i>
para ir recorriendo:</p>
<pre class="codigo">Enumeration en = p.propertyNames();
while (en.hasMoreElements())
{
	String nombre = (String)(en.nextElement());
	String valor = p.getProperty(nombre);
}</pre>
<p align="left">Una vez hayamos leído o modificado lo que quisiéramos, podemos
volver a guardar el fichero de propiedades, con el método <i>store </i>de <i>Properties</i>,
al que se le pasa un flujo de salida (<i>OutputStream</i>) y una cabecera para
el fichero:</p>
<pre class="codigo">p.store(new FileOutputStream(&quot;datos.txt&quot;), &quot;Fichero de propiedades&quot;);</pre>
<h3 class="subsection">2.3.4. Lectura de tokens</h3>
<p>Hemos visto como leer un fichero carácter a carácter, pero en el caso de ficheros 
  con una gramática medianamente compleja, esta lectura a bajo nivel hará muy 
  difícil el análisis de este fichero de entrada. Necesitaremos leer del fichero 
  elementos de la gramática utilizada, los llamados <b>tokens</b>, como pueden 
  ser palabras, número y otros símbolos.</p>
<p>La clase <b>StreamTokenizer </b>se encarga de partir la entrada en <b>tokens</b> 
  y nos permitirá realizar la lectura del fichero directamente como una secuencia 
  de <b>tokens</b>. Esta clase tiene una serie de constantes identificando los 
  tipos de <b>tokens</b> que puede leer:</p>
<table border="1" width="100%">
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_WORD</b></td>
    <td width="72%">Palabra</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_NUMBER</b></td>
    <td width="72%">Número real o entero</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_EOL</b></td>
    <td width="72%">Fin de línea</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_EOF</b></td>
    <td width="72%">Fin de fichero</td>
  </tr>
  <tr> 
    <td width="28%">Carácter de comillas establecido</td>
    <td width="72%">Cadena de texto encerrada entre comillas</td>
  </tr>
  <tr> 
    <td width="28%">Símbolos</td>
    <td width="72%">Vendrán representados por el código del carácter ASCII del 
      símbolo</td>
  </tr>
</table>
<p>Dado que un <b>StreamTokenizer </b>se utiliza para analizar un fichero de texto, 
  siempre habrá que crearlo a partir de un objeto <b>Reader</b> (o derivados).</p>
<pre class="codigo">StreamTokenizer st = new StreamTokenizer(reader);</pre>
<p>El método <b>nextToken() </b>leerá el siguiente token que encuentre en el fichero 
  y nos devolverá el tipo de <b> token</b> del que se trata. Según este tipo podremos 
  consultar las propiedades <b>sval </b>o <b>nval</b> para ver qué cadena o número 
  respectivamente se ha leído del fichero. Tanto cuando se lea un <b> token</b> 
  de tipo <b>TT_WORD </b>como de tipo cadena de texto entre comillas el valor 
  de este <b> token</b> estará almacenado en <b>sval</b>. En caso de la lectura
sea un número, su valor se almacenará en <b>nval </b>que es de tipo <b>double</b>. 
  Como los demás símbolos ya devuelven el código del símbolo como tipo de <b> 
  token</b> no será necesario acceder a su valor por separado. Podremos consultar 
  el tipo del último <b> token</b> leído en la propiedad <b>ttype</b>.</p>
<p>Un bucle de procesamiento básico será el siguiente:</p>
<pre class="codigo">while(st.<b>nextToken</b>() != StreamTokenizer.<b>TT_EOF</b>) {
&nbsp;&nbsp;&nbsp; switch(st.<b>ttype</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case StreamTokenizer.<b>TT_WORD</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Leida cadena: &quot; + st.<b>sval</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case StreamTokenizer.<b>TT_NUMBER</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Leido numero: &quot; + st.<b>nval</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; }
}&nbsp;</pre>
<p>Podemos distinguir tres tipos de caracteres:</p>
<table border="1" width="100%" height="71">
  <tr> 
    <td width="36%" height="17">Ordinarios (<b>ordinaryChars</b>)</td>
    <td width="64%" height="17">Caracteres que forman parte de los <i>tokens</i>.</td>
  </tr>
  <tr> 
    <td width="36%" height="18">De palabra (<b>wordChars</b>)</td>
    <td width="64%" height="18">Una secuencia formada enteramente por este tipo 
      de caracteres se considerará una palabra.</td>
  </tr>
  <tr> 
    <td width="36%" height="18">De espacio en blanco (<b>whitespaceChars</b>)</td>
    <td width="64%" height="18">Estos caracteres no son interpretados como <i>tokens</i>, 
      simplemente se utilizan para separar <i>tokens</i>. Normalmente estos caracteres 
      son el espacio, tabulador, y salto de línea.</td>
  </tr>
</table>
<p>Para establecer qué caracteres pertenecerán a cada uno de estos tipos utilizaremos 
  los métodos <i>ordinaryChars</i>, <i>wordChars</i> y <i>whitespaceChars</i> 
  del objeto <b>StreamTokenizer<i> </i></b>respectivamente. A cada uno de estos 
  métodos le pasamos un rango de caracteres (según su código ASCII), que serán 
  establecidos al tipo correspondiente al método que hayamos llamado. Por ejemplo, 
  si queremos que una palabra sea una secuencia de cualquier carácter imprimible 
  (con códigos ASCII desde 32 a 127) haremos lo siguiente:</p>
<pre class="codigo">st.<strong>wordChars</strong>(32,127);</pre>
<p>Los caracteres pueden ser especificados tanto por su código ASCII numérico 
  como especificando ese carácter entre comillas simples. Si ahora queremos hacer 
  que las palabras sean separadas por el caracter ':' (dos puntos) hacemos la 
  siguiente llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>(':', ':');</pre>
<p>De esta forma, si hemos hecho las llamadas anteriores el <i>tokenizer</i> leerá 
  palabras formadas por cualquier carácter imprimible separadas por los dos puntos 
  ':'. Al querer cambiar un único carácter, como siempre deberemos especificar 
  un rango, deberemos especificar un rango formado por ese único carácter como 
  inicial y final del rango. Si además quisieramos utilizar el guión '-' para 
  separar palabras, no siendo caracteres consecutivos guión y dos puntos en la 
  tabla ASCII, tendremos que hacer una tercera llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>('-', '-');</pre>
<p>Así tendremos tanto el guión como los dos puntos como separadores, y el resto 
  de caracteres imprimibles serán caracteres de palabra. Podemos ver que el <b>StreamTokenizer</b> 
  internamente implementa una tabla, en la que asocia a cada carácter uno de los 
  tres tipos mencionados. Al llamar a cada uno de los tres métodos cambiará el 
  tipo de todo el rango especificado al tipo correspondiente al método. Por ello 
  es importante el orden en el que invoquemos este método. Si en el ejemplo en 
  el que hemos hecho estas tres llamadas las hubiésemos hecho en orden inverso, 
  al establecer todo el rango de caracteres imprimibles como <i>wordChars</i> 
  hubiésemos sobrescrito el resultado de las otras dos llamadas y por lo tanto 
  el guión y los dos puntos no se considerarían separadores.</p>
<p>Podremos personalizar el <i> tokenizer</i> indicando para cada carácter a que 
  tipo pertenece. Además de con los tipos anteriores, podemos especificar el carácter 
  que se utilice para encerrar las cadenas de texto (<b>quoteChar</b>), mediante 
  el método <i>quoteChar</i>, y el carácter para los comentarios (<b>commentChar</b>), 
  mediante <i>commentChar</i>. Esto nos permitirá definir comentarios de una línea 
  que comiencen por un determinado carácter, como por ejemplo los comentarios 
  estilo Pascal comenzados por el carácter almohadilla ('#'). Además tendremos 
  otros métodos para activar comentarios tipo C como los comentarios <i>barra-barra 
  </i>(<i>//</i>)<i> </i>y <i>barra-estrella </i>(<i>/* */</i>).</p>
<h3 class="subsection">2.3.5. Acceso a ficheros o recursos dentro de un JAR</h3>
<p>Hemos visto como leer y escribir ficheros, pero cuando ejecutamos una
aplicación contenida en un fichero JAR, puede que necesitemos leer recursos
contenidos dentro de este JAR.</p>
<p>Para acceder a estos recursos deberemos abrir un flujo de entrada que se
encargue de leer su contenido. Para ello utilizaremos el método <code>getResourceAsStream</code>
de la clase <code>Class</code>:</p>
<pre class="codigo">InputStream in = getClass().<strong>getResourceAsStream</strong>(&quot;/datos.txt&quot;);</pre>
<p>De esta forma podremos utilizar el flujo de entrada obtenido para leer el
contenido del fichero que hayamos indicado. Este fichero deberá estar contenido
en el JAR de la aplicación.</p>
<p>Especificamos el carácter '<code>/</code>' delante del nombre del recurso
para referenciarlo de forma relativa al directorio raíz del JAR. Si no lo
especificásemos de esta forma se buscaría de forma relativa al directorio
correspondiente al paquete de la clase actual.</p>
<h3 class="subsection">2.3.6. Codificación de datos</h3>
<p class="subsection">Si queremos guardar datos en un fichero binario deberemos
codificar estos datos en forma de <em>array</em> de <em>bytes</em>. Los flujos
de procesamiento <code>DataInputStream</code> y <code>DataOutputStream</code>
nos permitirán codificar y descodificar respectivamente los tipos de datos
simples en forma de <em>array</em> de <em>bytes</em> para ser enviados a través
de un flujo de datos.</p>
<p class="subsection">Por ejemplo, podemos codificar datos en un <em>array</em>
en memoria (<code>ByteArrayOutputStream</code>) de la siguiente forma:</p>
<pre class="codigo">String nombre = &quot;Jose&quot;;
String edad = 25;

<strong>ByteArrayOutputStream</strong> baos = new <strong>ByteArrayOutputStream</strong>();
<strong>DataOutputStream</strong> dos = new <strong>DataOutputStream</strong>(baos);

dos.<strong>writeUTF</strong>(nombre);
dos.<strong>writeInt</strong>(edad);

dos.close();
baos.close();

byte [] datos = baos.<strong>toByteArray</strong>();</pre>
<p class="subsection">Podremos descodificar este <em>array</em> de <em>bytes</em>
realizando el procedimiento inverso, con un flujo que lea un <em>array</em> de <em>bytes</em>
de memoria (<code>ByteArrayInputStream</code>):</p>
<pre class="codigo"><strong>ByteArrayInputStream</strong> bais = new <strong>ByteArrayInputStream</strong>(datos);
<strong>DataInputStream</strong> dis = new <strong>DataInputStream</strong>(bais);

String nombre = dis.<strong>readUTF</strong>();
int edad = dis.<strong>readInt</strong>();
</pre>
<p class="subsection">Si en lugar de almacenar estos datos codificados en una <em>array</em>
en memoria queremos guardarlos codificados en un fichero, haremos lo mismo
simplemente sustituyendo el flujo canal de datos <code>ByteArrayOutputStream</code>
por un <code>FileOutputStream</code>. De esta forma podremos utilizar cualquier
canal de datos para enviar estos datos codificados a través de él.</p>
<h3 class="subsection">2.3.7. Serialización de objetos</h3>
<p>Si queremos enviar un objeto complejo a través de un flujo de datos, deberemos convertirlo 
  en una serie de bytes. Esto es lo que se conoce como serialización de objetos, 
  que nos permitirá leer y escribir objetos. </p>
<p>Para leer o escribir objetos podemos utilizar los objetos <b>ObjectInputStream 
  </b>y <b>ObjectOutputStream</b> que incorporan los métodos <b>readObject() </b>y 
  <b>writeObject(Object obj) </b>respectivamente. Los objetos que escribamos en 
  dicho flujo deben tener la capacidad de ser <i>serializables</i>. </p>
<p>Serán <i>serializables </i>aquellos objetos que implementan la interfaz <b>Serializable</b>. 
  Cuando queramos hacer que una clase definida por nosotros sea <i>serializable 
  </i>deberemos implementar dicho interfaz, que no define ninguna función, sólo 
  se utiliza para identificar las clases que son <i>serializables</i>. Para que 
  nuestra clase pueda ser <i>serializable</i>, todas sus propiedades deberán ser 
  de tipos de datos básicos o bien objetos que también sean<i><b> </b>serializables</i>. 
</p>

</body>
</html>