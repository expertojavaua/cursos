<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Sesi&oacute;n 11: Aplicaciones corporativas</title>
<link rel="stylesheet" href="../apuntes.css" type="text/css">
</head>
<body>
<h1>11. Registro push</h1>
<p>Hasta ahora hemos visto que cuando queremos obtener informaci&oacute;n primero 
  debemos abrir la aplicaci&oacute;n cliente que nos da acceso a esa informaci&oacute;n. 
  Para recibir algo antes tenemos que solicitarlo desde nuestra aplicaci&oacute;n, 
  esto es lo que se conoce como una conexi&oacute;n <em>pull</em>, en la que el 
  cliente debe &quot;tirar&quot; de los datos para obtenerlos.</p>
<p>Para determinadas aplicaciones puede ser interesante poder recibir datos sin 
  tener que solicitarlos. Por ejemplo pensemos en una aplicaci&oacute;n de foro, 
  en el que varios usuarios pueden publicar mensajes. Nosotros querremos visualizar 
  en nuestro cliente la lista de mensajes publicados en el servidor, pero no sabemos 
  cuando llega un mensaje al servidor, ya que puede haberlo enviado cualquier 
  otro cliente, s&oacute;lo el servidor sabe cuando llegan nuevos mensajes.</p>
<p>Cuando el usuario abra la aplicaci&oacute;n del foro se descargar&aacute;n 
  todos los mensajes publicados y se mostrar&aacute;n. Esto sigue un modelo <em>pull</em>, 
  en el que el usuario tiene que abrir la aplicaci&oacute;n para obtener los datos 
  deseados, debe &quot;tirar&quot; de los datos.</p>
<p>Pero imaginemos que queremos implementar una funci&oacute;n de avisos en el 
  foro, con la cual un usuario puede programar un aviso, de forma que cuando alguien 
  publique una contestaci&oacute;n a un tema que sea de su inter&eacute;s, el 
  usuario reciba una notificaci&oacute;n. De esta forma se evita tener que estar 
  entrando en la aplicaci&oacute;n peri&oacute;dicamente para ver si alguien ha 
  contestado. Esto es un modelo <em>push</em>, en el que es la aplicaci&oacute;n 
  la que &quot;empuja&quot; los datos hacia nosotros en el momento en el que llegan. 
</p>
<p>Para implementar este comportamiento podr&iacute;amos utilizar una t&eacute;cnica 
  conocida como <em>polling</em>, que consiste en interrogar al servidor cada 
  cierto periodo de tiempo para comprobar si han llegado mensajes nuevos, y en 
  tal caso recibirlos y mostrarlos al usuario. Esto nos obligar&aacute; a estar 
  continuamente realizando peticiones al servidor, aunque no se haya recibido 
  ning&uacute;n mensaje, con lo que se estar&aacute; produciendo un tr&aacute;fico 
  innecesario en la red. Adem&aacute;s deberemos tener la aplicaci&oacute;n continuamente 
  en funcionamiento, aunque sea en segundo plano, para que haga las comprobaciones.</p>
<p>Con un modelo de tipo <em>push</em> podremos solucionar este problema, ya que 
  en este caso el servidor podr&aacute; enviarnos informaci&oacute;n sin tener 
  que pedirla nosotros previamente. De esta forma cuando el servidor haya recibido 
  nuevos mensajes nos los enviar&aacute; mediante <em>push</em>, sin tener que 
  estar interrog&aacute;ndolo nosotros continuamente.</p>
<p>Es decir, <em>push</em> es un mecanismo que nos va a permitir recibir informaci&oacute;n 
  de forma as&iacute;ncrona, sin tenerla que solicitar nosotros previamente, y 
  evitando el elevado consumo de recursos que producen las t&eacute;cnicas de 
  <em>polling</em>. </p>
<p>En MIDP 2.0 aparece el registro <em>push</em>, que nos permitir&aacute; utilizar 
  este mecanismo de recepci&oacute;n de informaci&oacute;n de forma as&iacute;ncrona 
  en nuestro dispositivo.</p>
<h2>11.1. Aplicaciones activadas por push</h2>
<p>El registro <em>push</em> nos permitir&aacute; que nuestras aplicaciones sean 
  activadas autom&aacute;ticamente mediante <em>push</em>. Es decir, no har&aacute; 
  falta que nosotros abramos la aplicaci&oacute;n manualmente para que esta pueda 
  realizar alguna funci&oacute;n, sino que se podr&aacute; activar autom&aacute;ticamente 
  cuando suceda alg&uacute;n evento externo.</p>
<p>Por ejemplo, una utilidad bastante clara de este mecanismo es la programaci&oacute;n 
  de alarmas. Imaginemos una agenda que deba hacer sonar una alarma cuando llegue 
  la hora de una reuni&oacute;n. En MIDP 1.0 una aplicaci&oacute;n s&oacute;lo 
  podr&aacute; programar una alarma si abrimos manualmente esa aplicaci&oacute;n, 
  y deberemos mantener esta aplicaci&oacute;n abierta en segundo plano permanentemente, 
  ya que si la cerr&aacute;semos tambi&eacute;n se cerrar&iacute;a la alarma programada. 
  Esto hace que en MIDP 1.0 este tipo de aplicaciones sea poco &uacute;tiles, 
  ya que si se nos olvida abrir la aplicaci&oacute;n cuando encendamos el m&oacute;vil 
  no sonar&aacute; ninguna de las alarmas programadas.</p>
<p>Sin embargo, en MIDP 2.0 con el registro <em>push</em> podremos hacer que la 
  aplicaci&oacute;n se abra autom&aacute;ticamente cuando llegue la hora de la 
  alarma, es decir, la aplicaci&oacute;n se estar&aacute; activando autom&aacute;ticamente 
  mediante <em>push</em>. En este caso el evento externo que activa la aplicaci&oacute;n 
  ser&aacute; un temporizador.</p>
<h3><strong>11.1.1. M&eacute;todos de activaci&oacute;n</strong></h3>
<p>La activaci&oacute;n mediante push puede suceder por dos tipos de eventos:</p>
<ul>
  <li><strong>Temporizador</strong>: La aplicaci&oacute;n se abrir&aacute; a una 
    determinada hora que debemos programar.<br>
  </li>
  <li><strong>Conexi&oacute;n de red entrante</strong>: La aplicaci&oacute;n se 
    abrir&aacute; cuando se reciba una determinada conexi&oacute;n de red entrante. 
    Esta conexi&oacute;n puede ser una conexi&oacute;n mediante sockets, datagramas 
    o bien la recepci&oacute;n de un mensaje de texto por ejemplo.</li>
</ul>
<div align="center"><img src="imagenes/red/activacion_push.gif" width="417" height="354"> 
</div>
<p class="caption">Figura 5. M&eacute;todos de activaci&oacute;n de MIDlets</p>
<h3><strong>11.1.2. Responsabilidad compartida</strong></h3>
<p>Deberemos tener en cuenta que el registro <em>push</em> s&oacute;lo estar&aacute; 
  pendiente de estos eventos externos mientras nuestra aplicaci&oacute;n est&eacute; 
  cerrada. Cuando ejecutemos la aplicaci&oacute;n, ser&aacute; responsabilidad 
  suya escuchar las conexiones entrantes y registrar los temporizadores adecuados 
  para que se disparen las alarmas. </p>
<p>Es decir, que la responsabilidad de la escucha y la gesti&oacute;n de los eventos 
  <em>push</em> ser&aacute; compartida entre el MIDlet y el AMS: </p>
<ul>
  <li>Mientras el MIDlet se est&eacute; ejecutando ser&aacute; responsabilidad 
    suya atender a estos eventos.<br>
  </li>
  <li>Mientras el MIDlet no se est&eacute; ejecutando ser&aacute; el AMS el que 
    se encargar&aacute; de escuchar estos eventos, y cuando uno de ellos se produzca 
    ejecutar&aacute; autom&aacute;ticamente el MIDlet para que &eacute;ste realice 
    la funci&oacute;n oportuna. </li>
</ul>
<p>La facilidad que nos proporciona el registro <em>push</em> es esta capacidad 
  de ejecutar la aplicaci&oacute;n autom&aacute;ticamente cuando se produzca un 
  determinado evento externo, pero mientras nuestra aplicaci&oacute;n se est&eacute; 
  ejecutando este registro no realizar&aacute; ninguna funci&oacute;n.</p>
<h3><strong>11.1.3. Emulaci&oacute;n en WTK</strong></h3>
<p>A partir de WTK 2.0 se puede utilizar la activaci&oacute;n push en los emuladores. 
  Pero para disponer de esta funcionalidad deberemos cargar la aplicaci&oacute;n 
  utilizando provisionamiento OTA, instalando de esta forma la aplicaci&oacute;n 
  utilizando el AMS del emulador.</p>
<h2>11.2. Temporizadores</h2>
<p>Vamos a ver c&oacute;mo podemos registrar un temporizador <em>push</em>, para 
  que la aplicaci&oacute;n se ejecute autom&aacute;ticamente a una determinada 
  hora. Para hacer esto deberemos utilizar la API de <code>PushRegistry</code>, 
  que nos permitir&aacute; registrar este tipo de eventos en el registro <em>push</em>.</p>
<p>Podremos registrar una alarma <em>push</em> con el siguiente m&eacute;todo:</p>
<pre class="codigo">long t = PushRegistry.<strong>registerAlarm</strong>(String midletClassName, long hora);</pre>
<p>Deberemos proporcionar como par&aacute;metros el nombre de la clase del MIDlet 
  que queremos que se ejecute, y el tiempo del sistema en milisegundos del instante 
  en el que queremos que se produzca la alarma.</p>
<p>Hemos de tener en cuenta que s&oacute;lo podemos registrar una alarma por MIDlet, 
  de forma que si hubi&eacute;semos registrado otra alarma previamente, al invocar 
  este m&eacute;todo de sobrescribir&aacute;. </p>
<p>Si hubiese una alarma registrada previamente, la llamada a esta funci&oacute;n 
  nos devolver&aacute; como valor de tiempo <code>t</code> el instante en el que 
  estaba programada la alarma previa que ha sido sobrescrita. En caso contrario, 
  nos devolver&aacute; <code>0</code>. </p>
<p>Si nuestra aplicaci&oacute;n tuviese que programar varias alarmas, lo que deber&iacute;amos 
  hacer es registrar mediante push la alarma que tenga la fecha m&aacute;s temprana, 
  y una vez se haya producido esta alarma, se registrar&aacute; la siguiente, 
  y as&iacute; consecutivamente.</p>
<h3><strong>11.2.1. Programar una alarma para una fecha absoluta</strong></h3>
<p>Si queremos programar una alarma para que se produzca en una determinada fecha, 
  independientemente de la fecha actual, simplemente deberemos proporcionar al 
  m&eacute;todo <code>registerAlarm</code> el tiempo del sistema en milisegundos 
  de la hora en la que queremos que se produzca. </p>
<p>Para hacer esto simplemente deberemos obtener un objeto <code>Date</code> que 
  represente dicha hora. Podemos o bien solicitar que el usuario introduzca la 
  fecha manualmente en un campo de fecha, y leer de ese campo el objeto <code>Date</code> 
  con la fecha introducida, o bien generar desde nuestra aplicaciones una determinada 
  fecha utilizando un objeto <code>Calendar</code>.</p>
<p>Una vez tengamos el objeto <code>Date</code> correspondiente a esta fecha, 
  obtendremos de &eacute;l el tiempo en milisegundos de dicha fecha para proporcion&aacute;rselo 
  a la funci&oacute;n <code>registerAlarm</code>:</p>
<pre class="codigo">Date fecha = obtenerFecha();
long t = PushRegistry.<strong>registerAlarm</strong>(midlet.getClass().getName(), fecha.getTime());</pre>
<h3> <strong>11.2.2. Programar una alarma para un intervalo de tiempo</strong></h3>
<p>Es posible que no queramos dar una fecha absoluta a la alarma, sino que queramos 
  establecer una alarma que suene pasado cierto tiempo desde el instante actual. 
  Por ejemplo, podemos querer poner una alarma para que suene dentro de 5 minutos. 
</p>
<p>Para hacer esto deberemos establecer la fecha de forma relativa a la fecha 
  actual. Primero obtendremos la fecha actual mediante un objeto <code>Date</code>, 
  y a esta fecha podremos sumarle el n&uacute;mero de milisegundos del intervalo 
  de tiempo que queremos que tarde en sonar la alarma:</p>
<pre class="codigo">Date ahora = new Date(); // Obtiene la fecha actual
long t = PushRegistry.<strong>registerAlarm</strong>(midlet.getClass().getName(), 
                                    ahora.getTime() + intervalo);</pre>
<h3><strong>11.2.3. Responsabilidad del MIDlet</strong></h3>
<p>Cuando el MIDlet est&eacute; en ejecuci&oacute;n, los temporizadores registrados 
  mediante push no tendr&aacute;n efecto, estos temporizadores s&oacute;lo servir&aacute;n 
  para activar la aplicaci&oacute;n cuando est&eacute; cerrada. </p>
<p>Por lo tanto, normalmente durante la ejecuci&oacute;n de la aplicaci&oacute;n 
  crearemos temporizadores utilizando la clase <code>Timer</code> de Java. Como 
  estos temporizadores ser&aacute;n hilos de la aplicaci&oacute;n, cuando &eacute;sta 
  se cierre los temporizadores tambi&eacute;n se anular&aacute;n. Entonces ser&aacute; 
  este el momento en el que deberemos registrar el temporizador <em>push</em>.</p>
<p>El lugar adecuado para registrar los temporizadores <em>push</em> ser&aacute; 
  el m&eacute;todo <code>destroyApp</code> del MIDlet. De esta forma, si al destruirse 
  la aplicaci&oacute;n todav&iacute;a tuvi&eacute;semos alg&uacute;n temporizador 
  pendiente, los registraremos mediante <em>push</em> para que siga siendo efectivo.</p>
<h3><strong>11.2.4. Activaci&oacute;n del MIDlet</strong></h3>
<p>Cuando el MIDlet se active v&iacute;a push, debido a un temporizador, simplemente 
  se pondr&aacute; en marcha la aplicaci&oacute;n como si la hubi&eacute;semos 
  abierto manualmente, y no tendr&aacute; constancia en ning&uacute;n momento 
  de que se ha abierto debido a un temporizador.</p>
<p>Si queremos que cuando se abra autom&aacute;ticamente se ejecute la alarma, 
  deberemos implementar este comportamiento manualmente. Para hacer esto deberemos 
  registrar las alarmas pendientes utilizando RMS. </p>
<p>Cuando queramos programar una alarma, los datos de esta alarma se registrar&aacute;n 
  de forma persistente utilizando RMS, y se programar&aacute; un <code>Timer</code> 
  para ella. </p>
<p>Si salimos de la aplicaci&oacute;n, en el m&eacute;todo <code>destroyApp</code> 
  se buscar&aacute; la siguiente alarma pendiente, si hay alguna, y la registrar&aacute; 
  mediante <em>push</em>. </p>
<p>Cuando la aplicaci&oacute;n se active la pr&oacute;xima vez, podr&aacute; leer 
  las alarmas pendientes en RMS y programar un <code>Timer</code> para la siguiente. 
  De esta forma, si la aplicaci&oacute;n se hubiese abierto de forma manual y 
  no correspondiese activar ninguna alarma, como en RMS no hay ninguna alarma 
  programada para este momento no suceder&aacute; nada. Si por el contrario, se 
  hubiese abierto debido al temporizador push, como tendremos en RMS una alarma 
  programada justo para el momento actual, se activar&aacute; la alarma. As&iacute;, 
  aunque la aplicaci&oacute;n no sepa cual ha sido la forma de activarse, mediante 
  la informaci&oacute;n almacenada en RMS podremos saber cu&aacute;ndo debemos 
  disparar las alarmas y cuando no.</p>
<h2>11.3. Conexiones push</h2>
<p>Podemos hacer que las aplicaciones se activen mediante conexiones de red entrantes. 
  Utilizando protocolo HTTP no tenemos este tipo de conexiones, ya que &eacute;ste 
  es un protocolo s&iacute;ncrono en el que debemos realizar una petici&oacute;n 
  para obtener una respuesta.</p>
<p>Sin embargo, en MIDP 2.0 se definen otros tipos de conexiones a bajo nivel 
  que si que soportan conexiones entrantes. Estas son las conexiones de sockets 
  y datagramas. Podremos hacer que el dispositivo escuche en un determinado puerto 
  conexiones entrantes mediante sockets o datagramas.</p>
<p>El problema de estos tipos de conexiones es que en la mayor&iacute;a de los 
  casos los operadores de telefon&iacute;a m&oacute;vil actuales utilizan IPs 
  din&aacute;micas, por lo que cada vez que se establezca una nueva conexi&oacute;n 
  (por ejemplo mediante GPRS) se obtendr&aacute; una IP distinta. Esto complica 
  la tarea de registrar nuestro m&oacute;vil para recibir avisos, ya que si la 
  IP cambia frecuentemente no se sabr&aacute; a qu&eacute; direcci&oacute;n se 
  debe enviar la informaci&oacute;n.</p>
<p>Otro tipo de conexi&oacute;n que tenemos disponible en un gran n&uacute;mero 
  de dispositivos y que nos resultar&aacute; m&aacute;s &uacute;til es la conexi&oacute;n 
  de mensajes que aporta la API WMA. Los mensajes de texto se env&iacute;an a 
  un n&uacute;mero de tel&eacute;fono que sabemos que no va a cambiar. De esta 
  manera podremos tener identificado claramente el dispositivo en el cual queremos 
  recibir notificaciones.</p>
<p>Tenemos dos formas de registrar conexiones <em>push</em> entrantes:</p>
<ul>
  <li><strong>Registro est&aacute;tico</strong>: Se registran en el momento en 
    que se instala la suite. Para hacer esto podemos incluir la informaci&oacute;n 
    sobre las conexiones entrantes en el fichero JAD.<br>
  </li>
  <li><strong>Registro din&aacute;mico</strong>: Utilizamos la API de <code>PushRegistry</code> 
    para registrar las conexiones en tiempo de ejecuci&oacute;n, de la misma forma 
    en la que se registran los temporizadores.</li>
</ul>
<h3><strong>11.3.1. Registro est&aacute;tico</strong></h3>
<p>Podremos utilizar registro est&aacute;tico cuando las direcciones de nuestras 
  conexiones entrantes sean est&aacute;ticas. Este ser&aacute; el caso de las 
  conexiones de mensajes (SMS) en cualquier dispositivo, o de las conexiones de 
  sockets y datagramas en aquellos dispositivos que tengan asignada una IP est&aacute;tica 
  y su puerto se configure tambi&eacute;n de forma est&aacute;tica. </p>
<p>Para registrar una conexi&oacute;n <em>push</em> entrante a&ntilde;adiremos 
  un atributo como el siguiente en el fichero JAD:</p>
<pre class="codigo">MIDlet-Push-&lt;n&gt;: &lt;URL&gt;, &lt;NombreClaseMIDlet&gt;, &lt;RemitentesPermitidos&gt;</pre>
<p>Debemos especificar para cada conexi&oacute;n <em>push</em> que queramos permitir 
  la URL de la conexi&oacute;n entrante y el MIDlet que se ejecutar&aacute; cuando 
  recibamos datos. Adem&aacute;s como tercer elemento podemos indicar los remitentes 
  a los que les permitimos enviarnos datos. Con <code>*</code> indicamos que aceptamos 
  datos de cualquier remitente. </p>
<div align="center"><img src="imagenes/red/wtk_push.gif" width="465" height="194"> 
</div>
<p>Estas conexiones se registrar&aacute;n en el momento en que se instale la aplicaci&oacute;n, 
  y se eliminar&aacute;n cuando se desinstale.</p>
<p>Este tipo de registro no es posible cuando tengamos asignaci&oacute;n din&aacute;mica 
  de IPs, ya que en tiempo de despliegue no podremos conocer cual ser&aacute; 
  la IP que tenga el dispositivo cuando se utilice la aplicaci&oacute;n. En este 
  caso deberemos utilizar registro din&aacute;mico, como veremos m&aacute;s adelante.</p>
<p>Para configurar conexiones entrantes de sockets, datagramas y mensajes podremos 
  utilizar URLs de los siguientes tipos:</p>
<pre class="codigo">socket://:&lt;puerto&gt;
datagram://:&lt;puerto&gt;<br>sms://:&lt;puerto&gt;</pre>
<p>Al utilizar registro est&aacute;tico siempre deberemos indicar expl&iacute;citamente 
  el puerto, ya que si dejamos que el puerto se asigne din&aacute;micamente no 
  sabremos a qu&eacute; puerto del m&oacute;vil hay que conectarse para activar 
  la aplicaci&oacute;n.</p>
<p>Por ejemplo, podemos registrar una conexi&oacute;n de mensajes entrantes de 
  la siguiente forma:</p>
<pre class="codigo">MIDlet-Push-1: sms://:4444, es.ua.j2ee.sms.MIDletRecibirSMS, *</pre>
<p>De esta forma se escuchar&aacute; la llegada de SMSs en el puerto 4444, y en 
  el momento que llegue uno se ejecutar&aacute; el MIDlet <code>MIDletRecibirSMS</code>, 
  permitiendo que lleguen desde cualquier remitente.</p>
<h3><strong>11.3.2. Registro din&aacute;mico</strong></h3>
<p>Cuando utilicemos registro din&aacute;mico podremos configurar, adem&aacute;s 
  de las conexiones anteriores, las conexiones de sockets y datagramas para las 
  que se asigne el puerto de forma din&aacute;mica:</p>
<pre class="codigo">socket://
datagram://</pre>
<p>Utilizaremos este tipo de registro cuando estemos utilizando direcciones din&aacute;micas, 
  o bien cuando utilizando direcciones est&aacute;ticas queramos registrar la 
  conexi&oacute;n s&oacute;lo si se cumplen ciertas condiciones. </p>
<p>En este caso el registro lo realizaremos en tiempo de ejecuci&oacute;n, utilizando 
  la API de <code>PushRegistry</code>. Podemos registrar una conexi&oacute;n entrante 
  din&aacute;micamente de la siguiente forma:</p>
<pre class="codigo">PushRegistry.<strong>registerConnection</strong>(url, 
    nombreClaseMIDlet, remitentesPermitidos);</pre>
<p>Si estamos utilizando una conexi&oacute;n entrante asignada din&aacute;micamente, 
  encontramos el problema de que el sistema externo no sabr&aacute; a qu&eacute; 
  direcci&oacute;n debe enviar la informaci&oacute;n para contactar con nuestra 
  aplicaci&oacute;n. Para solucionar este problema deberemos comunicar a este 
  sistema externo la direcci&oacute;n en la que estamos escuchando. Esto podemos 
  hacerlo de la siguiente forma:</p>
<pre class="codigo">// Creamos socket servidor asignando el puerto din&aacute;micamente<br>ServerSocketConnection ssc =
   (ServerSocketConnection)Connector.open(&quot;socket://&quot;);
<br>// Obtenemos el puerto que ha asignado el sistema<br>String url = &quot;socket://:&quot; + ssc.<strong>getLocalPort</strong>();
<br>// Registramos en push una conexion entrante con este mismo puerto<br>PushRegistry.<strong>registerConnection</strong>(url, midletClassName, filter);
<br>// Obtenemos la URL completa de nuestra aplicaci&oacute;n<br>url = &quot;socket://&quot; + ssc.<strong>getLocalAddress</strong>() + &quot;:&quot; + ssc.<strong>getLocalPort</strong>(); <br><br>// Publicamos la URL en el sistema externo<br>publicarURL(url);</pre>
<p>De esta forma cada vez que el sistema asigne un nuevo puerto a nuestra aplicaci&oacute;n 
  deberemos publicar la nueva URL en el sistema externo. </p>
<p>Hemos visto que publicando la direcci&oacute;n en el sistema externo podemos 
  utilizar direcciones en las que el puerto de asigna de forma din&aacute;mica 
  por el sistema. Sin embargo, el caso en el que nuestro operador de telefon&iacute;a 
  asigne al dispositivo la IP de forma din&aacute;mica ser&aacute; m&aacute;s 
  complicado, ya que cualquier p&eacute;rdida de la conexi&oacute;n har&aacute; 
  que la IP cambie y el sistema externo ser&aacute; incapaz de comunicarse con 
  nuestra aplicaci&oacute;n. </p>
<p>En este caso los cambios de direcci&oacute;n pueden ser muy frecuentes, y si 
  la aplicaci&oacute;n Java est&aacute; cerrada no tendremos constancia del momento 
  en el que esto ocurra, por lo que estos tipos de conexi&oacute;n push no ser&aacute;n 
  de utilidad. En ese caso la soluci&oacute;n ser&aacute; utilizar conexiones 
  de mensajes, para las que si que tenemos una direcci&oacute;n (n&uacute;mero 
  de tel&eacute;fono) asignada de forma est&aacute;tica.</p>
<h3><strong>11.3.3. Eliminar conexi&oacute;n entrante</strong></h3>
<p>Las conexiones entrantes <em>push</em> que registremos de forma din&aacute;mica 
  podr&aacute;n ser eliminadas. Para eliminar una conexi&oacute;n utilizaremos 
  el siguiente m&eacute;todo:</p>
<pre class="codigo">try {
  boolean estado = PushRegistry.<strong>unregisterConnection</strong>(url);
} catch(SecurityException e) {
  // Error de seguridad<br>}</pre>
<p>El m&eacute;todo <code>unregisterConnection</code> nos devolver&aacute; <code>true</code> 
  si ha podido eliminar la conexi&oacute;n <em>push</em> correctamente, y <code>false</code> 
  en caso contrario.</p>
<h3><strong>11.3.4. Activaci&oacute;n de la aplicaci&oacute;n</strong></h3>
<p>Cuando la aplicaci&oacute;n haya sido activada mediante una conexi&oacute;n 
  entrante push, a diferencia de la activaci&oacute;n mediante temporizador, si 
  que tendremos constancia de la forma en la que se ha activado. </p>
<p>Para esto utilizaremos el m&eacute;todo <code>listConnections</code>, que nos 
  devuelve la lista de conexiones push registradas para el MIDlet. Si a este m&eacute;todo 
  le pasamos <code>true</code> como par&aacute;metro, nos devolver&aacute; s&oacute;lo 
  aquellas conexiones en las que tengamos datos disponibles para ser leidos.</p>
<p>De esta forma, si al ejecutarse la aplicaci&oacute;n existe alguna conexi&oacute;n 
  <em>push</em> con datos disponibles sabremos que la aplicaci&oacute;n se ha 
  activado mediante <em>push</em> debido a la recepci&oacute;n de datos en dichas 
  conexiones.</p>
<pre class="codigo">public boolean isPushActivated() {
<br>  String [] conexiones = PushRegistry.<strong>listConnections</strong>(true);
<br>  if (conexiones != null &amp;&amp; conexiones.length &gt; 0) {
    for (int i=0; i &lt; conexiones.length; i++) {
      leerDatos(conexiones[i]);<br>    }
    return true ;<br>  } else {<br>    return false;<br>  }
}</pre>
<p>Cuando hayamos recibido datos en una de estas conexiones ser&aacute; responsabilidad 
  de nuestro MIDlet abrir esta conexi&oacute;n y leer los datos. </p>
<p>Hemos de tener en cuenta que en conexiones como los sockets el AMS no crear&aacute; 
  ning&uacute;n buffer con los datos, sino que ser&aacute; el MIDlet activado 
  el que los lea directamente de la red. Por lo tanto, deberemos leerlos lo m&aacute;s 
  r&aacute;pidamente posible, ya que si demor&aacute;semos la lectura de datos 
  se podr&iacute;a producir un <em>timeout</em>.</p>
<h1>12. Seguridad</h1>
<p>Vamos a estudiar la seguridad de las aplicaciones MIDP. Nos referiremos a seguridad 
  en cuanto a que las aplicaciones que se instale el usuario en el m&oacute;vil 
  no puedan realizar actividades da&ntilde;inas para &eacute;l. Otros tipos de 
  seguridad dependientes de la aplicaci&oacute;n, como son la autentificaci&oacute;n 
  y la confidencialidad de la informaci&oacute;n transmitida por la red los estudiaremos 
  en el tema de aplicaciones corporativas.</p>
<p>El usuario navegando por la red puede encontrar aplicaciones MIDP que para 
  utilizarlas deber&aacute;n ser instaladas de forma local en su m&oacute;vil. 
  Si permiti&eacute;semos que estas aplicaciones, una vez instaladas, pudiesen 
  realizar cualquier acci&oacute;n, ser&iacute;a bastante peligroso utilizar este 
  tipo de aplicaciones. El usuario deber&iacute;a estar muy seguro que la aplicaci&oacute;n 
  que se instala es de su confianza, porque de no serlo la aplicaci&oacute;n podr&iacute;a 
  realizar tareas como por ejemplo:</p>
<ul>
  <li>Eliminar datos de otras aplicaciones del m&oacute;vil.</li>
  <li>Leer datos confidenciales del usuario almacenados en el m&oacute;vil y enviarlos 
    a trav&eacute;s de la red.</li>
  <li>Establecer conexiones de red que le costar&aacute;n dinero al usuario sin 
    que &eacute;ste lo sepa.</li>
</ul>
<p>Por lo tanto, es importante garantizar que las aplicaciones MIDP son seguras 
  y no pueden realizar ninguna acci&oacute;n da&ntilde;ina, para que de esta forma 
  los usuarios puedan confiar en ellas y descarg&aacute;rselas sin ning&uacute;n 
  temor. A continuaci&oacute;n veremos c&oacute;mo se garantiza esta seguridad 
  en las aplicaciones MIDP.</p>
<h2>12.1. Sandbox</h2>
<p>La seguridad de las aplicaciones MIDP se debe a que est&aacute;s aplicaciones 
  se debe a que &eacute;stas se ejecutan en un entorno restringido y controlado. 
  Al ejecutarse sobre una m&aacute;quina virtual, y no directamente sobre el dispositivo, 
  se puede limitar el n&uacute;mero de acciones que estas aplicaciones pueden 
  realizar, evitando de esta forma que se realicen acciones que puedan resultar 
  da&ntilde;inas.</p>
<p>Las aplicaciones se ejecutan dentro de lo que se conoce como un caj&oacute;n 
  de arena (<em>sandbox</em>), como los que existen en los parques para que los 
  ni&ntilde;os jueguen de forma segura. Este caj&oacute;n de arena es un entorno 
  limitado y cerrado en el que podr&aacute; trabajar la aplicaci&oacute;n, y en 
  el que no se tendr&aacute; acceso a nada que pudiera resultar da&ntilde;ino. 
</p>
<p>En el caso de las aplicaciones MIDP, este <em>sandbox</em> ser&aacute; la <em>suite</em> 
  de MIDlets. Es decir, ninguna aplicaci&oacute;n podr&aacute; acceder a nada 
  externo a su <em>suite</em>:</p>
<ul>
  <li>S&oacute;lo podremos instanciar clases contenidas en nuestra <em>suite</em>.</li>
  <li>S&oacute;lo podremos leer recursos incluidos en nuestra <em>suite</em>.</li>
  <li>S&oacute;lo podremos acceder a almacenes de registros RMS creados por MIDlets 
    de nuestra <em>suite</em>.</li>
</ul>
<p>Como las aplicaciones MIDP no permiten acceder al sistema de ficheros del dispositivo, 
  ni tampoco permiten utilizar su API nativa, no tendremos problemas de seguridad 
  en este aspecto.</p>
<p>La &uacute;nica funcionalidad que podr&iacute;a resultar peligrosa es la capacidad 
  que tienen estas aplicaciones de establecer conexiones de red. Una aplicaci&oacute;n 
  podr&iacute;a estar intercambiando informaci&oacute;n por la red, lo cual le 
  costar&aacute; dinero al usuario, sin que &eacute;ste se diese cuenta. Sin embargo, 
  esta es una funcionalidad imprescindible de las aplicaciones MIDP, por lo que 
  no podemos privar a estas aplicaciones de su API de red. Por esta raz&oacute;n, 
  a partir de MIDP 2.0 surge un modelo de seguridad que limitar&aacute; la utilizaci&oacute;n 
  de estas funciones a las aplicaciones que obtengan permiso para hacerlo.</p>
<h2>12.2. Solicitud de permisos</h2>
<p>En la API de MIDP 2.0 existen diferentes permisos para cada tipo de conexi&oacute;n 
  que pueda realizar el dispositivo. Estos permisos son los siguientes:</p>
<pre class="codigo">javax.microedition.io.Connector.http
javax.microedition.io.Connector.socket
javax.microedition.io.Connector.https
javax.microedition.io.Connector.ssl
javax.microedition.io.Connector.datagram
javax.microedition.io.Connector.serversocket
javax.microedition.io.Connector.datagramreceiver
javax.microedition.io.Connector.comm
javax.microedition.io.PushRegistry</pre>
<p>Cuando en nuestra aplicaci&oacute;n necesitemos utilizar alguna conexi&oacute;n 
  de cualquiera de estos tipos, deberemos solicitar el permiso para poder hacerlo. 
  Solicitaremos los permisos en el fichero JAD, mediante las propiedades <code>MIDlet-Permissions</code> 
  y <code>MIDlet-Permissions-Opt</code>, en las que especificaremos todos los 
  permisos solicitados separados por comas:</p>
<pre class="codigo">MIDlet-Permissions: javax.microedition.io.Connector.http,javax.microedition.io.PushRegistry
MIDlet-Permissions-Opt: javax.microedition.io.Connector.https</pre>
<p>El atributo <code>MIDlet-Permissions</code> indicar&aacute; aquellos permisos 
  que son esenciales para que nuestra aplicaci&oacute;n pueda funcionar. Si el 
  dispositivo en el que se va a instalar la aplicaci&oacute;n no pudiese conceder 
  estos permisos a nuestra aplicaci&oacute;n, debido a que no conf&iacute;a en 
  ella, se producir&aacute; un error en la instalaci&oacute;n ya que la aplicaci&oacute;n 
  no funcionar&aacute; sin estos permisos.</p>
<p>En el caso de <code>MIDlet-Permissions-Opt</code>, especificamos permisos que 
  solicitamos, pero que son opcionales. Si no se pudiesen obtener estos permisos 
  la aplicaci&oacute;n podr&iacute;a funcionar.</p>
<p>En WTK podremos introducir esta informaci&oacute;n en la pesta&ntilde;a <strong>Permissions</strong> 
  de la ventana <strong>Settings...</strong> de nuestra aplicaci&oacute;n:</p>
<div align="center"><img src="imagenes/red/wtk_perm.gif" width="465" height="319"> 
</div>
<p>Desde esta ventana, pulsando sobre <strong>Add</strong> podremos a&ntilde;adir 
  permisos de forma visual:</p>
<div align="center"><img src="imagenes/red/wtk_perm_2.gif" width="268" height="408"> 
</div>
<p>Aqu&iacute; podremos seleccionar los permisos deseados entre todos los permisos 
  proporcionados por la API que estemos utilizando.</p>
<h2>12.3. Dominios</h2>
<p>Los permisos que se le otorguen a cada aplicaci&oacute;n MIDP depender&aacute;n 
  del dominio en el que se encuentre dicha aplicaci&oacute;n. Un dominio comprende:</p>
<ul>
  <li>Un conjunto de permisos que se otorgar&aacute;n a los MIDlets que pertenezcan 
    a este dominio.<br>
  </li>
  <li>Un serie de criterios para decidir qu&eacute; MIDlets pertenecen a dicho 
    dominio.</li>
</ul>
<p>Podemos distinguir distintos tipos de dominios seg&uacute;n lo restrictivos 
  que sean:</p>
<ul>
  <li>Las aplicaciones que se ejecuten en un dominio de confianza tendr&aacute;n 
    permiso para establecer cualquiera de las conexiones vistas en el punto anterior. 
    <br>
  </li>
  <li>En el otro extremo tendremos un dominio de m&aacute;xima seguridad, en el 
    que se denieguen todas estas operaciones. En esta caso, cada vez que la aplicaci&oacute;n 
    quiera establecer una conexi&oacute;n se producir&aacute; una excepci&oacute;n 
    de tipo <code>SecurityException</code>. <br>
  </li>
  <li>Tambi&eacute;n podemos encontrar un punto intermedio, en el que cada vez 
    que se va a realizar una operaci&oacute;n de este tipo, no se deniegue directamente, 
    sino que se pregunte al usuario si autoriza la realizaci&oacute;n de dicha 
    operaci&oacute;n. Si la autoriza, la operaci&oacute;n podr&aacute; realizarse, 
    y si no lo hace, se producir&aacute; una excepci&oacute;n de tipo <code>SecurityException</code>.</li>
</ul>
<p>Hemos visto tres casos de dominios extremos como ejemplo, pero podemos tener 
  muchos m&aacute;s tipos de dominios distintos. Un dominio se definir&aacute; 
  otorgando a cada operaci&oacute;n sensible un determinado tipo de permiso. En 
  un dominio se pueden conceder permisos de dos formas distintas:</p>
<ul>
  <li>Permisos concedidos (<code>allow</code>): Se concede el permiso para que 
    la aplicaci&oacute;n pueda realizar la correspondiente operaci&oacute;n sin 
    tener que obtener la confirmaci&oacute;n del usuario.</li>
  <li>Permisos de usuario: Cuando la aplicaci&oacute;n vaya a realizar dicha operaci&oacute;n, 
    se pedir&aacute; la confirmaci&oacute;n del usuario. Seg&uacute;n cuantas 
    veces se pida esta confirmaci&oacute;n distinguimos los siguientes tipos: 
    <ul>
      <li><code>oneshot</code>: Se pedir&aacute; confirmaci&oacute;n al usuario 
        cada vez que se vaya a realizar la operaci&oacute;n.</li>
      <li><code>session</code>: Se pedir&aacute; confirmaci&oacute;n al usuario 
        s&oacute;lo la primera vez que se vaya a realizar la operaci&oacute;n 
        en cada sesi&oacute;n. Cuando se cierre la aplicaci&oacute;n y vuelva 
        a abrirse, se volver&aacute; a realizar la pregunta.</li>
      <li><code>blanket</code>: Se pedir&aacute; confirmaci&oacute;n s&oacute;lo 
        la primera vez que se vaya a realizar la operaci&oacute;n. La aplicaci&oacute;n 
        recordar&aacute; la opci&oacute;n que tom&oacute; el usuario en las sucesivas 
        sesiones, hasta que sea desinstalada.</li>
    </ul>
  </li>
</ul>
<p>Esta definici&oacute;n de los dominios ser&aacute; responsabilidad del fabricante 
  del dispositivo, por lo que no deberemos ocuparnos de ello. Nuestras aplicaciones 
  simplemente ser&aacute;n asignadas a uno de los dominios disponibles en el dispositivo 
  que las instalemos.<strong></strong></p>
<h3><strong>12.3.1. Dominios en dispositivos reales</strong></h3>
<p>Normalmente, los dispositivos reales incluyen a las aplicaciones por defecto 
  en un dominio como el &uacute;ltimo. Es decir, cualquier aplicaci&oacute;n que 
  instalemos se considera que no es de confianza, y se le preguntar&aacute; al 
  usuario cada vez que la aplicaci&oacute;n vaya a realizar una operaci&oacute;n 
  restringida. </p>
<p>Adem&aacute;s, en el caso de los dispositivos reales, tambi&eacute;n se suele 
  poder cambiar la configuraci&oacute;n de este dominio por defecto en la pantalla 
  de configuraci&oacute;n del AMS de nuestro m&oacute;vil. Por ejemplo, en el 
  caso del Nokia 6600, podremos cambiar los permisos que se le otorgan a cada 
  aplicaci&oacute;n manualmente. Para cada operaci&oacute;n restringida nos dar&aacute; 
  4 posibilidades:</p>
<ul>
  <li>No permitido</li>
  <li> Preguntar la primera vez</li>
  <li>Preguntar siempre</li>
  <li>Siempre permitido</li>
</ul>
<p>Deberemos tener cuidado de no asignarle permisos a una aplicaci&oacute;n que 
  no sea de nuestra confianza.</p>
<p>La forma en la que el dispositivo decide en qu&eacute; dominio se debe incluir 
  la aplicaci&oacute;n no est&aacute; especificada en MIDP, sin embargo se recomienda 
  la utilizaci&oacute;n de firmas criptogr&aacute;ficas y certificados. </p>
<p>De esta forma, si la aplicaci&oacute;n instalada no lleva una firma de confianza, 
  la aplicaci&oacute;n se incluir&aacute; en el dominio definido por defecto de 
  aplicaciones que no son de confianza. Si por el contrario, contiene una firma 
  reconocida por el dispositivo, la aplicaci&oacute;n se a&ntilde;adir&aacute; 
  a un dominio de confianza correspondiente a dicha firma, que nos otorgar&aacute; 
  un determinado conjunto de permisos para los cuales no ser&aacute; necesaria 
  la confirmaci&oacute;n del usuario.</p>
<p>Seg&uacute;n la firma se puede a&ntilde;adir la aplicaci&oacute;n a diferentes 
  dominios, y en cada uno de ellos se pueden conceder o denegar distintas operaciones. 
  De esta forma, puede ocurrir que una aplicaci&oacute;n firmada por A tenga s&oacute;lo 
  permiso para utilizar conexiones HTTP, una aplicaci&oacute;n firmada por B tenga 
  s&oacute;lo permiso para utilizar sockets, y una firmada por C tenga permiso 
  para utilizar cualquier tipo de conexi&oacute;n. Los distintos tipos de dominios 
  definidos y la asignaci&oacute;n de permisos a cada uno de ellos depender&aacute; 
  del fabricante del dispositivo.</p>
<h3><strong>12.3.2. Dominios en los emuladores</strong></h3>
<p>Los emuladores incluidos en WTK definen un conjunto de 4 dominios en los que 
  se podr&aacute;n incluir las aplicaciones. Estos dominios son:</p>
<ul>
  <li><em>minimum</em>: No se permite realizar ninguna operaci&oacute;n restringida. 
    Cuando se intente realizar alguna de ellas se producir&aacute; una excepci&oacute;n 
    de tipo <code>SecurityException</code> directamente.<br>
  </li>
  <li><em>untrusted</em>: Cada vez que se intente realizar una operaci&oacute;n 
    no permitida se preguntar&aacute; al usuario si desea permitirlo o no:</li>
</ul>
<div align="center"><img src="imagenes/red/wtk_perm_3.gif" width="181" height="208"></div>
<ul>
  <li><em>trusted/maximum</em>: La aplicaci&oacute;n puede realizar cualquier 
    operaci&oacute;n directamente, sin necesidad de preguntar al usuario.</li>
</ul>
<p>Podemos indicar en la configuraci&oacute;n de WTK cual ser&aacute; el dominio 
  por defecto en el que se ejecutar&aacute;n las aplicaciones cuando las carguemos 
  directamente en el emulador (sin utilizar OTA). Podemos cambiar este dominio 
  por defecto en la ventana de preferencias (<strong>Preferences...</strong>) 
  del WTK. </p>
<div align="center"><img src="imagenes/red/wtk_dom.gif" width="588" height="473"> 
</div>
<p>Cuando se utilice provisionamiento OTA, el emulador se comportar&aacute; como 
  un dispositivo real, asignando a la aplicaci&oacute;n un dominio seg&uacute;n 
  su firma.</p>
<h2>12.4. Firmar MIDlets</h2>
<p>En la especificaci&oacute;n de MIDP no se establece ning&uacute;n m&eacute;todo 
  para decidir a qu&eacute; dominio corresponde cada MIDlet, pero se recomienda 
  que para tomar esta decisi&oacute;n se utilicen firmas y certificados.</p>
<p>Cada dispositivo contendr&aacute; una serie de certificados de confianza. Cada 
  uno de estos certificados estar&aacute; asociado a un determinado dominio. Es 
  responsabilidad del fabricante decidir qu&eacute; certificados se incluyen en 
  el dispositivo y a qu&eacute; dominio se asocia cada uno.</p>
<h3><strong>12.4.1. Certificados en los dispositivos</strong></h3>
<p>Para que a un MIDlet se le otorguen ciertos permisos, deber&aacute; estar firmado 
  por un certificado que sea conocido por el dispositivo donde se instala. Al 
  instalar el MIDlet en el dispositivo, si est&aacute; firmado se comprobar&aacute; 
  si el dispositivo contiene el certificado que se ha utilizado para firmarlo. 
  De ser as&iacute;, se comprobar&aacute; la autenticidad de la aplicaci&oacute;n 
  descargada mediante este certificado, y de ser correcta se instalar&aacute; 
  la aplicaci&oacute;n en el dominio que el dispositivo tuviese asociado a dicho 
  certificado.</p>
<p>Si el certificado con el que se ha firmado la aplicaci&oacute;n no fuese conocido 
  por el dispositivo, simplemente instalar&aacute; la aplicaci&oacute;n en el 
  dominio de aplicaciones que no son de confianza. Normalmente en este dominio 
  se preguntar&aacute; al usuario cada vez que se va a realizar una operaci&oacute;n 
  restringida.</p>
<p>Por lo tanto, para conseguir que a nuestro MIDlet se le otorguen permisos deberemos 
  firmarlo por un certificado que est&eacute; incluido en el dispositivo. </p>
<p>La especificaci&oacute;n de MIDP 2.0 recomienda que se incluyan 3 tipos de 
  certificados:</p>
<ul>
  <li><strong>Del fabricante</strong>: Certificados pertenecientes al fabricante 
    del dispositivo. Por ejemplo, en el m&oacute;viles de Nokia, se pueden incluir 
    certificados con los que Nokia pueda firmar las aplicaciones que realice.<br>
  </li>
  <li><strong>Del operador</strong>: Certificados pertenecientes al operador de 
    telefon&iacute;a que utiliza el m&oacute;vil. Estos certificados pueden almacenarse 
    en la tarjeta SIM, ya que es propia del operador de telefon&iacute;a utilizado. 
    Por ejemplo, si en nuestro m&oacute;vil utilizamos una tarjeta Movistar, en 
    ella se pueden almacenar certificados de esta compa&ntilde;&iacute;a, de forma 
    que podamos instalar sus aplicaciones en un dominio de confianza.<br>
  </li>
  <li><strong>De terceros</strong>: Certificados pertenecientes a terceros adquiridos 
    de Autoridades Certificadoras como Verisign o Thwate. Cada dispositivo contendr&aacute; 
    un conjunto de estos certificados. Deberemos asegurarnos de que el certificado 
    con el que vayamos a firmar nuestra aplicaci&oacute;n est&eacute; incluido 
    en los dispositivos en los que vamos a desplegarla.</li>
</ul>
<p>Si el certificado con el que hemos firmado nuestra aplicaci&oacute;n no est&aacute; 
  entre los anteriores, o bien no hemos firmado la aplicaci&oacute;n, &eacute;sta 
  se instalar&aacute; en el dominio de aplicaciones no fiables que existir&aacute; 
  en cualquier dispositivo.</p>
<h3><strong>12.4.2. Certificados en WTK</strong></h3>
<p>Para que nuestra aplicaci&oacute;n obtenga permisos en un dispositivo m&oacute;vil 
  real deber&iacute;amos tenerla firmada por un certificado incorporado en el 
  dispositivo en el que la instalamos. Sin embargo, cuando la probemos en emuladores 
  podremos crear nuestros propios certificados y a&ntilde;adirlos al emulador, 
  sin necesidad de obtenerlos a partir de una Autoridad Certificadora. De esta 
  forma en el emulador las aplicaciones firmadas por nosotros podr&aacute;n obtener 
  los permisos que solicitemos.</p>
<p>Vamos a ver como firmar aplicaciones MIDP utilizando WTK. Para firmar una aplicaci&oacute;n, 
  lo primero que deberemos hacer es crear el paquete con la aplicaci&oacute;n, 
  ya que es necesario contar con el fichero JAR para obtener su <em>digest</em>. 
  Una vez creado el paquete utilizaremos la opci&oacute;n <strong>Project &gt; 
  Sign</strong> para firmar la aplicaci&oacute;n. Aparecer&aacute; la siguiente 
  ventana:</p>
<div align="center"><img src="imagenes/red/wtk_sign_1.gif" width="422" height="274"> 
</div>
<p>Aqu&iacute; podremos utilizar alguna de las claves disponibles para firmar 
  nuestra aplicaci&oacute;n, o bien crear un nuevo par de claves. Pulsaremos sobre 
  <strong>New Key Pair...</strong> para crear nuestras propias claves:</p>
<div align="center"><img src="imagenes/red/wtk_sign_2.gif" width="269" height="187"> 
</div>
<p>Aqu&iacute; introducimos informaci&oacute;n sobre nuestra compa&ntilde;&iacute;a, 
  para crear un certificado correspondiente a esta compa&ntilde;&iacute;a. Cuando 
  pulsemos sobre <strong>Create</strong> se crear&aacute; este certificado asign&aacute;ndole 
  su correspondiente par de claves, y nos mostrar&aacute; la siguiente ventana 
  para indicar a qu&eacute; dominio se asignar&aacute;n las aplicaciones firmadas 
  por nosotros:</p>
<div align="center"><img src="imagenes/red/wtk_sign_3.gif" width="349" height="124"> 
</div>
<p>De esta forma, nuestro certificado ser&aacute; instalado en el emulador. Cuando 
  instalemos una aplicaci&oacute;n firmada por nosotros en el emulador, esta aplicaci&oacute;n 
  se instalar&aacute; en el dominio que hayamos indicado aqu&iacute;. Si elegimos 
  <em>trusted</em>, nuestras aplicaciones dispondr&aacute;n de todos los permisos 
  sin tener que pedir la confirmaci&oacute;n del usuario.</p>
<p>El &uacute;ltimo paso que debemos realizar es firmar nuestra aplicaci&oacute;n 
  utilizando el certificado que acabamos de crear. Para esto simplemente seleccionaremos 
  en la ventana <strong>Sign MIDlet Suite</strong> el certificado que queremos 
  utilizar, y pulsaremos sobre el bot&oacute;n <strong>Sign MIDlet Suite...</strong></p>
<p>Una vez firmada, podremos probarla en el emulador para comprobar que se le 
  otorgan los permisos correspondientes. Para que esto sea as&iacute;, deberemos 
  probarla utilizando provisionamiento OTA, ya que si lo hacemos de otra forma 
  la firma no se tendr&iacute;a en cuenta.</p>
<p>Recordemos que si ejecutamos la aplicaci&oacute;n directamente se tiene en 
  cuenta el dominio que se haya configurado por defecto para los emuladores. Cuando 
  utilizamos OTA se comportar&aacute; como un dispositivo real, utilizando los 
  certificados de los que dispone para asignar un dominio a nuestra aplicaci&oacute;n.</p>
<h1> 13. Aplicaciones corporativas</h1>
<p>El poder establecer conexiones en red nos permitir&aacute; acceder a aplicaciones 
  web corporativas desde el m&oacute;vil. De esta forma, podremos hacer que estos 
  dispositivos m&oacute;viles se comporten como <em>front-end </em>de estas aplicaciones 
  corporativas.</p>
<h2>13.1. Front-ends de aplicaciones corporativas</h2>
<p>Desde los PCs de sobremesa normalmente accedemos a las aplicaciones corporativas 
  utilizando un navegador web. La aplicaci&oacute;n web genera de forma din&aacute;mica 
  la presentaci&oacute;n en el servidor en forma de un documento HTML que ser&aacute; 
  mostrado en los navegadores de los clientes. Podemos aplicar este mismo sistema 
  al caso de los m&oacute;viles, generando nuestra aplicaci&oacute;n web la respuesta 
  en forma de alg&uacute;n tipo de documento que pueda ser interpretado y mostrado 
  en un navegador de tel&eacute;fono m&oacute;vil. Por ejemplo estos documentos 
  pueden estar en formato WML, cHTML o XHTML. Esto puede ser suficiente para acceder 
  a algunas aplicaciones desde los m&oacute;viles.</p>
<p>Utilizar J2ME para realizar este <em>front-end</em> aporta una serie de ventajas 
  sobre el paradigma anterior, como por ejemplo las siguientes:</p>
<ul>
  <li><strong>Interfaz de usuario</strong>. Las aplicaciones J2ME nos permite 
    crear una interfaz de usuario flexible. La capa de presentaci&oacute;n esta 
    implementada totalmente en el cliente, por lo que se podr&aacute; ajustar 
    mejor a las caracter&iacute;sticas de cada dispositivo. <br>
  </li>
  <li><strong>Funcionamiento sin conexi&oacute;n</strong>. La aplicaci&oacute;n 
    J2ME se ejecuta de forma local en el m&oacute;vil, por lo que podremos trabajar 
    sin conexi&oacute;n. Podemos utilizar RMS para guardar datos mientras trabajamos 
    en forma local, y conectar al servidor &uacute;nicamente cuando sea necesario.<br>
  </li>
  <li><strong>Conexi&oacute;n HTTP</strong>. Estas aplicaciones se conectan utilizando 
    el protocolo est&aacute;ndar HTTP. No har&aacute; falta conocer la estructura 
    de la red m&oacute;vil subyacente. El poder establecer conexiones HTTP a Internet 
    nos permitir&aacute; enlazar las aplicaciones J2EE y J2ME. </li>
</ul>
<p>Normalmente ser&aacute; preferible utilizar HTTP a <em>sockets</em> o datagramas 
  porque esto nos aportar&aacute; una serie de ventajas. Por un lado, HTTP est&aacute; 
  soportado por todos los dispositivos MIDP. Al utilizar HTTP tampoco tendremos 
  problema con <em>firewalls</em> intermedios, cosa que puede ocurrir si conectamos 
  por <em>sockets</em> mediante un puerto que est&eacute; cerrado. Adem&aacute;s 
  las APIs de Java incluyen facilidades para trabajar con HTTP, por lo que ser&aacute; 
  sencillo realizar la comunicaci&oacute;n tanto en el cliente como en el servidor. 
</p>
<p>La conexi&oacute;n de red en los m&oacute;viles normalmente tiene una alta 
  latencia, un reducido ancho de banda y es posible que se produzcan interrupciones 
  cuando la cobertura es baja. Deberemos tener en cuenta todos estos factores 
  cuando dise&ntilde;emos nuestra aplicaci&oacute;n. Por esta raz&oacute;n deberemos 
  minimizar la cantidad de datos que se intercambian a trav&eacute;s de la red, 
  y permitir que la aplicaci&oacute;n pueda continuar trabajando correctamente 
  sin conexi&oacute;n.</p>
<h3><strong>13.1.1. Tr&aacute;fico en la red</strong></h3>
<p>Para reducir el n&uacute;mero de datos que se env&iacute;an por la red, evitando 
  que se hagan conexiones innecesarias, es conveniente realizar una validaci&oacute;n 
  de los datos introducidos por el usuario en el cliente. </p>
<p>Normalmente no podremos validarlos de la misma forma en que se validan en el 
  servidor, ya que por ejemplo no tenemos acceso a las bases de datos de la aplicaci&oacute;n, 
  por lo que deber&aacute; volverse a validar por el servidor para realizar la 
  validaci&oacute;n completa. No obstante, es conveniente realizar esta validaci&oacute;n 
  en el cliente como una prevalidaci&oacute;n, de forma que detecte siempre que 
  sea posible los datos err&oacute;neos en el lado del cliente evitando as&iacute; 
  realizar una conexi&oacute;n innecesaria con el servidor.</p>
<p>Deberemos env&iacute;ar y recibir s&oacute;lo la informaci&oacute;n necesaria 
  por la red. Podemos reducir este tr&aacute;fico manteniendo en RMS una copia 
  de los datos remotos que obtengamos (cach&eacute;), para no tener que volver 
  a solicitarlos si queremos volver a visualizarlos.</p>
<h3>13.1.2. Operaciones de larga duraci&oacute;n</h3>
<p>Dado que la red es lenta, las operaciones que necesiten conectarse a la red 
  ser&aacute;n costosas. Estas operaciones ser&aacute; conveniente que sean ejecutadas 
  por hilos en segundo plano, y nunca deberemos establecer una conexi&oacute;n 
  desde un <em>callback</em>. Otro tipo de operaciones que normalmente son de 
  larga duraci&oacute;n son las consultas de datos en RMS.</p>
<p>Cualquier operaci&oacute;n que sea costosa temporalmente deber&aacute; ser 
  ejecutada de esta forma, para evitar que bloquee la aplicaci&oacute;n. </p>
<p>Adem&aacute;s siempre que sea posible deberemos mostrar una barra de progreso 
  mientras se realiza la operaci&oacute;n, de forma que el usuario tenga constancia 
  de que se est&aacute; haciendo algo. Tambi&eacute;n ser&aacute; conveniente 
  permitir al usuario que interrumpa estas largas operaciones, siempre que la 
  interrupci&oacute;n pueda hacerse y no cause inconsistencias en los datos.</p>
<h3>13.1.3. Personalizaci&oacute;n</h3>
<p>Un aspecto interesante en los clientes J2ME es la posibilidad de incorporar 
  personalizaci&oacute;n. La personalizaci&oacute;n consiste en recordar los datos 
  y las preferencias del usuario, de forma que la aplicaci&oacute;n se adapte 
  a estas preferencias y el usuario no tenga que introducir estos datos en cada 
  sesi&oacute;n. Podremos pedir esta informaci&oacute;n de personalizaci&oacute;n 
  la primera vez que ejecuta la aplicaci&oacute;n y almacenar esta informaci&oacute;n 
  utilizando RMS o bien registrarla en el servidor de forma remota. Si tuvi&eacute;semos 
  esta informaci&oacute;n por duplicado, en local y en remoto, deberemos proporcionar 
  mecanismos para sincronizar ambos registros.</p>
<p>Normalmente los dispositivos m&oacute;viles son personales, por lo que las 
  aplicaciones instaladas en un m&oacute;vil s&oacute;lo va a utilizarlas una 
  persona. Por este motivo puede ser conveniente guardar la informaci&oacute;n 
  del usuario para que no tenga que volver a introducirla cada vez que utilice 
  la aplicaci&oacute;n. Podemos hacer que la aplicaci&oacute;n recuerde el login 
  y el password del usuario.</p>
<p>Podemos incluir en la ficha de datos del usuario informaci&oacute;n sobre sus 
  preferencias, de forma que la aplicaci&oacute;n se adapte a sus gustos y resulte 
  m&aacute;s c&oacute;moda de manejar.</p>
<h2>13.2. Integraci&oacute;n con aplicaciones corporativas</h2>
<p>Vamos a considerar que en el servidor tenemos una aplicaci&oacute;n J2EE. En 
  este caso accederemos a la aplicaci&oacute;n corporativa a trav&eacute;s de 
  un <code>Servlet</code>. Los <em>servlets</em> son componentes Java en el servidor 
  que encapsulan el mecanismo petici&oacute;n/respuesta. Es decir, podemos enviar 
  una petici&oacute;n HTTP a un <em>servlet</em>, y &eacute;ste la analizar&aacute; 
  y nos devolver&aacute; una respuesta. </p>
<div align="center"><img src="imagenes/red/j2ee.gif" width="431" height="155"> 
</div>
<p class="caption">Figura 30. Integraci&oacute;n de J2ME y J2EE</p>
<p>La aplicaci&oacute;n J2ME se comunicar&aacute; con un <em>servlet</em>. Dentro 
  de la aplicaci&oacute;n J2EE en el servidor este <em>servlet</em> utilizar&aacute; 
  EJBs para realizar las tareas necesarias. Los EJBs son componentes reutilizables 
  que implementan la l&oacute;gica de negocio de la aplicaci&oacute;n. Estos EJBs 
  podr&aacute;n utilizar otras APIs para realizar sus funciones, como por ejemplo 
  JMS para enviar o recibir mensajes, JDBC para acceder a bases de datos, CORBA 
  para acceder a objetos distribuidos, o bien acceder a Servicios Web utilizando 
  las APIs de XML.</p>
<p>Normalmente tendremos <em>servlets</em> que se encarguen de generar una respuesta 
  para navegadores web HTML. Para las aplicaciones m&oacute;viles esta respuesta 
  no es adecuada, por lo que deberemos crear otra versi&oacute;n de estos <em>servlets</em> 
  que devuelvan una respuesta adaptada a las necesidades de los m&oacute;viles. 
  La arquitectura de capas de J2EE nos permitir&aacute; crear <em>servlets</em> 
  para distintos tipos de clientes minimizando la cantidad de c&oacute;digo redundante, 
  ya que la l&oacute;gica de negocio est&aacute; implementada en los EJBs y estos 
  componentes pueden ser reutilizados desde los diferentes <em>servlets</em>.</p>
<p>El proceso de comunicaci&oacute;n entre nuestra aplicaci&oacute;n y un <em>servlet</em> 
  ser&aacute; el siguiente:</p>
<ul>
  <li>La aplicaci&oacute;n J2ME env&iacute;a la petici&oacute;n al <em>servlet</em>. 
    Para ello establece como URL la direcci&oacute;n en la que est&aacute; mapeado 
    el <em>servlet</em> y a&ntilde;ade al mensaje el contenido que queramos enviar 
    en la petici&oacute;n. Si incluimos contenido en un mensaje de tipo POST deberemos 
    establecer la cabecera <code>Content-Type</code> al tipo correcto de datos 
    que estemos enviando para que el mensaje sea procesado de forma correcta por 
    los <em>gateways</em> intermedios por los que pase. Si enviamos el contenido 
    del mensaje codificado como texto, deberemos establecer este tipo a<code> 
    text/plain</code>, mientras que si los datos se env&iacute;an en binario deberemos 
    utilizar como tipo <code>application/octet-stream</code>.<br>
  </li>
  <li>El <em>servlet</em> recibe la petici&oacute;n, la descodifica, la analiza 
    y en caso necesario utiliza los EJBs que sean necesarios para realizar las 
    acciones oportunas.<br>
  </li>
  <li>Una vez se ha procesado la petici&oacute;n el <em>servlet</em> construye 
    la respuesta con los resultados obtenidos y la codifica. Deberemos establecer 
    las cabeceras <code>Content-Type </code>y <code>Content-Length</code> para 
    asegurarnos de que el mensaje sea procesado correctamente por los <em>gateways</em> 
    intermedios igual que en el caso del env&iacute;o de la petici&oacute;n. En 
    este caso como tipo podremos utilizar por ejemplo<code> text/plain</code> 
    para texto <code>image/png</code> para devolver una imagen PNG al cliente, 
    y <code>application/octet-stream</code> para devolver un mensaje codificado 
    en binario.<br>
  </li>
  <li>Para finalizar, el cliente recibir&aacute; y descodificar&aacute; la respuesta 
    que le ha enviado el <em>servlet</em>. Una vez descodificada podr&aacute; 
    mostrarla en pantalla utilizando la API LCDUI.</li>
</ul>
<h3><strong>13.2.1. Codificaci&oacute;n de los datos</strong></h3>
<p>Hemos visto que la aplicaci&oacute;n J2ME y el <em>servlet</em> de la aplicaci&oacute;n 
  J2EE intercambian datos con una determinada codificaci&oacute;n. En J2ME no 
  tenemos disponibles mecanismos de alto nivel para intercambiar informaci&oacute;n 
  con componentes remotos, como por ejemplo RMI para la invocaci&oacute;n de m&eacute;todos 
  de objetos Java remotos, o las API de an&aacute;lisis de XML para intercambiar 
  informaci&oacute;n en este formato. Por lo tanto deberemos codificar la informaci&oacute;n 
  con formatos propios. Seremos nosotros los que decidamos qu&eacute; formato 
  y codificaci&oacute;n deben tener estos datos.</p>
<p>Podemos movernos entre dos extremos: la codificaci&oacute;n de los datos en 
  binario y la codificaci&oacute;n en XML.</p>
<p>La codificaci&oacute;n binaria de los datos ser&aacute; eficiente y compacta. 
  Ser&aacute; sencillo codificar informaci&oacute;n en este formato utilizando 
  los objetos <code>DataOutputStream</code> y <code>ByteArrayOutputStream</code>. 
  Tiene el inconveniente de que tanto el cliente como el servidor deber&aacute;n 
  conocer c&oacute;mo est&aacute; codificada la informaci&oacute;n dentro del 
  <em>array</em> de <em>bytes</em>, por lo que estos componentes estar&aacute;n 
  altamente acoplados.</p>
<p>Si hemos definido una serializaci&oacute;n para los objetos, podemos aprovechar 
  esta serializaci&oacute;n para enviarlos a trav&eacute;s de la red. En este 
  caso la serializaci&oacute;n la hemos definido manualmente nosotros en un m&eacute;todo 
  del objeto, y no se hace autom&aacute;ticamente como en el caso de J2SE, por 
  lo que deberemos tener cuidado de que en el objeto del cliente y en el del servidor 
  se serialice y deserialice de la misma forma. Adem&aacute;s, al transferir un 
  objeto entre J2ME y J2EE deberemos asegurarnos de que este objeto utiliza solamente 
  la parte com&uacute;n de la API de Java en ambas plataformas.</p>
<p>Por ejemplo, si definimos los m&eacute;todos de serializaci&oacute;n para la 
  clase <code>Cita</code> de la siguiente forma:</p>
<pre class="codigo">public class Cita {<br><br>  Date fecha;<br>  String asunto;<br>  String lugar;<br>  String contacto;<br>  boolean alarma;<br><br>  public void <strong>serialize</strong>(DataOutputStream dos) throws IOException {
    dos.writeLong(fecha.getTime());
    dos.writeUTF(asunto);
    dos.writeUTF(lugar);
    dos.writeUTF(contacto);
    dos.writeBoolean(alarma);
  }<br><br>  public static Cita <strong>deserialize</strong>(DataInputStream dis) throws IOException {
    Cita cita = new Cita();<br><br>    cita.setFecha(new Date(dis.readLong()));
    cita.setAsunto(dis.readUTF());
    cita.setLugar(dis.readUTF());
    cita.setContacto(dis.readUTF());
    cita.setAlarma(dis.readBoolean());<br><br>    return cita;
  }
}</pre>
<p>Podremos intercambiar objetos de este tipo mediante HTTP como se muestra a 
  continuaci&oacute;n:</p>
<pre class="codigo">HttpConnection con = (HttpConnection) Connector.open(URL_SERVLET);<br><br>// Envia datos al servidor
<strong>DataOutputStream</strong> dos = con.<strong>openDataOutputStream</strong>();
Cita[] citasCliente = datosCliente.getCitas();
if (citasCliente == null) {
  dos.<strong>writeInt</strong>(0);
} else {
  dos.<strong>writeInt</strong>(citasCliente.length);
  for (int i = 0; i &lt; citasCliente.length; i++) {
    citasCliente[i].<strong>serialize</strong>(dos);
  }
}<br><br>// Recibe datos del servidor
<strong>DataInputStream</strong> dis = con.<strong>openDataInputStream</strong>();
int nCitasServidor = dis.<strong>readInt</strong>();
Cita[] citasServidor = new Cita[nCitasServidor];
for (int i = 0; i &lt; nCitasServidor; i++) {
  citasServidor[i] = Cita.<strong>deserialize</strong>(dis);
}</pre>
<p>En el otro extremo, XML es un lenguaje complejo de analizar y la informaci&oacute;n 
  ocupa m&aacute;s espacio. Como ventaja tenemos que XML es un lenguaje est&aacute;ndar 
  y autodescriptivo, por lo que reduciremos el acoplamiento de cliente y servidor. 
  Aunque en MIDP no se incluyen librer&iacute;as para procesar XML, diversos fabricantes 
  proporcionan sus propias implementaciones de las librer&iacute;as de XML para 
  J2ME. Podemos utilizar estas librer&iacute;as para crear y analizar estos documentos 
  en los clientes m&oacute;viles. </p>
<p>Podemos encontrar incluso implementaciones de librer&iacute;as de XML orientado 
  a RPC para invocar Servicios Web SOAP directamente desde el m&oacute;vil. Debemos 
  tener cuidado al invocar Servicios Web directamente desde los m&oacute;viles, 
  ya que la construcci&oacute;n y el an&aacute;lisis de los mensajes SOAP es una 
  tarea demasiado costosa para estos dispositivos. Para optimizar la aplicaci&oacute;n, 
  en lugar de invocarlos desde el mismo m&oacute;vil, podemos hacer que sea la 
  aplicaci&oacute;n J2EE la que invoque el servicio, y que el m&oacute;vil se 
  comunique con esta aplicaci&oacute;n a trav&eacute;s de mensajes sencillos.</p>
<h3><strong>13.2.2. Mantenimiento de sesiones</strong></h3>
<p>El protocolo HTTP sigue un mecanismo de petici&oacute;n/respuesta, no mantiene 
  informaci&oacute;n de sesi&oacute;n. Es decir, si realizamos varias peticiones 
  HTTP a un servidor desde nuestro cliente, cada una de estas peticiones ser&aacute; 
  tratada independientemente por el servidor, sin identificar que se trata de 
  un mismo usuario. Para implementar sesiones sobre protocolo HTTP tendremos que 
  recurrir a mecanismos como la reescritura de URLs o las <em>cookies</em>.</p>
<p>Normalmente cuando accedamos a una aplicaci&oacute;n web necesitaremos mantener 
  una sesi&oacute;n para que en todas las peticiones que hagamos al servidor, 
  &eacute;ste nos identifique como un mismo usuario. De esta forma por ejemplo 
  podremos ir a&ntilde;adiendo con cada petici&oacute;n productos a un carrito 
  de la compra en el lado del servidor, sin perder la informaci&oacute;n sobre 
  los productos a&ntilde;adidos de una petici&oacute;n a otra.</p>
<p>Para mantener las sesiones lo que se har&aacute; es obtener en el cliente un 
  identificador de la sesi&oacute;n, de forma que en cada petici&oacute;n que 
  se haga al servidor se env&iacute;e este identificador para que el servidor 
  sepa a qu&eacute; sesi&oacute;n pertenece dicha petici&oacute;n. Este identificador 
  puede ser obtenido mediante <em>cookies</em>, o bien incluirlo como parte de 
  las URLs utilizando la t&eacute;cnica de reescritura de URLs.</p>
<p>Los navegadores web normalmente implementan las sesiones mediante <em>cookies</em>. 
  Estas <em>cookies</em> son informaci&oacute;n que el servidor nos env&iacute;a 
  en la respuesta y que el navegador almacena de forma local en nuestra m&aacute;quina. 
  En la primera petici&oacute;n el servidor enviar&aacute; una <em>cookie</em> 
  al cliente con el identificador de la sesi&oacute;n, y el navegador almacenar&aacute; 
  esta <em>cookie</em> de forma local en el cliente. Cuando se vaya a hacer otra 
  petici&oacute;n al servidor, el navegador env&iacute;a esta <em>cookie</em> 
  para identificarnos ante el servidor como el mismo cliente. De esta forma el 
  servidor podr&aacute; utilizar el valor de la <em>cookie</em> recibida para 
  determinar la sesi&oacute;n correspondiente a dicho cliente, y de esta forma 
  poder acceder a los datos que hubiese almacenado en peticiones anteriores dentro 
  de la misma sesi&oacute;n. </p>
<p>Sin embargo, cuando conectamos desde un cliente J2ME estamos estableciendo 
  una conexi&oacute;n con la URL del <em>servlet</em> desde nuestra propia aplicaci&oacute;n, 
  no desde un navegador que gestione autom&aacute;ticamente estas <em>cookies</em>. 
  Por lo tanto ser&aacute; tarea nuestra implementar los mecanismos necesarios 
  para mantener esta sesi&oacute;n desde el cliente.</p>
<p>Vamos a ver como implementar los mecanismos para mantenimiento de sesiones 
  en las aplicaciones J2ME. Ser&aacute; m&aacute;s fiable utilizar reescritura 
  de URLs, ya que algunos <em>gateways</em> podr&iacute;an filtrar las <em>cookies</em> 
  y por lo tanto este mecanismo fallar&iacute;a. </p>
<p>Estos mecanismos de <em>cookies</em> y reescritura de URLs se utilizan para 
  que los navegadores mantengan las sesiones de una forma est&aacute;ndar para 
  todas las aplicaciones. Pero lo que pretendemos en &uacute;ltima instancia es 
  tener un identificador de la sesi&oacute;n en el cliente que pueda ser enviado 
  al servidor en cada petici&oacute;n. Si nos conectamos desde nuestra propia 
  aplicaci&oacute;n podremos utilizar nuestro propio identificador y enviarlo 
  al servidor de la forma que queramos (como cabecera, par&aacute;metro, en el 
  post, etc). Por ejemplo, podr&iacute;amos hacer que en cada petici&oacute;n 
  que haga nuestra aplicaci&oacute;n J2ME env&iacute;e nuestro <em>login</em> 
  al servidor, de forma que esta informaci&oacute;n le sirva al servidor para 
  identificarnos en cada momento.</p>
<p>Sin embargo, ser&aacute; conveniente que nuestra aplicaci&oacute;n implemente 
  alguno de los mecanismos est&aacute;ndar para el mantenimiento de sesiones, 
  ya que as&iacute; podremos aprovechar las facilidades que ofrecen los componentes 
  del servidor para mantener las sesiones. Ahora veremos como implementar las 
  t&eacute;cnicas de reescritura de URLs y <em>cookies</em> en nuestras aplicaciones 
  J2ME.</p>
<p><strong>Reescritura de URLs</strong></p>
<p>Algunos navegadores no soportan <em>cookies</em>. Para mantener sesiones en 
  este caso podemos utilizar la t&eacute;cnica de reescritura de URLs. Esta t&eacute;cnica 
  consiste en modificar las URLs a las que acceder&aacute; el cliente incluyendo 
  en ellas el identificador de sesi&oacute;n como par&aacute;metro.</p>
<p>Para utilizar esta t&eacute;cnica deberemos codificar la URL en el servidor 
  y devolverla de alguna forma al cliente. Por ejemplo, podemos devolver esta 
  URL modificada como una cabecera HTTP propia. Supongamos que devolvemos esta 
  URL reescrita como una cabecera <code>URL-Reescrita</code>. Podremos obtenerla 
  en la aplicaci&oacute;n cliente de la siguiente forma:</p>
<pre class="codigo">String url_con_ID = con.getHeaderField(&quot;URL-Reescrita&quot;);</pre>
<p>En la pr&oacute;xima petici&oacute;n que hagamos al servidor deberemos utilizar 
  la URL que hemos obtenido, en lugar de la URL b&aacute;sica a la que conectamos 
  inicialmente:</p>
<pre class="codigo">HttpConnection con = (HttpConnection)Connector.open(url_con_ID);</pre>
<p>De esta forma cuando establezcamos esta segunda conexi&oacute;n el <em>servlet</em> 
  al que conectamos sabr&aacute; que se trata de la misma sesi&oacute;n y podremos 
  acceder a la informaci&oacute;n de la sesi&oacute;n dentro del servidor.</p>
<p>En el c&oacute;digo del <em>servlet</em> que atiende nuestra petici&oacute;n 
  en el servidor deberemos rescribir la URL y devolv&eacute;rsela al cliente como 
  la cabecera que hemos visto anteriormente. Esto podemos hacerlo de la siguiente 
  forma:</p>
<pre class="codigo">String url = request.getRequestURL().toString();<br>String url_con_ID = response.<strong>encodeURL</strong>(url);<br>response.setHeader(&quot;URL-Reescrita&quot;, url_con_ID);</pre>
<p><strong>Manejo de cookies</strong></p>
<p>Los <em>servlets</em> utilizan las <em>cookies</em> para mantener la sesi&oacute;n 
  siempre que detecten que el cliente soporta <em>cookies</em>. Para el caso de 
  estas aplicaciones J2ME el <em>servlet</em> detectar&aacute; que el cliente 
  no soporta <em>cookies</em>, por lo que utilizar&aacute; &uacute;nicamente reescritura 
  de URLs. Sin embargo, si que podremos crear <em>cookies</em> manualmente en 
  el <em>servlet</em> para permitir mantener la informaci&oacute;n del usuario 
  en el cliente durante el tiempo que dure la sesi&oacute;n o incluso durante 
  m&aacute;s tiempo.</p>
<p>Desde las aplicaciones J2ME podremos implementar las sesiones utilizando <em>cookies</em>. 
  Adem&aacute;s con las <em>cookies</em> podremos mantener informaci&oacute;n 
  del usuario de forma persistente, no &uacute;nicamente durante una sola sesi&oacute;n. 
  Por ejemplo, podemos utilizar RMS para almacenar las <em>cookies</em> con informaci&oacute;n 
  sobre el usuario, de forma que cuando se vuelve a utilizar la aplicaci&oacute;n 
  en otro momento sigamos teniendo esta informaci&oacute;n. Con esto podemos por 
  ejemplo evitar que el usuario tenga que autentificarse cada vez que entra a 
  la aplicaci&oacute;n. </p>
<p>Estas <em>cookies</em> consisten en una pareja <em>&lt;nombre, valor&gt;</em> 
  y una fecha de caducidad. Con esta fecha de caducidad podemos indicar si la 
  <em>cookie</em> debe mantenerse s&oacute;lo durante la sesi&oacute;n actual, 
  o por m&aacute;s tiempo. </p>
<p>Podemos recibir las <em>cookies</em> que nos env&iacute;a el servidor leyendo 
  la cabecera <code>set-cookie</code> de la respuesta desde nuestra aplicaci&oacute;n 
  J2ME:</p>
<pre class="codigo">String cookie = con.<strong>getHeaderField</strong>(&quot;set-cookie&quot;);</pre>
<p>Una vez tengamos la <em>cookie</em> podemos guard&aacute;rnosla en memoria, 
  o bien en RMS si queremos almacenar persistentemente esta informaci&oacute;n. 
  En las siguientes peticiones que hagamos al servidor deberemos enviarle esta 
  cookie en la cabecera <code>cookie</code>:</p>
<pre class="codigo">con.<strong>setRequestProperty</strong>(&quot;cookie&quot;, cookie);</pre>
<h3><strong>13.2.3. Seguridad</strong></h3>
<p>Vamos a ver como crear aplicaciones seguras en cuando a la autentificaci&oacute;n 
  de los usuarios y a la confidencialidad de los datos que circulan por la red.</p>
<p><strong>Confidencialidad</strong></p>
<p>Para proteger los datos que circulan por la red, y evitar que alguien pueda 
  interceptarlos, podemos enviarlos codificados mediante SSL.</p>
<p>Podemos establecer una conexi&oacute;n segura con el servidor mediante SSL 
  (<em>Secure Sockets Layer</em>) simplemente indicando como protocolo en la URL 
  de la conexi&oacute;n <code>https</code> en lugar de <code>http</code>. </p>
<p>El problema es que la mayor&iacute;a de m&oacute;viles con MIDP 1.0 no soportan 
  este tipo de protocolo. Si intentamos utilizar HTTPS desde un dispositivo que 
  no lo soporta, obtendremos una excepci&oacute;n de tipo <code>ConnectionNotFoundException</code>. 
  Adem&aacute;s de tener que se soportada por el m&oacute;vil, este tipo de conexi&oacute;n 
  deber&aacute; ser soportada por el servidor.</p>
<p><strong>Autentificaci&oacute;n</strong></p>
<p>En muchas aplicaciones necesitaremos que el usuario se autentifique para que 
  de esa forma pueda acceder a determinados datos privados alojados en el servidor, 
  o pueda realizar determinadas acciones para las que no todos los usuarios tienen 
  permiso. </p>
<p>Para autentificar a los usuarios que se conectan desde el m&oacute;vil a las 
  aplicaciones corporativas, normalmente utilizaremos seguridad a nivel de la 
  aplicaci&oacute;n. Es decir, enviaremos nuestros credenciales (<em>login</em> 
  y <em>password</em>) a un <em>servlet</em> para que los verifique en la base 
  de datos de usuarios que haya en el servidor. </p>
<p>Una vez autentificados, podremos mantener esta informaci&oacute;n de registro 
  en la sesi&oacute;n del usuario, de forma que en sucesivas peticiones podamos 
  obtener la informaci&oacute;n sin necesidad de volvernos a autentificar en cada 
  una de ellas.</p>
<h3>13.2.4. Transacciones</h3>
<p>Cada petici&oacute;n HTTP que se haga el servidor ser&aacute; una transacci&oacute;n 
  independiente. Todas las operaciones de la transacci&oacute;n se deben realizar 
  dentro de esa conexi&oacute;n en el servidor, ya que las peticiones HTTP son 
  independientes entre si y el dispositivo cliente m&oacute;vil no realiza ninguna 
  gesti&oacute;n de transacciones. Por lo tanto las transacciones nunca supondr&aacute;n 
  m&aacute;s de una petici&oacute;n HTTP.</p>
<p>En el caso en el que la inserci&oacute;n de unos datos en la memoria local 
  dependa de que los datos sean aceptados por el servidor remoto, siempre realizaremos 
  antes la petici&oacute;n al servidor remoto, y una vez hayamos enviados estos 
  datos correctamente, haremos la inserci&oacute;n local. Esto se da por ejemplo 
  en el caso en que queremos mantener una copia local de los datos que enviamos 
  al servidor. S&oacute;lo insertaremos los datos en la copia local una vez hayan 
  sido insertados en el servidor.</p>
<h3>13.2.5. Gesti&oacute;n de errores</h3>
<p>Cuando estemos accediendo al lado del servidor de nuestra aplicaci&oacute;n 
  mediante HTTP, si la petici&oacute;n que hemos hecho produce un error no podremos 
  gestionar este error mediante excepciones ya que lo &uacute;nico que vamos a 
  recibir es una respuesta HTTP.</p>
<p>Para gestionar los errores del servidor deberemos almacenarlos de alguna forma 
  en el mensaje de respuesta HTTP. </p>
<p>Podemos utilizar el c&oacute;digo de estado de la respuesta para indicar la 
  presencia de alg&uacute;n error. Si necesitamos una mayor flexibilidad podemos 
  establecer nuestra propia codificaci&oacute;n para los errores dentro del contenido 
  de la respuesta, y hacer que nuestro cliente sea capaz de interpretar dicha 
  codificaci&oacute;n.</p>
<h2><strong>13.3. Arquitectura MVC</strong></h2>
<p>El patr&oacute;n de dise&ntilde;o MVC (Modelo-Vista-Controlador) suele aplicarse 
  para dise&ntilde;ar las aplicaciones web J2EE. Podemos aplicar este mismo patr&oacute;n 
  a las aplicaciones cliente J2ME. En una aplicaci&oacute;n cliente tendremos 
  los siguientes elementos:</p>
<ul>
  <li><strong>Modelo</strong>: Datos de la aplicaci&oacute;n.<br>
  </li>
  <li><strong>Vista</strong>: Presentaci&oacute;n de la aplicaci&oacute;n. Ser&aacute;n 
    las distintas pantallas de nuestro MIDlet. <br>
  </li>
  <li><strong>Controlador</strong>: El controlador ser&aacute; quien controle 
    el flujo de la aplicaci&oacute;n. Nos dir&aacute; qu&eacute; pantalla se debe 
    mostrar y que operaciones se deben ejecutar en cada momento, seg&uacute;n 
    las acciones realizadas.</li>
</ul>
<p>De esta forma con esta arquitectura estamos aislando datos, presentaci&oacute;n 
  y flujo de control. Es especialmente interesante el haber aislado los datos 
  del resto de componentes. De esta forma la capa de datos podr&aacute; decidir 
  si trabajar con datos de forma local con RMS o de forma remota a trav&eacute;s 
  de HTTP, sin afectar con ello al resto de la aplicaci&oacute;n. Este dise&ntilde;o 
  nos facilitar&aacute; cambiar de modo remoto a modo local cuando no queramos 
  tener que establecer una conexi&oacute;n de red.</p>
<h3>13.3.1. Modelo</h3>
<p>Normalmente en las aplicaciones para dispositivos m&oacute;viles vamos a trabajar 
  tanto con datos locales como con datos remotos. Por lo tanto, podemos ver el 
  modelo dividido en dos subsistemas: modelo local y modelo remoto. </p>
<p><strong>Modelo local</strong></p>
<p>El modelo local normalmente utilizar&aacute; un adaptador RMS para acceder 
  a los datos almacenados de forma persistente en el m&oacute;vil. Por ejemplo, 
  en nuestra aplicaci&oacute;n de agenda para la gesti&oacute;n de citas podemos 
  crear la siguiente clase para acceder a los datos locales:</p>
<pre class="codigo">public class <strong>ModeloLocal</strong> {<br><br>  AdaptadorRMS rms;<br><br>  public <strong>ModeloLocal</strong>() throws RecordStoreException {
    rms = new AdaptadorRMS();
  }<br><br>  /*
   * Agrega una cita indicando si esta pendiente de ser enviada al servidor
   */
  public void <strong>addCita</strong>(Cita cita, boolean pendiente) throws IOException,
                                                   RecordStoreException {
    int id = rms.addCita(cita);
    IndiceCita indice = new IndiceCita();
    indice.setId(id);
    indice.setFecha(cita.getFecha());
    indice.setAlarma(cita.isAlarma());
    indice.setPendiente(pendiente);
    rms.addIndice(indice);<br>  }<br><br>  /*
   * Obtiene todas las citas
   */
  public Cita[] <strong>listaCitas</strong>() throws RecordStoreException, IOException {
    return rms.listaCitas();
  }<br><br>  /*
   * Obtiene las citas correspondientes a los indices indicados
   */
  public Cita[] <strong>listaCitas</strong>(IndiceCita[] indices) throws RecordStoreException,
                                                        IOException {
    Cita[] citas = new Cita[indices.length];
    for (int i = 0; i &lt; indices.length; i++) {
      citas[i] = rms.getCita(indices[i].getId());
    }
<br>    return citas;<br>  } 
<br>  /*
   * Busca las citas con alarmas pendientes
   */
  public IndiceCita[] <strong>listaAlarmasPendientes</strong>() throws RecordStoreException,
                                                      IOException {
    IndiceCita[] indices = rms.buscaCitas(new Date(), true);<br>    return indices;
  }<br><br>  /*
   * Busca las citas pendientes de ser enviadas al servidor
   */
  public IndiceCita[] <strong>listaCitasPendientes</strong>() throws RecordStoreException,
                                                    IOException {
    IndiceCita[] indices = rms.listaCitasPendientes();<br>    return indices;
  }<br><br>  /*
   * Marca las citas indicada como enviadas al servidor
   */
  public void <strong>marcaEnviados</strong>(IndiceCita[] indices) throws IOException,
                                                   RecordStoreException {
    for (int i = 0; i &lt; indices.length; i++) {
      indices[i].setPendiente(false);
      rms.updateIndice(indices[i]);
    }
  }<br><br>  /*
   * Obtiene la configuracion local
   */
  public InfoLocal <strong>getInfoLocal</strong>() throws RecordStoreException, IOException {<br><br>    try {
      InfoLocal info = rms.getInfoLocal();
      return info;
    } catch (Exception e) { }<br><br>    InfoLocal info = new InfoLocal();
    rms.setInfoLocal(info);<br><br>    return info;
  }<br><br>  /*
   * Modifica la configuracion local
   */
  public void <strong>setInfoLocal</strong>(InfoLocal info) throws RecordStoreException,
                                                  IOException {
    rms.setInfoLocal(info);
  }<br><br>  /*
   * Libera recursos del modelo
   */
  public void <strong>destroy</strong>() throws RecordStoreException {
    rms.cerrar();
  }
}</pre>
<p>En esta clase definiremos m&eacute;todos para acceder a todos los datos locales 
  que nuestra aplicaci&oacute;n necesite utilizar.</p>
<p><strong>Modelo remoto</strong></p>
<p>Adem&aacute;s de la informaci&oacute;n local que almacenamos en el m&oacute;vil, 
  ser&aacute; importante tener acceso a los datos remotos de nuestra aplicaci&oacute;n 
  corporativa. Esta parte del modelo normalmente utilizar&aacute; HTTP para acceder 
  a estos datos. </p>
<p>Para implementar este subsistema del modelo podemos utilizar el patr&oacute;n 
  de dise&ntilde;o <em>proxy</em>. Este patr&oacute;n se utiliza cuando accedemos 
  a componentes remotos, encapsulando dentro de la clase <em>proxy</em> todo el 
  mecanismo de comunicaci&oacute;n necesario para acceder a las funcionalidades 
  del servidor.</p>
<p>De esta forma, cuando utilizamos un <em>proxy</em> para acceder a componentes 
  remotos, el que estos componentes se est&eacute;n utilizando de forma remota 
  es transparente para nosotros. El <em>proxy</em> implementa todo el mecanismo 
  de comunicaci&oacute;n necesario (por ejemplo HTTP), aislando al resto de la 
  aplicaci&oacute;n de &eacute;l. Invocaremos los m&eacute;todos del <em>proxy</em> 
  directamente para utilizar funcionalidades de nuestro servidor como si se tratase 
  de un acceso a un objeto local, sin preocuparnos de que realmente el <em>proxy</em> 
  est&eacute; realizando una conexi&oacute;n remota.</p>
<p>Por ejemplo, en el caso de nuestra agenda, el servidor nos proporcionar&aacute; 
  la funcionalidad de sincronizar las citas almacenadas en el m&oacute;vil con 
  las notas almacenadas en el servidor, para hacer que en ambos lados se tenga 
  el mismo conjunto de citas. Podemos encapsular esta operaci&oacute;n en una 
  clase <em>proxy</em> como la siguiente:</p>
<pre class="codigo">public class <strong>ProxyRemoto</strong> {<br><br>  public <strong>ProxyRemoto</strong>() {<br>  }<br><br>  public SyncItem <strong>sincroniza</strong>(SyncItem datosCliente) throws IOException {
    HttpConnection con = (HttpConnection) Connector.open(URL_SERVLET);<br><br>    // Envia datos al servidor
    DataOutputStream dos = con.openDataOutputStream();
    Cita[] citasCliente = datosCliente.getCitas();
    dos.writeLong(datosCliente.getTimeStamp());
    if (citasCliente == null) {
      dos.writeInt(0);
    } else {
      dos.writeInt(citasCliente.length);
      for (int i = 0; i &lt; citasCliente.length; i++) {
        citasCliente[i].serialize(dos);
      }
    }<br><br>    // Recibe datos del servidor
    DataInputStream dis = con.openDataInputStream();
    long tsServidor = dis.readLong();
    int nCitasServidor = dis.readInt();
    Cita[] citasServidor = new Cita[nCitasServidor];
    for (int i = 0; i &lt; nCitasServidor; i++) {
      citasServidor[i] = Cita.deserialize(dis);
    }<br><br>    SyncItem datosServidor = new SyncItem();
    datosServidor.setTimeStamp(tsServidor);
    datosServidor.setCitas(citasServidor);<br><br>    return datosServidor;
  }<br>}</pre>
<p>De esta forma desde el resto de la aplicaci&oacute;n simplemente tendremos 
  que invocar el m&eacute;todo <code>sincroniza</code> del <em>proxy</em> para 
  utilizar esta funcionalidad del servidor.</p>
<p><strong>Patr&oacute;n de dise&ntilde;o fachada</strong></p>
<p>Hasta ahora hemos visto que tenemos dos subsistemas en el modelo. Esta divisi&oacute;n 
  podr&iacute;a causar que el acceso al modelo desde nuestra aplicaci&oacute;n 
  fuese demasiado complejo. </p>
<p>Para evitar esto podemos utilizar el patr&oacute;n de dise&ntilde;o fachada 
  (<em>facade</em>). Este patr&oacute;n consiste un implementar una interfaz &uacute;nica 
  que integre varios subsistemas, proporcionando de esta forma una interfaz sencilla 
  para el acceso al modelo.</p>
<p>Desde el resto de la aplicaci&oacute;n accederemos al modelo siempre a trav&eacute;s 
  de la fachada, y &eacute;sta ser&aacute; quien se encargue de coordinar los 
  subsistemas local y remoto. Estos dos subsistemas se mantendr&aacute;n independientes, 
  pero accederemos a ellos mediante una interfaz &uacute;nica.</p>
<p>Por ejemplo, para nuestra agenda podemos definir una fachada como la siguiente 
  para el modelo:</p>
<pre class="codigo">public class <strong>FachadaModelo</strong> {<br><br>  boolean online;<br>  <strong>ModeloLocal</strong> mLocal;<br>  <strong>ProxyRemoto</strong> mRemoto;<br><br>  public <strong>FachadaModelo</strong>() throws RecordStoreException, IOException    {
    mLocal = new ModeloLocal();
    mRemoto = new ProxyRemoto();<br><br>    InfoLocal info = getConfig();
    online = info.isOnline();
  }<br><br>  /*
   * Crea una nueva cita
   */
  public void <strong>nuevaCita</strong>(Cita cita) throws IOException, RecordStoreException {
    mLocal.addCita(cita, true);
    if (online) {
      sincroniza();
    }
  }<br><br>  /*
   * Obtiene la lista de todas las citas
   */
  public Cita[] <strong>listaCitas</strong>() throws RecordStoreException, IOException {
    if (online) {
      sincroniza();
    }
    return mLocal.listaCitas();
  }<br><br>  /*
   * Obtiene la lista de citas con alarmas pendientes
   */
  public Cita[] <strong>listaAlarmasPendientes</strong>() throws RecordStoreException,
                                                IOException {
    if (online) {
      sincroniza();
    }
    IndiceCita[] indices = mLocal.listaAlarmasPendientes();
    return mLocal.listaCitas(indices);
  }<br> <br>  /*
   * Obtiene la configuracion local
   */
  public InfoLocal <strong>getConfig</strong>() throws RecordStoreException, IOException {
    return mLocal.getInfoLocal();
  }<br><br>  /*
   * Actualiza la configuracion local
   */
  public void <strong>updateConfig</strong>(InfoLocal config) throws RecordStoreException,
                                                    IOException {
    InfoLocal info = mLocal.getInfoLocal();
    info.setOnline(config.isOnline());
    this.online = config.isOnline();
    mLocal.setInfoLocal(info);
  }<br><br>  /*
   * Sincroniza la lista de citas con el servidor
   */
  public void <strong>sincroniza</strong>() throws RecordStoreException, IOException {<br><br>    // Obtiene datos del cliente   
<br>    InfoLocal info = mLocal.getInfoLocal();<br><br>    IndiceCita[] indices = mLocal.listaCitasPendientes();
    Cita[] citas = mLocal.listaCitas(indices);
    SyncItem datosCliente = new SyncItem();
    datosCliente.setCitas(citas);
    datosCliente.setTimeStamp(info.getTimeStamp());<br><br>    // Envia y recibe   
<br>    SyncItem datosServidor = mRemoto.sincroniza(datosCliente);<br><br>    mLocal.marcaEnviados(indices);<br><br>    // Agrega los datos recibidos del servidor<br><br>    Cita[] citasServidor = datosServidor.getCitas();
    if (citasServidor != null) {
      for (int i = 0; i &lt; citasServidor.length; i++) {
        mLocal.addCita(citasServidor[i], false);
      }
    }<br><br>    info.setTimeStamp(datosServidor.getTimeStamp());
    mLocal.setInfoLocal(info);
  }<br><br>  public void <strong>destroy</strong>() throws RecordStoreException {
    mLocal.destroy();
  }<br>}</pre>
<p>Podemos ver en este ejemplo como este modelo nos permite trabajar de forma 
  <em>online</em> u <em>offline</em>. Seg&uacute;n el modo de conexi&oacute;n, 
  se utilizar&aacute;n las funciones de uno u otro subsistema. En modo <em>online</em> 
  siempre que se haga una operaci&oacute;n se acceder&aacute; al servidor para 
  leer o almacenar las novedades que haya. En modo <em>offline</em> s&oacute;lo 
  se leer&aacute;n o almacenar&aacute;n los datos de forma local, excepto cuando 
  solicitemos de forma expl&iacute;cita sincronizar los datos con el servidor.</p>
<p>En el caso del m&eacute;todo <code>sincroniza</code>, que ser&aacute; el m&eacute;todo 
  encargado de coordinar informaci&oacute;n local con informaci&oacute;n remota, 
  podemos ver que la transacci&oacute;n de sincronizaci&oacute;n se realiza en 
  una &uacute;nica petici&oacute;n HTTP. Adem&aacute;s, los mensajes que se hayan 
  enviado al servidor no se marcan como enviados hasta despu&eacute;s de haber 
  completado el env&iacute;o (se llama a <code>marcaEnviados</code> despu&eacute;s 
  de llamar a <code>sincroniza</code>). </p>
<h3>13.3.2. Vista</h3>
<p>Para la vista crearemos una clase para cada pantalla de nuestra aplicaci&oacute;n, 
  como hemos visto en temas anteriores. La clase correspondiente a una pantalla 
  heredar&aacute; del tipo de displayable correspondiente y encapsular&aacute; 
  la creaci&oacute;n de la interfaz y la respuesta a los comandos.</p>
<p>Por ejemplo, para la edici&oacute;n de datos de las citas en nuestra aplicaci&oacute;n 
  podemos utilizar la siguiente pantalla:</p>
<pre class="codigo">public class <strong>EditaCitaUI</strong> extends <strong>Form</strong> implements <strong>CommandListener</strong> {<br><br>  ControladorUI controlador;<br><br>  DateField iFecha;
  TextField iAsunto;
  TextField iLugar;
  TextField iContacto;
  ChoiceGroup iAlarma;
  int itemAlarmaOn;
  int itemAlarmaOff;<br><br>  Command cmdAceptar;
  Command cmdCancelar;
  int eventoAceptar = ControladorUI.EVENTO_AGREGA_CITA;
  int eventoCancelar = ControladorUI.EVENTO_MUESTRA_MENU;<br><br>  Cita cita;
   <br>  public <strong>EditaCitaUI</strong>(ControladorUI controlador) {
    super(controlador.getString(Recursos.STR_DATOS_TITULO));<br>    this.controlador = controlador;<br><br>    iFecha = new DateField(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_FECHA), <br>      DateField.DATE_TIME);
   iAsunto = new TextField(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_ASUNTO), <br>      &quot;&quot;, MAX_LENGHT, TextField.ANY);
   iLugar = new TextField(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_LUGAR), <br>      &quot;&quot;, MAX_LENGHT, TextField.ANY);
   iContacto = new TextField(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_CONTACTO), <br>      &quot;&quot;, MAX_LENGHT, TextField.ANY);
   iAlarma = new ChoiceGroup(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_ALARMA),
      ChoiceGroup.EXCLUSIVE);
   itemAlarmaOn = iAlarma.append(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_ALARMA_ON), null);
   itemAlarmaOff = iAlarma.append(<br>      controlador.getString(Recursos.STR_DATOS_ITEM_ALARMA_OFF), null);<br><br>   this.append(iFecha);
   this.append(iAsunto);
   this.append(iLugar);
   this.append(iContacto);
   this.append(iAlarma);<br><br>   cmdAceptar = new Command(<br>     controlador.getString(Recursos.STR_CMD_ACEPTAR), Command.OK, 1);
   cmdCancelar = new Command(<br>     controlador.getString(Recursos.STR_CMD_CANCELAR), Command.CANCEL, 1);
   this.addCommand(cmdAceptar);
   this.addCommand(cmdCancelar);<br><br>   this.setCommandListener(this);
  }<br><br>  private void setCita(Cita cita) {
    if (cita == null) {
      this.cita = new Cita();
   
      iFecha.setDate(new Date());
      iAsunto.setString(null);
      iLugar.setString(null);
      iContacto.setString(null);
      iAlarma.setSelectedIndex(itemAlarmaOff, true);
    } else {
      this.cita = cita;
   
      iFecha.setDate(cita.getFecha());
      iAsunto.setString(cita.getAsunto());
      iLugar.setString(cita.getLugar());
      iContacto.setString(cita.getContacto());
      if (cita.isAlarma()) {
        iAlarma.setSelectedIndex(itemAlarmaOn, true);
      } else {
        iAlarma.setSelectedIndex(itemAlarmaOff, true);
      }
    }
  }<br><br>  private Cita getCita() {
    if(cita==null) {
      this.cita = new Cita(); 
    }
    if(iFecha.getDate()==null) {
      cita.setFecha(new Date());
    } else {
      cita.setFecha(iFecha.getDate()); 
    }
    cita.setAsunto(iAsunto.getString());
    cita.setLugar(iLugar.getString());
    cita.setContacto(iContacto.getString());
    cita.setAlarma(iAlarma.getSelectedIndex() == itemAlarmaOn);<br>
    return cita;
  }<br><br>  public void reset(Cita cita, int eventoAceptar, int eventoCancelar) {
    this.setCita(cita);
    this.eventoAceptar = eventoAceptar;
    this.eventoCancelar = eventoCancelar;
  }<br><br>  public void <strong>commandAction</strong>(Command cmd, Displayable disp) {
    if (cmd == cmdAceptar) {
      controlador.<strong>procesaEvento</strong>(eventoAceptar, this.getCita());
    } else if (cmd == cmdCancelar) {
      controlador.<strong>procesaEvento</strong>(eventoCancelar, null);
    }
  }
}</pre>
<p>Intentaremos llevar la mayor parte de la gesti&oacute;n de eventos al controlador, 
  para as&iacute; aislar lo m&aacute;s posible la vista del controlador. En la 
  vista implementaremos la interfaz <code>commandAction</code>, pero el procesamiento 
  de los eventos lo har&aacute; el controlador mediante el m&eacute;todo <code>procesaEvento</code> 
  que veremos a continuaci&oacute;n.</p>
<h3>13.3.3. Controlador</h3>
<p>El controlador ser&aacute; el encargado de controlar el flujo de la aplicaci&oacute;n. 
  Seg&uacute;n las acciones realizadas, el controlador mostrar&aacute; distintas 
  pantalla y realizar&aacute; diferentes operaciones en el modelo.</p>
<p>Por ejemplo, el controlador para nuestra agenda ser&aacute; el siguiente:</p>
<pre class="codigo">public class <strong>ControladorUI</strong> {<br>
  /*
   * Tipos de eventos
   */
  public final static int EVENTO_MUESTRA_MENU = 0;
  public final static int EVENTO_MUESTRA_NUEVA_CITA = 1;
  public final static int EVENTO_MUESTRA_LISTA_CITAS = 2;
  public final static int EVENTO_MUESTRA_DATOS_CITA = 3;
  public final static int EVENTO_MUESTRA_LISTA_ALARMAS_PENDIENTES = 4;
  public final static int EVENTO_MUESTRA_DATOS_ALARMA_PENDIENTE = 5;
  public final static int EVENTO_AGREGA_CITA = 6;
  public final static int EVENTO_SALIR = 8;
  public final static int EVENTO_SINCRONIZAR = 9;
  public final static int EVENTO_MUESTRA_CONFIG =10;
  public final static int EVENTO_APLICA_CONFIG = 11;<br><br>  /*
   * Componentes de la UI
   */
  <strong>DatosCitaUI</strong> uiDatosCita;
  <strong>EditaCitaUI</strong> uiEditaCita;
  <strong>ListaCitasUI</strong> uiListaCitas;
  <strong>EditaConfigUI</strong> uiEditaConfig;
  <strong>MenuPrincipalUI</strong> uiMenuPrincipal;
  <strong>BarraProgresoUI</strong> uiBarraProgreso;
   
  /*
   * Gestor de recursos
   */
  <strong>Recursos</strong> recursos;
   
  /*
   * Modelo
   */
  <strong>FachadaModelo</strong> modelo;
   
  MIDletAgenda midlet;
  Display display;
   
  public ControladorUI(MIDletAgenda midlet) {
    this.midlet = midlet;
    display = Display.getDisplay(midlet);
   
    init();
  }
   
  /*
   * Inicializacion de los componentes de la UI
   */
  public void init() {
   
    // Crea gestor de recursos
    recursos = new <strong>Recursos</strong>();<br><br>    // Crea UI
    uiDatosCita = new <strong>DatosCitaUI</strong>(this);
    uiEditaCita = new <strong>EditaCitaUI</strong>(this);
    uiListaCitas = new <strong>ListaCitasUI</strong>(this);
    uiEditaConfig = new <strong>EditaConfigUI</strong>(this);
    uiMenuPrincipal = new <strong>MenuPrincipalUI</strong>(this);
    uiBarraProgreso = new <strong>BarraProgresoUI</strong>(this);
   
    try {
      // Crea modelo
      modelo = new <strong>FachadaModelo</strong>(alarmas);
    } catch (Exception e) {
      e.printStackTrace();
    }  
  }
   
  public void destroy() throws RecordStoreException {
    modelo.destroy();
  }
   
  public void showMenu() {
    display.setCurrent(uiMenuPrincipal);
  }
   
  public String getString(int cod) {
    return recursos.getString(cod);
  }
   
  /*
   * Lanza el procesamiento de un evento
   */
  public void <strong>procesaEvento</strong>(int evento, Object param) {
    HiloEventos he = new HiloEventos(evento, param);
    he.start();
  }
   
  /*
   * Hilo para el procesamiento de eventos
   */
  class HiloEventos extends Thread {
    int evento;
    Object param;
   
    public HiloEventos(int evento, Object param) {
      this.evento = evento;
      this.param = param;
    }
   
    public void run() {
      Cita cita;
      Cita [] citas;
      InfoLocal info;
   
      try {
        switch(evento) {
          case EVENTO_MUESTRA_MENU:
            showMenu();
            break;<br>
          case EVENTO_MUESTRA_NUEVA_CITA:
            uiEditaCita.reset(null, <br>                ControladorUI.EVENTO_AGREGA_CITA, <br>                ControladorUI.EVENTO_MUESTRA_MENU);
            display.setCurrent(uiEditaCita); 
            break;
<br>          case EVENTO_AGREGA_CITA:
            cita = (Cita)param;
            modelo.nuevaCita(cita);
            showMenu();
            break;
<br>          case EVENTO_MUESTRA_LISTA_CITAS:
            uiBarraProgreso.reset(<br>                getString(Recursos.STR_PROGRESO_CARGA_LISTA), <br>                10, 0, true);
            display.setCurrent(uiBarraProgreso);
            citas = modelo.listaCitas();
            uiListaCitas.reset(citas, <br>                ControladorUI.EVENTO_MUESTRA_DATOS_CITA, <br>                ControladorUI.EVENTO_MUESTRA_MENU);
            display.setCurrent(uiListaCitas);
            break;
<br>          case EVENTO_MUESTRA_DATOS_CITA:
            cita = (Cita)param;
            uiDatosCita.reset(cita, <br>                ControladorUI.EVENTO_MUESTRA_LISTA_CITAS);
            display.setCurrent(uiDatosCita);
            break;
<br>          case EVENTO_MUESTRA_LISTA_ALARMAS_PENDIENTES:
            uiBarraProgreso.reset(<br>                getString(Recursos.STR_PROGRESO_CARGA_LISTA), <br>                10, 0, true);
            display.setCurrent(uiBarraProgreso);
            citas = modelo.listaAlarmasPendientes();
            uiListaCitas.reset(citas, <br>                ControladorUI.EVENTO_MUESTRA_DATOS_ALARMA_PENDIENTE,<br>                ControladorUI.EVENTO_MUESTRA_MENU);
            display.setCurrent(uiListaCitas);
            break;
<br>          case EVENTO_MUESTRA_DATOS_ALARMA_PENDIENTE:
            cita = (Cita)param;
            uiDatosCita.reset(cita, <br>                ControladorUI.EVENTO_MUESTRA_LISTA_ALARMAS_PENDIENTES);
            display.setCurrent(uiDatosCita);
            break;
<br>          case EVENTO_SINCRONIZAR: 
            uiBarraProgreso.reset(<br>                getString(Recursos.STR_PROGRESO_SINCRONIZA), <br>                10, 0, true);
            display.setCurrent(uiBarraProgreso);
            modelo.sincroniza();
            display.setCurrent(uiMenuPrincipal);
            break;
<br>          case EVENTO_MUESTRA_CONFIG:
            info = modelo.getConfig();
            uiEditaConfig.reset(info, <br>                ControladorUI.EVENTO_APLICA_CONFIG, <br>                ControladorUI.EVENTO_MUESTRA_MENU);
            display.setCurrent(uiEditaConfig); 
            break;
<br>          case EVENTO_APLICA_CONFIG:
            info = (InfoLocal)param;
            modelo.updateConfig(info);
            display.setCurrent(uiMenuPrincipal); 
            break;
<br>          case EVENTO_SALIR: 
            midlet.salir();
            break;
        } 
      } catch(Exception e) {
        e.printStackTrace();
      }
    }
  }<br>}</pre>
<p>Vemos en este ejemplo que el controlador tiene acceso al modelo a trav&eacute;s 
  de la fachada, y tambi&eacute;n tiene acceso a las diferentes pantallas de la 
  interfaz de usuario (UI). A trav&eacute;s de estos elementos controlar&aacute; 
  la presentaci&oacute;n de la aplicaci&oacute;n y la l&oacute;gica de negocio 
  de la misma.</p>
<p>Este controlador se encargar&aacute; de dar respuesta a los eventos que se 
  produzcan en la aplicaci&oacute;n. Vemos que para hacer esto se utiliza un m&eacute;todo 
  <code>procesaEvento</code> que a su vez utiliza un hilo para procesar el evento 
  solicitado. Esto se hace as&iacute; para no bloquear el hilo de la aplicaci&oacute;n 
  al realizar operaciones que normalmente ser&aacute;n de larga duraci&oacute;n.</p>
<p>Tenemos varios tipos de eventos definidos como constantes, y para cada uno 
  de ellos especificaremos las operaciones a realizar y los componentes de la 
  UI que se deben mostrar. Se puede observar en el ejemplo que en las operaciones 
  que son de m&aacute;s larga duraci&oacute;n, el controlador mientras la realiza 
  muestra en pantalla una barra de progreso.</p>
<p>Tambi&eacute;n se puede observar que todas las cadenas de texto se encuentran 
  centralizadas en la clase <code>Recursos</code>. Todos los componentes de la 
  aplicaci&oacute;n obtendr&aacute;n el texto de esta clase. Esto nos facilitar&aacute; 
  tareas como la traducci&oacute;n de nuestra aplicaci&oacute;n a otros idiomas.</p>
<p>Para la internacionalizaci&oacute;n de la aplicaci&oacute;n, podr&iacute;amos 
  hacer que la clase <code>Recursos</code> cargase todas las cadenas de texto 
  de un fichero externo. De esta forma, cambiando este fichero podremos cambiar 
  el idioma de nuestra aplicaci&oacute;n. Podr&iacute;amos permitir que el usuario 
  se descargase ficheros con otros idiomas.</p>
<h2>13.4. Modo sin conexi&oacute;n</h2>
<p>Hemos visto que en las aplicaciones MIDP es conveniente permitir trabajar sin 
  conexi&oacute;n, trabajando con datos locales. Tambi&eacute;n hemos visto como 
  con el patr&oacute;n MVC podemos dividir el modelo en dos subsistemas para permitir 
  los dos modos de funcionamiento: con y sin conexi&oacute;n.</p>
<p>Vamos ahora a estudiar m&aacute;s a fondo el funcionamiento de este tipo de 
  aplicaciones.</p>
<h3>13.4.1. Tipos de aplicaciones</h3>
<p>Podemos distinguir varios tipos de aplicaciones:</p>
<ul>
  <li><em>Thin</em>: Este tipo de aplicaciones son por ejemplo los navegadores, 
    en los que todo el procesamiento se realiza en el servidor. En el cliente 
    tenemos una aplicaci&oacute;n gen&eacute;rica (navegador) que se encarga de 
    obtener documentos del servidor y mostrarlos en la pantalla.</li>
  <li><em>Thick</em>: Aplicaciones dedicadas. Son aplicaciones para tareas concretas 
    que llevan al cliente la l&oacute;gica de presentaci&oacute;n. Permiten realizar 
    una presentaci&oacute;n sofisticada de datos. Por ejemplo, podremos realizar 
    una ordenaci&oacute;n de los datos en el cliente. </li>
  <li><em>Standalone</em>: Llevan todo el procesamiento al cliente. Estas aplicaciones 
    son por ejemplo el bloc de notas, calculadora, juegos, etc. Pueden conectarse 
    de forma ocasional al servidor para actualizar datos, normalmente a petici&oacute;n 
    del usuario.</li>
</ul>
<p>Nos centraremos en el estudio de las aplicaciones de tipo thick. Estas aplicaciones 
  deber&aacute;n trabajar de forma coordinada con el servidor, pero podremos permitir 
  trabajar sin conexi&oacute;n. El permitir trabajar en este modo nos trae la 
  ventaja de que minimiza el trafico en la red, sin embargo aumentar&aacute; el 
  coste de procesamiento, memoria y almacenamiento en el dispositivo local. Deberemos 
  por lo tanto buscar un compromiso entre estos dos factores.</p>
<h3>13.4.2. Replicaci&oacute;n de datos</h3>
<p>Para poder trabajar sin conexi&oacute;n es imprescindible replicar en nuestro 
  dispositivo datos del servidor. Por lo tanto tendremos dos tipos de datos en 
  el cliente:</p>
<ul>
  <li>Datos replicados: Necesitaremos sincronizarlos con el servidor.</li>
  <li>Datos propios: Son s&oacute;lo del cliente.</li>
</ul>
<p>Adem&aacute;s, dentro de los datos replicados del servidor podemos distinguir:</p>
<ul>
  <li>Datos de solo lectura: Cach&eacute; de datos del servidor. S&oacute;lo tendremos 
    que preocuparnos de renovar estos datos cuando hayan caducado.</li>
  <li>Datos de lectura/escritura: En este caso necesitaremos sincronizar los datos 
    locales con el servidor. Si se modifica la copia local, deberemos aplicar 
    esta modificaci&oacute;n a la copia remota posteriormente.</li>
</ul>
<p>El modelo de r&eacute;plica de datos que utilicemos se caracterizar&aacute; 
  por los siguientes factores:</p>
<ul>
  <li>&iquest;Se replican todos los datos o s&oacute;lo una parte de ellos?</li>
  <li>&iquest;Las estructuras de datos se replican fielmente o no?</li>
  <li>&iquest;Los datos son de lectura/escritura o de s&oacute;lo lectura?</li>
  <li>&iquest;Los mismos datos pueden ser compartidos y replicados por muchos 
    usuarios?</li>
  <li>&iquest;Los datos tienen fecha de caducidad?</li>
</ul>
<p>Seg&uacute;n estos factores deberemos decidir el modelo de sincronizaci&oacute;n 
  adecuado para nuestra aplicaci&oacute;n.</p>
<p>Para facilitar la sincronizaci&oacute;n es conveniente reducir la granularidad 
  de los datos en el almacenamiento, es decir, reducir la cantidad de datos que 
  se almacenen juntos en el mismo registro.</p>
<h3>13.4.3. Sincronizaci&oacute;n de los datos</h3>
<p>Los datos de nuestra aplicaci&oacute;n se pueden transferir de diferentes formas:</p>
<ul>
  <li>El cliente descarga peri&oacute;dicamente datos del servidor. En este caso 
    simplemente deberemos mantener una cach&eacute; de datos. Podremos renovar 
    esta cach&eacute; cuando haya pasado la fecha de caducidad de los datos, cada 
    cierto per&iacute;odo fijo, o cuando el usuario lo solicite.</li>
  <li>El cliente env&iacute;a datos propios (no compartidos) al servidor. Deberemos 
    actualizar en el servidor los datos que hayamos modificado en el cliente.</li>
  <li>El cliente env&iacute;a al servidor datos compartidos con varios usuarios. 
    Este es el caso m&aacute;s complicado, ya que varios clientes podr&iacute;an 
    estar modificando los mismos datos al mismo tiempo en sus copias locales. 
  </li>
</ul>
<p><strong>Descarga de datos del servidor</strong></p>
<p>Este caso se puede resolver de forma sencilla. Las actualizaciones de los datos 
  se pueden hacer de varias formas:</p>
<ul>
  <li>Si conocemos cuando caducar&aacute;n los datos, podemos ponerles una fecha 
    de caducidad, y una vez pasada &eacute;sta forzaremos a que se descargue nuevos 
    datos de la red. Por ejemplo, si tenemos una aplicaci&oacute;n para consultar 
    la cartelera de los cines, como sabemos que las pel&iacute;culas se estrenan 
    los viernes, podemos hacer que los datos caduquen este d&iacute;a. De esta 
    forma cada viernes cuando utilicemos la aplicaci&oacute;n volver&aacute; a 
    descargar nuevas pel&iacute;culas.<br>
  </li>
  <li>Si desconocemos esta fecha de caducidad, podr&iacute;amos hacer que el m&oacute;vil 
    los actualice cada cierto per&iacute;odo fijo (<em>polling</em>), o bien dejar 
    que el usuario decida cuando quiere actualizar estos datos.</li>
</ul>
<p>En muchas aplicaciones necesitaremos identificar qu&eacute; datos no descargados 
  todav&iacute;a hay en el servidor. Por ejemplo, imaginemos nuestra aplicaci&oacute;n 
  de agenda. Podemos crear nuevas citas utilizando un navegador web en nuestro 
  PC o desde otro dispositivo. Cuando ejecutemos la aplicaci&oacute;n en nuestro 
  m&oacute;vil, para actualizar la agenda deber&aacute; descargar las nuevas citas 
  que se hayan creado en el servidor.</p>
<p>Pero, &iquest;c&oacute;mo podemos saber qu&eacute; citas son nuevas? Podemos 
  utilizar estampas de tiempo (timestamps) para etiquetar cada cita, de forma 
  que cada nueva cita que a&ntilde;adamos al servidor tenga una estampa de tiempo 
  superior a la de la anterior cita. </p>
<pre class="codigo">public void sincroniza() throws RecordStoreException, IOException {<br><br>  // Obtiene datos del cliente
   
  InfoLocal info = mLocal.getInfoLocal();<br>  IndiceCita[] indices = mLocal.listaCitasPendientes();
  Cita[] citas = mLocal.listaCitas(indices);
  SyncItem datosCliente = new SyncItem();
  datosCliente.setCitas(citas);
  datosCliente.<strong>setTimeStamp</strong>(info.<strong>getTimeStamp</strong>());<br><br>  // Envia y recibe
   
  SyncItem datosServidor = mRemoto.<strong>sincroniza</strong>(datosCliente);<br><br>  mLocal.marcaEnviados(indices);<br>  <br>  // Agrega los datos recibidos del servidor<br>  <br>  Cita[] citasServidor = datosServidor.getCitas();
  if (citasServidor != null) {
    for (int i = 0; i &lt; citasServidor.length; i++) {
      mLocal.addCita(citasServidor[i], false);
    }
  }<br><br>  info.<strong>setTimeStamp</strong>(datosServidor.<strong>getTimeStamp</strong>());
  mLocal.setInfoLocal(info);
}</pre>
<p>En nuestro dispositivo nos guardaremos el n&uacute;mero de la &uacute;ltima 
  estampa de tiempo obtenida. Cuando solicitemos los nuevos datos al servidor, 
  le proporcionaremos esta estampa de tiempo para que nos devuelva s&oacute;lo 
  aquellas citas que sean posteriores. Junto a estas citas nos devolver&aacute; 
  una nueva estampa de tiempo correspondiente al &uacute;ltimo dato que hayamos 
  recibido. El cliente tendr&aacute; la responsabilidad de almacenar esta estampa 
  de tiempo para poder utilizarla en la pr&oacute;xima petici&oacute;n.</p>
<p><strong>Env&iacute;o de datos no compartidos al servidor</strong></p>
<p>En este caso deberemos actualizar cada cierto per&iacute;odo en el servidor 
  los datos que hayamos modificado en nuestro dispositivo. La actualizaci&oacute;n 
  podemos hacer que sea autom&aacute;tica, cada cierto per&iacute;odo de tiempo, 
  o manual, a petici&oacute;n del usuario.</p>
<p>Para actualizar los datos deberemos conocer qu&eacute; datos han cambiado desde 
  la &uacute;ltima actualizaci&oacute;n. Para ello podremos a&ntilde;adir a los 
  datos almacenados en RMS un atributo que nos diga si hay cambios pendientes 
  de actualizar en dicho dato.</p>
<p>Si hemos creado &iacute;ndices para nuestros registros de RMS, podremos a&ntilde;adir 
  este atributo a los &iacute;ndices, para facilitar de esta forma la b&uacute;squeda 
  de estos datos.</p>
<pre class="codigo">public class IndiceCita {<br>  int rmsID;<br>  int id;<br>  Date fecha;<br>  boolean alarma;<br>  boolean <strong>pendiente</strong>;
}</pre>
<p>Podemos ver aqu&iacute; la raz&oacute;n por la que preferimos una granularidad 
  fina de los datos almacenados. Si tuvi&eacute;semos almacenados muchos datos 
  en un mismo registro, y modificamos una peque&ntilde;a parte de estos datos, 
  tendremos que marcar todo el registro como modificado, por lo que habr&aacute; 
  que subir al servidor un mayor volumen de datos. Si estos datos hubiesen estado 
  repartidos en varios registros, s&oacute;lo hubiese hecho falta actualizar la 
  parte que hubiese cambiado.</p>
<p><strong>Env&iacute;o de datos compartidos al servidor</strong></p>
<p>Este caso es el m&aacute;s complejo. Existe una copia maestra de los datos 
  almacenada en el servidor, y varias copias locales, conocidas como copias legales, 
  que se descargan los usuarios a sus dispositivos. </p>
<p>Si varios clientes han descargado los datos en sus m&oacute;viles, y modifican 
  su copia legal, cuando actualicen los datos en la copia maestra del servidor 
  podr&iacute;an sobrescribir el trabajo de otros usuarios.</p>
<p>Para poder corregir estos conflictos de la mejor forma posible, deberemos tener 
  una granularidad muy fina de los datos, de forma que los usuarios s&oacute;lo 
  modifiquen las porciones de los datos que hayan modificado. De esta forma, si 
  nosotros hemos modificado una parte de los datos que otro usuario no ha tocado, 
  cuando el otro usuario actualice los datos no sobrescribir&aacute; dicha parte.</p>
<p>Para decidir qu&eacute; versi&oacute;n de los datos mantener en la copia maestra 
  podemos tomar diferentes criterios:</p>
<ul>
  <li>Sobrescribir directamente el &uacute;ltimo que llegue al servidor</li>
  <li>Mantener el que tenga fecha de modificaci&oacute;n posterior</li>
  <li>Mantener el que tenga fecha de modificaci&oacute;n anterior</li>
  <li>etc</li>
</ul>
<p>Deberemos intentar solucionar los conflictos sin necesidad de solicitar la 
  intervenci&oacute;n del usuario, aunque en ciertas ocasiones la mejor soluci&oacute;n 
  puede ser preguntar qu&eacute; copia de los datos desea que se mantenga.</p>
<p></p>
</body>
</html>
