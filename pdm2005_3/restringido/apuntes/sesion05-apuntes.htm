<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Sesi&oacute;n 5: Gr&aacute;ficos avanzados</title>
<link rel="stylesheet" href="../apuntes.css" type="text/css">
</head>
<body>
<h1> 6. Gr&aacute;ficos avanzados</h1>
<p>Hasta ahora hemos visto la creaci&oacute;n de aplicaciones con una interfaz 
  gr&aacute;fica creada a partir de una serie de componentes de alto nivel definidos 
  en la API LCDUI (alertas, campos de texto, listas, formularios).</p>
<p>En este punto veremos como dibujar nuestros propios gr&aacute;ficos directamente 
  en pantalla. Para ello Java nos proporciona acceso a bajo nivel al contexto 
  gr&aacute;fico del &aacute;rea donde vayamos a dibujar, permiti&eacute;ndonos 
  a trav&eacute;s de &eacute;ste modificar los <em>pixels</em> de este &aacute;rea, 
  dibujar una serie de figuras geom&eacute;tricas, as&iacute; como volcar im&aacute;genes 
  en ella.</p>
<p>Tambi&eacute;n podremos acceder a la entrada del usuario a bajo nivel, conociendo 
  en todo momento cu&aacute;ndo el usuario pulsa o suelta cualquier tecla del 
  m&oacute;vil. </p>
<p>Este acceso a bajo nivel ser&aacute; necesario en aplicaciones como juegos, 
  donde debemos tener un control absoluto sobre la entrada y sobre lo que dibujamos 
  en pantalla en cada momento. El tener este mayor control tiene el inconveniente 
  de que las aplicaciones ser&aacute;n menos portables, ya que dibujaremos los 
  gr&aacute;ficos pensando en una determinada resoluci&oacute;n de pantalla y 
  un determinado tipo de teclado, pero cuando la queramos llevar a otro dispositivo 
  en el que estos componentes sean distintos deberemos hacer cambios en el c&oacute;digo.</p>
<p>Por esta raz&oacute;n para las aplicaciones que utilizan esta API a bajo nivel, 
  como los juegos Java para m&oacute;viles, encontramos distintas versiones para 
  cada modelo de dispositivo. Dada la heterogeneidad de estos dispositivos, resulta 
  m&aacute;s sencillo rehacer la aplicaci&oacute;n para cada modelo distinto que 
  realizar una aplicaci&oacute;n adaptable a las caracter&iacute;sticas de cada 
  modelo.</p>
<p>Al programar las aplicaciones deberemos facilitar en la medida de lo posible 
  futuros cambios para adaptarla a otros modelos, permitiendo reutilizar la m&aacute;xima 
  cantidad de c&oacute;digo posible.</p>
<h2 class="subsection">6.1. Gr&aacute;ficos en LCDUI</h2>
<p>La API de gr&aacute;ficos a bajo nivel de LCDUI es muy parecida a la existente 
  en AWT, por lo que el aprendizaje de esta API para programadores que conozcan 
  la de AWT va a ser casi inmediato. </p>
<p>Las clases que implementan la API de bajo nivel en LCDUI son <code>Canvas</code> 
  y <code>Graphics</code>. Estas clases reciben el mismo nombre que las de AWT, 
  y se utilizan de una forma muy parecida. Tienen alguna diferencia en cuanto 
  a su interfaz para adaptarse a las necesidades de los dispositivos m&oacute;viles.</p>
<p>El <code>Canvas</code> es un tipo de elemento <em>displayable</em> correspondiente 
  a una pantalla vac&iacute;a en la que nosotros podremos dibujar a bajo nivel 
  el contenido que queramos. Adem&aacute;s este componente nos permitir&aacute; 
  leer los eventos de entrada del usuario a bajo nivel.</p>
<p>Esta pantalla del m&oacute;vil tiene un contexto gr&aacute;fico asociado que 
  nosotros podremos utilizar para dibujar en ella. Este objeto encapsula el <em>raster</em> 
  de pantalla (la matriz de <em>pixels</em> de los que se compone la pantalla) 
  y adem&aacute;s tiene una serie de atributos con los que podremos modificar 
  la forma en la que se dibuja en este <em>raster</em>. Este contexto gr&aacute;fico 
  se definir&aacute; en un objeto de la clase <code>Graphics</code>. Este objeto 
  nos ofrece una serie de m&eacute;todos que nos permiten dibujar distintos elementos 
  en pantalla. M&aacute;s adelante veremos con detalle los m&eacute;todos m&aacute;s 
  importantes.</p>
<p>Este objeto <code>Graphics</code> para dibujar en la pantalla del dispositivo 
  nos lo deber&aacute; proporcionar el sistema en el momento en que se vaya a 
  dibujar, no podremos obtenerlo nosotros por nuestra cuenta de ninguna otra forma. 
  Esto es lo que se conoce como <em>render</em> pasivo, definimos la forma en 
  la que se dibuja pero es el sistema el que decidir&aacute; cu&aacute;ndo hacerlo.</p>
<h3><strong>6.1.1. Creaci&oacute;n de un Canvas</strong></h3>
<p>Para definir la forma en la que se va a dibujar nuestro componente deberemos 
  extender la clase <code>Canvas</code> redefiniendo su m&eacute;todo <code>paint</code>. 
  Dentro de este m&eacute;todo es donde definiremos c&oacute;mo se realiza el 
  dibujado de la pantalla. Esto lo haremos de la siguiente forma:</p>
<pre class="codigo">public class MiCanvas <strong>extends Canvas</strong> {
	public void <strong>paint(Graphics g)</strong> {
		// Dibujamos en la pantalla
		// usando el objeto g proporcionado
	}
}</pre>
<p>Con esto en la clase <code>MiCanvas</code> hemos creado una pantalla en la 
  que nosotros controlamos lo que se dibuja. Este m&eacute;todo <code>paint</code> 
  nunca debemos invocarlo nosotros, ser&aacute; el sistema el que se encargue 
  de invocarlo cuando necesite dibujar el contenido de la pantalla. En ese momento 
  se proporcionar&aacute; como par&aacute;metro el objeto correspondiente al contexto 
  gr&aacute;fico de la pantalla del dispositivo, que podremos utilizar para dibujar 
  en ella. Dentro de este m&eacute;todo es donde definiremos c&oacute;mo dibujar 
  en la pantalla, utilizando para ello el objeto de contexto gr&aacute;fico <code>Graphics</code>.</p>
<p>Siempre deberemos dibujar utilizando el objeto <code>Graphics</code> dentro 
  del m&eacute;todo <code>paint</code>. Guardarnos este objeto y utilizarlo despu&eacute;s 
  de haberse terminado de ejecutar <code>paint</code> puede producir un comportamiento 
  indeterminado, y por lo tanto no debe hacerse nunca.</p>
<h3><strong>6.1.2. Propiedades del Canvas</strong></h3>
<p>Las pantallas de los dispositivos pueden tener distintas resoluciones. Adem&aacute;s 
  normalmente el &aacute;rea donde podemos dibujar no ocupa toda la pantalla, 
  ya que el m&oacute;vil utiliza una franja superior para mostrar informaci&oacute;n 
  como la cobertura o el t&iacute;tulo de la aplicaci&oacute;n, y en la franja 
  inferior para mostrar los comandos disponibles.</p>
<p>Sin embargo, a partir de MIDP 2.0 aparece la posibilidad de utilizar modo a 
  pantalla completa, de forma que controlaremos el contenido de toda la pantalla. 
  Para activar el modo a pantalla completa utilizaremos el siguiente m&eacute;todo:</p>
<pre class="codigo"><strong>setFullScreenMode</strong>(true); // Solo disponible a partir de MIDP 2.0</pre>
<p>Es probable que nos interese conocer desde dentro de nuestra aplicaci&oacute;n 
  el tama&ntilde;o real del &aacute;rea del <code>Canvas</code> en la que podemos 
  dibujar. Para ello tenemos los m&eacute;todos <code>getWidth</code> y <code>getHeight</code> 
  de la clase <code>Canvas</code>, que nos devolver&aacute;n el ancho y el alto 
  del &aacute;rea de dibujo respectivamente.</p>
<p>Para obtener informaci&oacute;n sobre el n&uacute;mero de colores soportados 
  deberemos utilizar la clase <code>Display</code> tal como vimos anteriormente, 
  ya que el n&uacute;mero de colores es propio de todo el visor y no s&oacute;lo 
  del &aacute;rea de dibujo.</p>
<h3><strong>6.1.3. Mostrar el Canvas</strong></h3>
<p>Podemos mostrar este componente en la pantalla del dispositivo igual que mostramos 
  cualquier otro <em>displayable</em>:</p>
<pre class="codigo">MiCanvas mc = <strong>new MiCanvas()</strong>;
mi_display.<strong>setCurrent</strong>(mc);</pre>
<p> Es posible que queramos hacer que cuando se muestre este <em>canvas</em> se 
  realice alguna acci&oacute;n, como por ejemplo poner en marcha alguna animaci&oacute;n 
  que se muestre en la pantalla. De la misma forma, cuando el <em>canvas</em> 
  se deje de ver deberemos detener la animaci&oacute;n. Para hacer esto deberemos 
  tener constancia del momento en el que el <em>canvas</em> se muestra y se oculta. 
</p>
<p>Podremos saber esto debido a que los m&eacute;todos <code>showNotify</code> 
  y <code>hideNotify</code> de la clase <code>Canvas</code> ser&aacute;n invocados 
  son invocados por el sistema cuando dicho componente se muestra o se oculta 
  respectivamente. Nosotros podremos en nuestra subclase de <code>Canvas</code> 
  redefinir estos m&eacute;todos, que por defecto est&aacute;n vac&iacute;os, 
  para definir en ellos el c&oacute;digo que se debe ejecutar al mostrarse u ocultarse 
  nuestro componente. Por ejemplo, si queremos poner en marcha o detener una animaci&oacute;n, 
  podemos redefinir los m&eacute;todos como se muestra a continuaci&oacute;n:</p>
<pre class="codigo">public class MiCanvas <strong>extends Canvas</strong> {
	public void paint(Graphics g) {
		// Dibujamos en la pantalla
		// usando el objeto g proporcionado
	}<br><br>    public void <strong>showNotify</strong>() {<br>        // El Canvas se muestra<br>        comenzarAnimacion();<br>    }
<br>    public void <strong>hideNotify</strong>() {<br>        // El Canvas se oculta<br>        detenerAnimacion();<br>    }
}</pre>
<p>De esta forma podemos utilizar estos dos m&eacute;todos como respuesta a los 
  eventos de aparici&oacute;n y ocultaci&oacute;n del <em>canvas</em>.</p>
<h2>6.2. Contexto gr&aacute;fico</h2>
<p>El objeto <code>Graphics</code> nos permitir&aacute; acceder al contexto gr&aacute;fico 
  de un determinado componente, en nuestro caso el <em>canvas</em>, y a trav&eacute;s 
  de &eacute;l dibujar en el <em>raster</em> de este componente. En el caso del 
  contexto gr&aacute;fico del <em>canvas</em> de LCDUI este <em>raster</em> corresponder&aacute; 
  a la pantalla del dispositivo m&oacute;vil. Vamos a ver ahora como dibujar utilizando 
  dicho objeto <code>Graphics</code>. Este objeto nos permitir&aacute; dibujar 
  distintas primitivas geom&eacute;tricas, texto e im&aacute;genes.</p>
<h3 class="subsection"><strong>6.2.1. Atributos</strong></h3>
<p>El contexto gr&aacute;fico tendr&aacute; asociados una serie de atributos que 
  indicar&aacute;n c&oacute;mo se va a dibujar en cada momento, como por ejemplo 
  el color o el tipo del l&aacute;piz que usamos para dibujar. El objeto <code>Graphics</code> 
  proporciona una serie de m&eacute;todos para consultar o modificar estos atributos. 
  Podemos encontrar los siguientes atributos en el contexto gr&aacute;fico de 
  LCDUI:</p>
<ul>
  <li><strong>Color del l&aacute;piz</strong>: Indica el color que se utilizar&aacute; 
    para dibujar la primitivas geom&eacute;tricas y el texto. MIDP trabaja con 
    color de 24 bits (<em>truecolor</em>), que codificaremos en modelo RGB. Dentro 
    de estos 24 bits tendremos 8 bits para cada uno de los tres componentes: rojo 
    (R), verde (G) y azul (B). No tenemos canal <em>alpha</em>, por lo que no 
    soportar&aacute; transparencia. No podemos contar con que todos los dispositivos 
    soporten color de 24 bits. Lo que har&aacute; cada implementaci&oacute;n concreta 
    de MIDP ser&aacute; convertir los colores solicitados en las aplicaciones 
    al color m&aacute;s cercano soportado por el dispositivo.
    <p>Podemos trabajar con los colores de dos formas distintas: tratando los 
      componentes R, G y B por separado, o de forma conjunta. En MIDP desaparece 
      la clase <code>Color</code> que ten&iacute;amos en AWT, por lo que deberemos 
      asignar los colores proporcionando directamente los valores num&eacute;ricos 
      del color.</p>
    <p>Si preferimos tratar los componentes de forma separada, tenemos los siguientes 
      m&eacute;todos para obtener o establecer el color actual del l&aacute;piz:</p>
    <pre class="codigo">g.<strong>setColor</strong>(rojo, verde, azul);<br>int rojo = g.<strong>getRedComponent</strong>();<br>int green = g.<strong>getGreenComponent</strong>();<br>int blue = g.<strong>getBlueComponent</strong>();</pre>
    <p>Donde <code>g</code> es el objeto <code>Graphics</code> del contexto donde 
      vamos a dibujar. Estos componentes rojo, verde y azul tomar&aacute;n valores 
      entre 0 y 255.</p>
    <p>Podemos tratar estos componentes de forma conjunta empaquet&aacute;ndolos 
      en un &uacute;nico entero. En hexadecimal se codifica de la siguiente forma:</p>
    <p><code>0x00RRGGBB</code></p>
    <p>Podremos leer o establecer el color utilizando este formato empaquetado 
      con los siguientes m&eacute;todos:</p>
    <pre class="codigo">g.<strong>setColor</strong>(rgb);<br>int rgb = g.<strong>getColor</strong>();</pre>
    <p>Tenemos tambi&eacute;n m&eacute;todos para trabajar con valores en escala 
      de grises. Estos m&eacute;todos nos pueden resultar &uacute;tiles cuando 
      trabajemos con dispositivos monocromos.</p>
    <pre class="codigo">int gris = g.<strong>getGrayScale</strong>();<br>g.<strong>setGrayScale</strong>(gris);</pre>
    <p>Con estos m&eacute;todos podemos establecer como color actual distintos 
      tonos en la escala de grises. El valor de gris se mover&aacute; en el intervalo 
      de 0 a 255. Si utilizamos <code>getGrayScale</code> teniendo establecido 
      un color fuera de la escala de grises, convertir&aacute; este color a escala 
      de grises obteniendo su brillo.</p>
  </li>
  <li><strong>Tipo del l&aacute;piz</strong>: Adem&aacute;s del color del l&aacute;piz, 
    tambi&eacute;n podemos establecer su tipo. El tipo del l&aacute;piz indicar&aacute; 
    c&oacute;mo se dibujan las l&iacute;neas de las primitivas geom&eacute;tricas. 
    Podemos encontrar dos estilos:</li>
</ul>
<table width="90%" border="0" align="center">
  <tr> 
    <td width="27%"><code>Graphics.SOLID</code></td>
    <td width="73%">L&iacute;nea s&oacute;lida (se dibujan todos los <em>pixels</em>)</td>
  </tr>
  <tr> 
    <td height="20"><code>Graphics.DOTTED</code></td>
    <td>L&iacute;nea punteada (se salta algunos <em>pixels</em> sin dibujarlos)</td>
  </tr>
</table>
<blockquote> 
  <p>Podemos establecer el tipo del l&aacute;piz o consultarlo con los siguientes 
    m&eacute;todos:</p>
  <pre class="codigo">int tipo = g.<strong>getStrokeStyle</strong>(); <br>g.<strong>setStrokeStyle</strong>(tipo);</pre>
</blockquote>
<ul>
  <li><strong>Fuente</strong>: Indica la fuente que se utilizar&aacute; para dibujar 
    texto. Utilizaremos la clase <code>Font</code> para especificar la fuente 
    de texto que vamos a utilizar, al igual que en AWT. Podemos obtener o establecer 
    la fuente con los siguientes m&eacute;todos: 
    <pre class="codigo">Font fuente = g.<strong>getFont</strong>(); <br>g.<strong>setFont</strong>(fuente);</pre>
  </li>
</ul>
<ul>
  <li><strong>&Aacute;rea de recorte</strong>: Podemos definir un rect&aacute;ngulo 
    de recorte. Cuando definimos un &aacute;rea de recorte en el contexto gr&aacute;fico, 
    s&oacute;lo se dibujar&aacute;n en pantalla los <em>pixels</em> que caigan 
    dentro de este &aacute;rea. Nunca se dibujar&aacute;n los <em>pixels</em> 
    que escribamos fuera de este espacio. Para establecer el &aacute;rea de recorte 
    podemos usar el siguiente m&eacute;todo: 
    <pre class="codigo">g.<strong>setClip</strong>(x, y, ancho, alto); </pre>
    <p>Tambi&eacute;n tenemos disponible el siguiente m&eacute;todo:</p>
    <pre class="codigo">g.<strong>clipRect</strong>(x, y, ancho, alto); </pre>
    <p>Este m&eacute;todo establece un recorte en el &aacute;rea de recorte anterior. 
      Si ya exist&iacute;a un rect&aacute;ngulo de recorte, el nuevo rect&aacute;ngulo 
      de recorte ser&aacute; la intersecci&oacute;n de ambos. Si queremos eliminar 
      el &aacute;rea de recorte anterior deberemos usar el m&eacute;todo <code>setClip</code>.</p>
  </li>
  <li><strong>Origen de coordenadas</strong>: Indica el punto que se tomar&aacute; 
    como origen en el sistema de coordenadas del &aacute;rea de dibujo. Por defecto 
    este sistema de coordenadas tendr&aacute; la coordenada (0,0) en su esquina 
    superior izquierda, y las coordenadas ser&aacute;n positivas hacia la derecha 
    (coordenada x) y hacia abajo (coordenada y), tal como se muestra a continuaci&oacute;n:</li>
</ul>
<div align="center"><img src="imagenes/graficos/scoord.gif" width="215" height="159" align="middle"></div>
<p align="center" class="caption">Figura 1. Sistema de coordenadas del &aacute;rea 
  de dibujo</p>
<blockquote>
  <p>Podemos trasladar el origen de coordenadas utilizando el m&eacute;todo <code>translate</code>. 
    Tambi&eacute;n tenemos m&eacute;todos para obtener la traslaci&oacute;n del 
    origen de coordenadas.</p>
  <pre class="codigo">int x = g.<strong>getTranslateX</strong>();<br>int y = g.<strong>getTranslateY</strong>();<br>g.<strong>translate</strong>(x, y);</pre>
  <p>Estas coordenadas no corresponden a <em>pixels</em>, sino a los l&iacute;mites 
    de los <em>pixels</em>. De esta forma, el <em>p&iacute;xel</em> de la esquina 
    superior izquierda de la imagen se encontrar&aacute; entre las coordenadas 
    (0,0), (0,1), (1,0) y (1,1).</p>
  <div align="center"><img src="imagenes/graficos/pixels.gif" width="373" height="406"> 
  </div>
  <p class="caption">Figura 2. Coordenadas de los l&iacute;mites de los pixels</p>
</blockquote>
<h3><strong>6.2.2. Dibujar primitivas geom&eacute;tricas</strong></h3>
<p>Una vez establecidos estos atributos en el contexto gr&aacute;fico, podremos 
  dibujar en &eacute;l una serie de elementos utilizando una serie de m&eacute;todos 
  de <code>Graphics</code>. Vamos a ver en primer lugar c&oacute;mo dibujar una 
  serie de primitivas geom&eacute;tricas. Para ello tenemos una serie de m&eacute;todos 
  que comienzan por <code>draw_</code> para dibujar el contorno de una determinada 
  figura, o <code>fill_</code> para dibujar dicha figura con relleno.</p>
<ul>
  <li><strong>L&iacute;neas</strong>: Dibuja una l&iacute;nea desde un punto <em>(x1,y1)</em> 
    hasta <em>(x2,y2)</em>. Dibujaremos la l&iacute;nea con: 
    <pre class="codigo">g.<strong>drawLine</strong>(x1, y1, x2, y2);</pre>
    <p>En este caso no encontramos ning&uacute;n m&eacute;todo <code>fill</code> 
      ya que las l&iacute;neas no pueden tener relleno. Al dibujar una l&iacute;nea 
      se dibujar&aacute;n los <em>p&iacute;xels</em> situados inmediatamente abajo 
      y a la derecha de las coordenadas indicadas. Por ejemplo, si dibujamos con 
      <code>drawLine(0, 0, 0, 0)</code> se dibujar&aacute; el <em>pixel</em> de 
      la esquina superior izquierda.</p>
  </li>
  <li><strong>Rect&aacute;ngulos</strong>: Podemos dibujar rect&aacute;ngulos 
    especificando sus coordenadas y su altura y anchura. Podremos dibujar el rect&aacute;ngulo 
    relleno o s&oacute;lo el contorno: </li>
  <pre class="codigo">g.<strong>drawRect</strong>(x, y, ancho, alto);
g.<strong>fillRect</strong>(x, y, ancho, alto);</pre>
  <p>En el caso de <code>fillRect</code>, lo que har&aacute; ser&aacute; rellenar 
    con el color actual los <em>pixels</em> situados entre las coordenadas lim&iacute;trofes. 
    En el caso de <code>drawRect</code>, la l&iacute;nea inferior y derecha se 
    dibujar&aacute;n justo debajo y a la derecha respectivamente de las coordenadas 
    de dichos l&iacute;mites, es decir, se dibuja con un <em>pixel</em> m&aacute;s 
    de ancho y de alto que en el caso relleno. Esto es poco intuitivo, pero se 
    hace as&iacute; para mantener la coherencia con el comportamiento de <code>drawLine</code>.</p>
  <p>Al menos, lo que siempre se nos asegura es que cuando utilizamos las mismas 
    dimensiones no quede ning&uacute;n hueco entre el dibujo del relleno y el 
    del contorno. </p>
  <p>Podemos tambi&eacute;n dibujar rect&aacute;ngulos con las esquinas redondeadas, 
    utilizando los m&eacute;todos:</p>
  <pre class="codigo">g.<strong>drawRoundRect</strong>(x, y, ancho, alto, ancho_arco, alto_arco);
g.<strong>fillRoundRect</strong>(x, y, ancho, alto, ancho_arco, alto_arco)</pre>
  <li><strong>Arcos: </strong>A diferencia de AWT, no tenemos un m&eacute;todo 
    para dibujar directamente elipses, sino que tenemos uno m&aacute;s gen&eacute;rico 
    que nos permite dibujar arcos de cualquier tipo. Nos servir&aacute; tanto 
    para dibujar elipses y c&iacute;rculos como para cualquier otro tipo de arco.</li>
</ul>
<pre class="codigo">g.<strong>drawArc</strong>(x, y, ancho, alto, angulo_inicio, angulo_arco);
g.<strong>fillArc</strong>(x, y, ancho, alto, angulo_inicio, angulo_arco);</pre>
<p>Los &aacute;ngulos especificados deben estar en grados. Por ejemplo, si queremos 
  dibujar un c&iacute;rculo o una elipse en <code>angulo_arco</code> pondremos 
  un valor de 360 grados para que se cierre el arco. En el caso del c&iacute;rculo 
  los valores de <code>ancho</code> y <code>alto</code> ser&aacute;n iguales, 
  y en el caso de la elipse ser&aacute;n diferentes.</p>
<div align="center"><img src="imagenes/graficos/primitivas.gif" width="431" height="163"> 
</div>
<p class="caption">Figura 3. Ejemplos de diferentes primitivas</p>
<p>Por ejemplo, el siguiente <em>canvas</em> aparecer&aacute; con un dibujo de 
  un c&iacute;rculo rojo y un cuadrado verde:</p>
<pre class="codigo">public class MiCanvas extends Canvas {
	public void paint(Graphics g) {
		g.<strong>setColor</strong>(0x00FF0000);
		g.<strong>fillArc</strong>(10,10,50,50,0,360);
		g.<strong>setColor</strong>(0x0000FF00);
		g.<strong>fillRect</strong>(60,60,50,50);
	}
}</pre>
<h3><strong>6.2.3. Puntos anchor</strong></h3>
<p>En MIDP se introduce una caracter&iacute;sticas no existente en AWT que son 
  los puntos <em>anchor</em>. Estos puntos nos facilitar&aacute;n el posicionamiento 
  del texto y de las im&aacute;genes en la pantalla. Con los puntos <em>anchor</em>, 
  adem&aacute;s de dar una coordenada para posicionar estos elementos, diremos 
  qu&eacute; punto del elemento vamos a posicionar en dicha posici&oacute;n. </p>
<p>Para el posicionamiento horizontal tenemos las siguientes posibilidades:</p>
<table width="90%" border="0">
  <tr> 
    <td width="27%" valign="top"><code>Graphics.LEFT</code></td>
    <td width="73%">En las coordenadas especificadas se posiciona la parte izquierda 
      del texto o de la imagen.</td>
  </tr>
  <tr> 
    <td valign="top"><code>Graphics.HCENTER</code></td>
    <td>En las coordenadas especificadas se posiciona el centro del texto o de 
      la imagen.</td>
  </tr>
  <tr> 
    <td valign="top"><code>Graphics.RIGHT</code></td>
    <td>En las coordenadas especificadas se posiciona la parte derecha del texto 
      o de la imagen.</td>
  </tr>
</table>
<p>Para el posicionamiento vertical tenemos:</p>
<table width="90%" border="0">
  <tr> 
    <td width="27%" valign="top"><code>Graphics.TOP</code></td>
    <td width="73%">En las coordenadas especificadas se posiciona la parte superior 
      del texto o de la imagen.</td>
  </tr>
  <tr> 
    <td valign="top"><code>Graphics.VCENTER</code></td>
    <td>En las coordenadas especificadas se posiciona el centro de la imagen. 
      No se aplica a texto.</td>
  </tr>
  <tr> 
    <td valign="top"><code>Graphics.BASELINE</code></td>
    <td>En las coordenadas especificadas se posiciona la l&iacute;nea de base 
      del texto. No se aplica a im&aacute;genes.</td>
  </tr>
  <tr> 
    <td valign="top"><code>Graphics.BOTTOM</code></td>
    <td>En las coordenadas especificadas se posiciona la parte inferior del texto 
      o de la imagen.</td>
  </tr>
</table>
<h3><strong>6.2.4. Cadenas de texto</strong></h3>
<p>Podemos dibujar una cadena de texto utilizando el m&eacute;todo <code>drawString</code>. 
  Deberemos proporcionar la cadena de texto de dibujar y el punto <em>anchor</em> 
  donde dibujarla. </p>
<pre class="codigo">g.<strong>drawString</strong>(cadena, x, y, anchor);</pre>
<p>Por ejemplo, si dibujamos la cadena con:</p>
<pre class="codigo">g.<strong>drawString</strong>(&quot;Texto de prueba&quot;, 0, 0, Graphics.LEFT|Graphics.BASELINE);</pre>
<p>Este punto corresponder&aacute; al inicio de la cadena (lado izquierdo), en 
  la l&iacute;nea de base del texto como se muestra a continuaci&oacute;n:</p>
<div align="center"><img src="imagenes/graficos/lbase.gif" width="212" height="58"></div>
<p align="center" class="caption">Figura 4. L&iacute;nea de base del texto</p>
<p>Con esto dibujaremos un texto en pantalla, pero es posible que nos interese 
  conocer las coordenadas que limitan el texto, para saber exactamente el espacio 
  que ocupa en el &aacute;rea de dibujo. En AWT pod&iacute;amos usar para esto 
  un objeto <code>FontMetrics</code>, pero este objeto no existe en MIDP. En MIDP 
  la informaci&oacute;n sobre las m&eacute;tricas de la fuente est&aacute; encapsulada 
  en la misma clase <code>Font</code> por lo que ser&aacute; m&aacute;s sencillo 
  acceder a esta informaci&oacute;n. Podemos obtener esta informaci&oacute;n utilizando 
  los siguientes m&eacute;todos de la clase <code>Font</code>:</p>
<ul>
  <li><strong> <code>stringWidth(cadena)</code></strong>: Nos devuelve el ancho 
    que tendr&aacute; la cadena<i> </i><em>cadena</em> en <em>pixels</em>.</li>
  <li><strong><code>getHeight()</code></strong>: Nos devuelve la altura de la 
    fuente, es decir, la distancia entre las l&iacute;neas de base de dos l&iacute;neas 
    consecutivas de texto. Llamamos ascenso (<em>ascent</em>) a la altura t&iacute;pica 
    que suelen subir los caracteres desde la l&iacute;nea de base, y descenso 
    (<em>descent</em>) a lo que suelen bajar desde esta l&iacute;nea. La altura 
    ser&aacute; la suma del ascenso y el descenso de la fuente, m&aacute;s un 
    margen para evitar que se junten los caracteres de las dos l&iacute;neas. 
    Es la distancia existente entre el punto superior (<code>TOP</code>) y el 
    punto inferior (<code>BOTTOM</code>) de la cadena de texto.</li>
  <li><strong><code>getBaselinePosition</code></strong><code><strong>()</strong></code>: 
    Nos devuelve el ascenso de la fuente, es decir, la altura t&iacute;pica desde 
    la l&iacute;nea de base hasta la parte superior de la fuente.</li>
</ul>
<p>Con estas medidas podremos conocer exactamente los l&iacute;mites de una cadena 
  de texto, tal como se muestra a continuaci&oacute;n:</p>
<div align="center"><img src="imagenes/graficos/fmetrics.gif" width="272" height="57"></div>
<p align="center" class="caption">Figura 5. M&eacute;tricas del texto</p>
<h3><strong>6.2.5. Im&aacute;genes</strong></h3>
<p>Hemos visto como crear im&aacute;genes y como utilizarlas en componentes de 
  alto nivel. Estas mismas im&aacute;genes encapsuladas en la clase <code>Image</code>, 
  podr&aacute;n ser mostradas tambi&eacute;n en cualquier posici&oacute;n de nuestro 
  &aacute;rea de dibujo. </p>
<p>Para ello utilizaremos el m&eacute;todo:</p>
<pre class="codigo">g.<strong>drawImage</strong>(img, x, y, anchor);</pre>
<p>En este caso podremos dibujar tanto im&aacute;genes mutables como inmutables.</p>
<p>Vimos que las im&aacute;genes mutables son aquellas cuyo contenido puede ser 
  modificado. Vamos a ver ahora como hacer esta modificaci&oacute;n. Las im&aacute;genes 
  mutables, al igual que el <em>canvas</em>, tienen un contexto gr&aacute;fico 
  asociado. En el caso de las im&aacute;genes, este contexto gr&aacute;fico representa 
  el contenido de la imagen que es un <em>raster</em> en memoria, pero podremos 
  dibujar en &eacute;l igual que lo hac&iacute;amos en el <em>canvas</em>. Esto 
  es as&iacute; debido a que dibujaremos tambi&eacute;n mediante un objeto de 
  la clase <code>Graphics</code>. Podemos obtener este objeto de contexto gr&aacute;fico 
  en cualquier momento invocando el m&eacute;todo <code>getGraphics</code> de 
  la imagen:</p>
<pre class="codigo">Graphics offg = img.<strong>getGraphics</strong>();</pre>
<p>Si queremos modificar una imagen que hemos cargado de un fichero o de la red, 
  y que por lo tanto es inmutable, podemos crear una copia mutable de la imagen 
  para poder modificarla. Para hacer esto lo primero que deberemos hacer es crear 
  la imagen mutable con el mismo tama&ntilde;o que la inmutable que queremos copiar. 
  Una vez creada podremos obtener su contexto gr&aacute;fico, y dibujar en &eacute;l 
  la imagen inmutable, con lo que habremos hecho la copia de la imagen inmutable 
  a una imagen mutable, que podr&aacute; ser modificada m&aacute;s adelante.</p>
<pre class="codigo">Image img_mut = Image.<strong>createImage</strong>(img.getWidth(), img.getHeight());<br>Graphics offg = img_mut.<strong>getGraphics</strong>();<br>offg.<strong>drawImage</strong>(img, 0, 0, Graphics.TOP|Graphics.LEFT);</pre>
<h2>6.3. Animaci&oacute;n</h2>
<p>Hasta ahora hemos visto como dibujar gr&aacute;ficos en pantalla, pero lo &uacute;nico 
  que hacemos es definir un m&eacute;todo que se encargue de dibujar el contenido 
  del componente, y ese m&eacute;todo ser&aacute; invocado cuando el sistema necesite 
  dibujar la ventana. </p>
<p>Sin embargo puede interesarnos cambiar din&aacute;micamente los gr&aacute;ficos 
  de la pantalla para realizar una animaci&oacute;n. Para ello deberemos indicar 
  el momento en el que queremos que se redibujen los gr&aacute;ficos.</p>
<h3><strong> 6.3.1. Redibujado del &aacute;rea</strong></h3>
<p>Para forzar que se redibuje el &aacute;rea de la pantalla deberemos llamar 
  al m&eacute;todo <code>repaint</code> del <em>canvas</em>. Con eso estamos solicitando 
  al sistema que se repinte el contenido, pero no lo repinta en el mismo momento 
  en el que se llama. El sistema introducir&aacute; esta solicitud en la cola 
  de eventos pendientes y cuando tenga tiempo repintar&aacute; su contenido.</p>
<pre class="codigo">MiCanvas mc = new MiCanvas();
...
mc.<strong>repaint()</strong>;</pre>
<p>En MIDP podemos forzar a que se realicen todos los repintados pendientes llamando 
  al m&eacute;todo <code>serviceRepaints</code>. La llamada a este m&eacute;todo 
  nos bloquear&aacute; hasta que se hayan realizado todos los repintados pendientes. 
  Por esta raz&oacute;n deberemos tener cuidado de no causar un interbloqueo invocando 
  a este m&eacute;todo.</p>
<pre class="codigo">mc.<strong>serviceRepaints</strong>();</pre>
<p>Para repintar el contenido de la pantalla el sistema llamar&aacute; al m&eacute;todo 
  <code>paint</code>, en MIDP no existe el m&eacute;todo <code>update</code> de 
  AWT. Por lo tanto, deberemos definir dentro de <code>paint</code> qu&eacute; 
  se va a dibujar en la pantalla en cada instante, de forma que el contenido de 
  la pantalla var&iacute;e con el tiempo y eso produzca el efecto de la animaci&oacute;n.</p>
<p>Podemos optimizar el redibujado repintando &uacute;nicamente el &aacute;rea 
  de la pantalla que haya cambiado. Para ello en MIDP tenemos una variante del 
  m&eacute;todo <code>repaint</code> que nos permitir&aacute; hacer esto. </p>
<pre class="codigo"><strong>repaint</strong>(x, y, ancho, alto);</pre>
<p>Utilizando este m&eacute;todo, la pr&oacute;xima vez que se redibuje se invocar&aacute; 
  <code>paint</code> pero se proporcionar&aacute; un objeto de contexto gr&aacute;fico 
  con un &aacute;rea de recorte establecida, correspondiente a la zona de la pantalla 
  que hemos solicitado que se redibuje.</p>
<p>Al dibujar cada <em>frame</em> de la animaci&oacute;n deberemos borrar el contenido 
  del <em>frame</em> anterior para evitar que quede el rastro, o al menos borrar 
  la zona de la pantalla donde haya cambios.</p>
<p>Imaginemos que estamos moviendo un rect&aacute;ngulo por pantalla. El rect&aacute;ngulo 
  ir&aacute; cambiando de posici&oacute;n, y en cada momento lo dibujaremos en 
  la posici&oacute;n en la que se encuentre. Pero si no borramos el contenido 
  de la pantalla en el instante anterior, el rect&aacute;ngulo aparecer&aacute; 
  en todos los lugares donde ha estado en instantes anteriores produciendo este 
  efecto indeseable de dejar rastro. Por ello ser&aacute; necesario borrar el 
  contenido anterior de la pantalla.</p>
<p>Sin embargo, el borrar la pantalla y volver a dibujar en cada <em>frame</em> 
  muchas veces puede producir un efecto de parpadeo de los gr&aacute;ficos. Si 
  adem&aacute;s en el proceso de dibujado se deben dibujar varios componentes, 
  y vamos dibujando uno detr&aacute;s de otro directamente en la pantalla, en 
  cada <em>frame</em> veremos como se va construyendo poco a poco la escena, cosa 
  que tambi&eacute;n es un efecto poco deseable. </p>
<p>Para evitar que esto ocurra y conseguir unas animaciones limpias utilizaremos 
  la t&eacute;cnica del <em>doble buffer</em>.</p>
<h3><strong>6.3.2. T&eacute;cnica del doble buffer</strong></h3>
<p>La t&eacute;cnica del <em>doble buffer</em> consiste en dibujar todos los elementos 
  que queremos mostrar en una imagen en memoria, que denominaremos <em>backbuffer</em>, 
  y una vez se ha dibujado todo volcarlo a pantalla como una unidad. De esta forma, 
  mientras se va dibujando la imagen, como no se hace directamente en pantalla 
  no veremos efectos de parpadeo al borrar el contenido anterior, ni veremos como 
  se va creando la imagen, en pantalla se volcar&aacute; la imagen como una unidad 
  cuando est&eacute; completa.</p>
<p>Para utilizar esta t&eacute;cnica lo primero que deberemos hacer es crearnos 
  el <em>backbuffer</em>. Para implementarlo en Java utilizaremos una imagen (objeto 
  <code>Image</code>) con lo que tendremos un <em>raster</em> en memoria sobre 
  el que dibujar el contenido que queramos mostrar. Deberemos crear una imagen 
  del mismo tama&ntilde;o de la pantalla en la que vamos a dibujar. </p>
<p>Crearemos para ello una imagen mutable en blanco, como hemos visto anteriormente, 
  con las dimensiones del <em>canvas</em> donde vayamos a volcarla:</p>
<pre class="codigo">Image backbuffer = Image.<b>createImage</b>(getWidth(), getHeight());</pre>
<p>Obtenemos su contexto gr&aacute;fico para poder dibujar en su <em>raster</em> 
  en memoria:</p>
<pre class="codigo">Graphics offScreen = backbuffer.<strong>getGraphics</strong>();</pre>
<p>Una vez obtenido este contexto gr&aacute;fico, dibujaremos todo lo que queremos 
  mostrar en &eacute;l, en lugar de hacerlo en pantalla. Una vez hemos dibujado 
  todo el contenido en este contexto gr&aacute;fico, deberemos volcar la imagen 
  a pantalla (al contexto gr&aacute;fico del <em>canvas</em>) para que &eacute;sta 
  se haga visible:</p>
<pre class="codigo">g.<strong>drawImage</strong>(backbuffer, 0, 0, Graphics.TOP|Graphics.LEFT);</pre>
<p>La imagen conviene crearla una &uacute;nica vez, ya que la animaci&oacute;n 
  puede redibujar frecuentemente, y si cada vez que lo hacemos creamos un nuevo 
  objeto imagen estaremos malgastando memoria in&uacute;tilmente. Es buena pr&aacute;ctica 
  de programaci&oacute;n en Java instanciar nuevos objetos las m&iacute;nimas 
  veces posibles, intentando reutilizar los que ya tenemos. </p>
<p>Podemos ver como quedar&iacute;a nuestra clase ahora:</p>
<pre class="codigo">public MiCanvas extends Canvas {

	// Backbuffer
	Image backbuffer = null;

	// Ancho y alto del backbuffer
	int width, height;

	// Coordenadas del rectangulo dibujado
	int x, y;<br>
	public void paint(Graphics g) {
		// Solo creamos la imagen la primera vez 
		// o si el componente ha cambiado de tamaño
		if( backbuffer == null || 
			width != getWidth() || 
			height != getHeight() )
		{
			width = getWidth();
			height = getHeight();
			backbuffer = Image.<strong>createImage</strong>(width, height);
		}

		Graphics offScreen = backbuffer.<strong>getGraphics</strong>();

		// Vaciamos el área de dibujo

		offScreen.<strong>clearRect</strong>(0,0,getWidth(), getHeight());

		// Dibujamos el contenido en offScreen
		offScreen.setColor(0x00FF0000);
		offScreen.fillRect(x,y,50,50);

		// Volcamos el back buffer a pantalla
		g.<strong>drawImage</strong>(backbuffer,0,0,Graphics.TOP|Graphics.LEFT);
	}
}</pre>
<p>En ese ejemplo se dibuja un rect&aacute;ngulo rojo en la posici&oacute;n <em>(x,y)</em> 
  de la pantalla que podr&aacute; ser variable, tal como veremos a continuaci&oacute;n 
  a&ntilde;adiendo a este ejemplo m&eacute;todos para realizar la animaci&oacute;n.</p>
<p>Algunas implementaciones de MIDP ya realizan internamente el doble <em>buffer</em>, 
  por lo que en esos casos no ser&aacute; necesario que lo hagamos nosotros. Es 
  m&aacute;s, convendr&aacute; que no lo hagamos para no malgastar innecesariamente 
  el tiempo. Podemos saber si implementa el doble <em>buffer</em> o no llamando 
  al m&eacute;todo <code>isDoubleBuffered</code> del <code>Canvas</code>.</p>
<p> Podemos modificar el ejemplo anterior para en caso de realizar el doble <em>buffer</em> 
  la implementaci&oacute;n de MIDP, no hacerla nosotros:</p>
<pre class="codigo">public MiCanvas extends Canvas {
    ...<br> 	public void paint(Graphics gScreen) {
<br>        boolean doblebuffer = <strong>isDoubleBuffered</strong>();<br><br>		// Solo creamos el backbuffer si no hay doble buffer
		if( !<strong>doblebuffer</strong> ) {<br>            if ( backbuffer == null || 
    	        width != getWidth() || 
	            height != getHeight() )
            {
                width = getWidth();
                height = getHeight();
                backbuffer = Image.createImage(width, height);
            }<br>        }

        // g sera la pantalla o nuestro backbuffer segun si<br>        // el doble buffer est&aacute; ya implementado o no<br><br>		Graphics g = null;
<br>        if(<strong>doblebuffer</strong>) {<br>            g = gScreen;<br>        } else {<br>            g = backbuffer.getGraphics();<br>        }<br><br>		// Vaciamos el área de dibujo

		g.clearRect(0,0,getWidth(), getHeight());

		// Dibujamos el contenido en g
		g.setColor(0x00FF0000);
		g.fillRect(x,y,50,50);

		// Volcamos si no hay doble buffer implementado<br>        if(!<strong>doblebuffer</strong>) {<br>            gScreen.drawImage(backbuffer,0,0,<br>                                  Graphics.TOP|Graphics.LEFT);
        }
	}
}</pre>
<h3><strong>6.3.3. C&oacute;digo para la animaci&oacute;n</strong></h3>
<p>Si queremos hacer una animaci&oacute;n tendremos que ir cambiando ciertas propiedades 
  de los objetos de la imagen (por ejemplo su posici&oacute;n) y solicitar que 
  se redibuje tras cada cambio. Esta tarea deber&aacute; realizarla un hilo que 
  se ejecute en segundo plano. El bucle para la animaci&oacute;n podr&iacute;a 
  ser el siguiente:</p>
<pre class="codigo">public class MiCanvas extends Canvas {
	...
	public void run() {
		// El rectangulo comienza en (10,10)
		x = 10;
		y = 10;

		while(x &lt; 100) {
			x++;
			<strong>repaint</strong>();

			try {
				Thread.sleep(100);
			} catch(InterruptedException e) {}
		}
	}
}</pre>
<p>Con este c&oacute;digo de ejemplo veremos una animaci&oacute;n en la que el 
  rect&aacute;ngulo que dibujamos partir&aacute; de la posici&oacute;n (10,10) 
  y cada 100ms se mover&aacute; un <em>pixel</em> hacia la derecha, hasta llegar 
  a la coordenada (100,10).</p>
<p>Si queremos que la animaci&oacute;n se ponga en marcha nada m&aacute;s mostrarse 
  la pantalla del canvas, podremos hacer que este hilo comience a ejecutarse en 
  el m&eacute;todo <code>showNotify</code> como hemos visto anteriormente.</p>
<pre class="codigo">public class MiCanvas extends Canvas implements Runnable {
	...
	public void showNotify() {
        Thread t = new Thread(this);<br>        t.start();<br>	}
}</pre>
<p>Para implementar estas animaciones podemos utilizar un hilo que duerma un determinado 
  per&iacute;odo tras cada iteraci&oacute;n, como en el ejemplo anterior, o bien 
  utilizar temporizadores que realicen tareas cada cierto periodo de tiempo. Los 
  temporizadores nos pueden facilitar bastante la tarea de realizar animaciones, 
  ya que simplemente deberemos crear una tarea que actualice los objetos de la 
  escena en cada iteraci&oacute;n, y ser&aacute; el temporizador el que se encargue 
  de ejecutar c&iacute;clicamente dicha tarea.</p>
<h3><strong>6.3.4. Hilo de eventos</strong></h3>
<p>Hemos visto que existen una serie de m&eacute;todos que se invocan cuando se 
  produce alg&uacute;n determinado evento, y nosotros podemos redefinir estos 
  m&eacute;todos para indicar c&oacute;mo dar respuesta a estos eventos. Estos 
  m&eacute;todos que definimos para que sean invocados cuando se produce un evento 
  son denominados <em>callbacks</em>. Tenemos los siguientes <em>callbacks</em>:</p>
<ul>
  <li><code><strong>showNotify</strong></code> y <code><strong>hideNotify</strong></code>, 
    para los eventos de aparici&oacute;n y ocultaci&oacute;n del canvas.<br>
  </li>
  <li><code><strong>paint</strong></code> para el evento de dibujado.<br>
  </li>
  <li><code><strong>commandAction</strong></code> para el evento de ejecuci&oacute;n 
    de un comando.<br>
  </li>
  <li><code><strong>keyPressed</strong></code>, <code><strong>keyRepeated</strong></code>, 
    <code><strong>keyReleased</strong></code>, <code><strong>pointerPressed</strong></code>, 
    <code><strong>pointerDragged</strong></code> y <code><strong>pointerReleased</strong></code> 
    para los eventos de teclado y de puntero, que veremos m&aacute;s adelante.</li>
</ul>
<p>Estos eventos son ejecutados por el sistema de forma secuencial, desde un mismo 
  hilo de eventos. Por lo tanto, estos <em>callbacks</em> deber&aacute;n devolver 
  el control cuanto antes, de forma que bloqueen al hilo de eventos el m&iacute;nimo 
  tiempo posible. </p>
<p>Si dentro de uno de estos <em>callbacks</em> tenemos que realizar una tarea 
  que requiera tiempo, deberemos crear un hilo que realice la tarea en segundo 
  plano, para que el hilo de eventos siga ejecut&aacute;ndose mientras tanto.</p>
<p>En algunas ocasiones puede interesarnos ejecutar alguna tarea de forma secuencial 
  dentro de este hilo de eventos. Por ejemplo esto ser&aacute; &uacute;til si 
  queremos ejecutar el c&oacute;digo de nuestra animaci&oacute;n sin que interfiera 
  con el m&eacute;todo <code>paint</code>. Podemos hacer esto con el m&eacute;todo 
  <code>callSerially</code> del objeto <code>Display</code>. Deberemos proporcionar 
  un objeto <code>Runnable</code> para ejecutar su m&eacute;todo <code>run</code> 
  en serie dentro del hilo de eventos. La tarea que definamos dentro de este <code>run</code> 
  deber&aacute; terminar pronto, al igual que ocurre con el c&oacute;digo definido 
  en los <em>callbacks</em>, para no bloquear el hilo de eventos.</p>
<p>Podemos utilizar <code>callSerially</code> para ejecutar el c&oacute;digo de 
  la animaci&oacute;n de la siguiente forma:</p>
<pre class="codigo">public class MiCanvas extends Canvas implements Runnable {
    ...<br>    public void anima() {
        // Inicia la animaci&oacute;n<br>        repaint();
        mi_display.<strong>callSerially</strong>(this);
    }
<br>    public void run() {
        // Actualiza la animaci&oacute;n<br>        ...<br>        repaint();
        mi_display.<strong>callSerially</strong>(this);
    }
}</pre>
<p>La llamada a <code>callSerially</code> nos devuelve el control inmediatamente, 
  no espera a que el m&eacute;todo <code>run</code> sea ejecutado.</p>
<h3><strong>6.3.5. Optimizaci&oacute;n de im&aacute;genes</strong></h3>
<p>Si tenemos varias im&aacute;genes correspondientes a varios <em>frames</em> 
  de una animaci&oacute;n, podemos optimizar nuestra aplicaci&oacute;n guardando 
  todas estas im&aacute;genes como una &uacute;nica imagen. Las guardaremos en 
  forma de mosaico dentro de un mismo fichero de tipo imagen, y en cada momento 
  deberemos mostrar por pantalla s&oacute;lo una de las im&aacute;genes dentro 
  de este mosaico.</p>
<div align="center"><img src="imagenes/graficos/frames.gif" width="96" height="24"> 
</div>
<p class="caption">Figura 6. Imagen con los frames de una animaci&oacute;n</p>
<p>De esta forma estamos reduciendo el n&uacute;mero de ficheros que incluimos 
  en el JAR de la aplicaci&oacute;n, por lo que por una lado reduciremos el espacio 
  de este fichero, y por otro lado tendremos que abrir s&oacute;lo un fichero, 
  y no varios.</p>
<p>Para mostrar s&oacute;lo una de las im&aacute;genes del mosaico, lo que podemos 
  hacer es establecer un &aacute;rea de recorte del tama&ntilde;o de un elemento 
  del mosaico (<em>frame</em>) en la posici&oacute;n donde queramos dibujar esta 
  imagen. Una vez hecho esto, ajustaremos las coordenadas donde dibujar la imagen 
  de forma que dentro del &aacute;rea de recorte caiga el elemento del mosaico 
  que queremos mostrar en este momento. De esta forma, s&oacute;lo ser&aacute; 
  dibujado este elemento, ignor&aacute;ndose el resto.</p>
<p>Podemos ver esto ilustrado en la Figura 18. En ella podemos ver a la izquierda 
  c&oacute;mo mostrar el segundo frame del reloj, y a la derecha c&oacute;mo mostrar 
  el tercer frame. Queremos dibujar el reloj en la posici&oacute;n <code>(x,y)</code> 
  de la imagen. Cada frame de este reloj tiene un tama&ntilde;o <code>anchoFrame 
  x altoFrame</code>. Por lo tanto, el &aacute;rea de recorte ser&aacute; un rect&aacute;ngulo 
  cuya esquina superior izquierda estar&aacute; en las coordenadas <code>(x,y)</code> 
  y tendra una altura y una anchura de <code>altoFrame</code> y <code>anchoFrame</code> 
  respectivamente, para de esta manera poder dibujar en esa regi&oacute;n de la 
  pantalla cada <em>frame</em> de nuestra imagen.</p>
<p>Para dibujar cada uno de los <em>frames</em> deberemos desplazar la imagen 
  de forma que el <em>frame</em> que queramos mostrar caiga justo bajo el &aacute;rea 
  de recorte establecida. De esta forma al dibujar la imagen, se volcar&aacute; 
  a la pantalla s&oacute;lo el <em>frame</em> deseado, y el resto, al estar fuera 
  del &aacute;rea de recorte, no se mostrar&aacute;. En la figura podemos ver 
  los <em>frames</em> que quedan fuera del &aacute;rea de recorte representados 
  con un color m&aacute;s claro, al volcar la imagen estos <em>frames</em> no 
  se dibujar&aacute;n.</p>
<div align="center"><img src="imagenes/graficos/ejemplo_frames_1.gif" width="262" height="167">  &nbsp;
  <img src="imagenes/graficos/ejemplo_frames_2.gif" width="262" height="167"> 
</div>
<p class="caption">Figura 7. Ejemplo de dibujado de diferentes frames de una imagen</p>
<p>A continuaci&oacute;n se muestra el c&oacute;digo fuente del ejemplo anterior, 
  con el que podremos dibujar cada <em>frame</em> de la imagen.</p>
<pre class="codigo">// Guardamos el &aacute;rea de recorte anterior<br>int clipX = g.getClipX();
int clipY = g.getClipY();
int clipW = g.getClipWidth();
int clipH = g.getClipHeight();<br><br>// Establecemos nuevo &aacute;rea de recorte<br>g.clipRect(<strong>x, y, anchoFrame, altoFrame</strong>);

// Dibujamos la imagen con el desplazamiento adecuado   
g.drawImage(
   imagen,
   <strong>x - xFrame[frameActual]</strong>,
   <strong>y - yFrame[frameActual]</strong>,
   Graphics.TOP | Graphics.LEFT);<br><br>// Reestablecemos el &aacute;rea de recorte anterior
g.setClip(clipX, clipY, clipW, clipH);</pre>
<h2>6.4. Eventos de entrada</h2>
<p>La clase <code>Canvas</code> nos permite acceder a los eventos de entrada del 
  usuario a bajo nivel. De esta forma podremos saber cuando el usuario pulsa o 
  suelta cualquier tecla del dispositivo. Cuando ocurra un evento en el teclado 
  se invocar&aacute; uno de los siguientes m&eacute;todos de la clase <code>Canvas</code>:</p>
<table width="90%" border="0" align="center">
  <tr> 
    <td width="30%"><code>keyPressed(int cod)</code></td>
    <td width="70%">Se ha presionado la tecla con c&oacute;digo <code>cod</code></td>
  </tr>
  <tr> 
    <td><code>keyRepeated(int cod)</code></td>
    <td>Se mantiene presionada la tecla con c&oacute;digo <code>cod</code></td>
  </tr>
  <tr> 
    <td><code>keyReleased(int cod)</code></td>
    <td>Se ha soltado la tecla con c&oacute;digo <code>cod</code></td>
  </tr>
</table>
<p>Estos dispositivos, adem&aacute;s de generar eventos cuando presionamos o soltamos 
  una tecla, son capaces de generar eventos de repetici&oacute;n. Estos eventos 
  se producir&aacute;n cada cierto per&iacute;odo de tiempo mientras mantengamos 
  pulsada una tecla.</p>
<p>Al realizar aplicaciones para m&oacute;viles debemos tener en cuenta que en 
  la mayor&iacute;a de estos dispositivos no se puede presionar m&aacute;s de 
  una tecla al mismo tiempo. Hasta que no hayamos soltado la tecla que estemos 
  pulsando, no se podr&aacute;n recibir eventos de pulsaci&oacute;n de ninguna 
  otra tecla.</p>
<p>Para dar respuesta a estos eventos del teclado deberemos redefinir estos m&eacute;todos 
  en nuestra subclase de <code>Canvas</code>:</p>
<pre class="codigo">public class MiCanvas <strong>extends Canvas</strong> {
    ...
	public void <strong>keyPressed(int cod)</strong> {<br>        // Se ha presionado la tecla con c&oacute;digo cod<br>    }<br>
	public void <strong>keyRepeated(int cod)</strong> {<br>        // Se mantiene pulsada la tecla con c&oacute;digo cod<br>    }<br>
	public void <strong>keyReleased(int cod)</strong> {<br>        // Se ha soltado la tecla con c&oacute;digo cod<br>    }
}</pre>
<h3><strong>6.4.1. C&oacute;digos del teclado</strong></h3>
<p>Cada tecla del teclado del dispositivo tiene asociado un c&oacute;digo identificativo 
  que ser&aacute; el par&aacute;metro que se le proporcione a estos m&eacute;todos 
  al presionarse o soltarse. Tenemos una serie de constantes en la clase <code>Canvas</code> 
  que representan los c&oacute;digos de las teclas est&aacute;ndar:</p>
<table width="90%" border="0" align="center">
  <tr> 
    <td width="31%"><code>Canvas.KEY_NUM0</code></td>
    <td width="69%">0</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM1</code></td>
    <td>1</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM2</code></td>
    <td>2</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM3</code></td>
    <td>3</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM4</code></td>
    <td>4</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM5</code></td>
    <td>5</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM6</code></td>
    <td>6</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM7</code></td>
    <td>7</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM8</code></td>
    <td>8</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_NUM9</code></td>
    <td>9</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_POUND</code></td>
    <td>#</td>
  </tr>
  <tr> 
    <td><code>Canvas.KEY_STAR</code></td>
    <td>*</td>
  </tr>
</table>
<p>Los teclados, adem&aacute;s de estas teclas est&aacute;ndar, normalmente tendr&aacute;n 
  otras teclas, cada una con su propio c&oacute;digo num&eacute;rico. Es recomendable 
  utilizar &uacute;nicamente estas teclas definidas como constantes para asegurar 
  la portabilidad de la aplicaci&oacute;n, ya que si utilizamos cualquier otro 
  c&oacute;digo de tecla no podremos asegurar que est&eacute; disponible en todos 
  los modelos de tel&eacute;fonos.</p>
<p>Los c&oacute;digos de tecla corresponden al c&oacute;digo Unicode del car&aacute;cter 
  correspondiente a dicha tecla. Si la tecla no corresponde a ning&uacute;n car&aacute;cter 
  Unicode entonces su c&oacute;digo ser&aacute; negativo. De esta forma podremos 
  obtener f&aacute;cilmente el car&aacute;cter correspondiente a cada tecla. Sin 
  embargo, esto no ser&aacute; suficiente para realizar entrada de texto, ya que 
  hay caracteres que corresponden a m&uacute;ltiples pulsaciones de una misma 
  tecla, y a bajo nivel s&oacute;lo tenemos constancia de que una misma tecla 
  se ha pulsado varias veces, pero no sabemos a qu&eacute; car&aacute;cter corresponde 
  ese n&uacute;mero de pulsaciones. Si necesitamos que el usuario escriba texto, 
  lo m&aacute;s sencillo ser&aacute; utilizar uno de los componentes de alto nivel.</p>
<p>Podemos obtener el nombre de la tecla correspondiente a un c&oacute;digo dado 
  con el m&eacute;todo <code>getKeyName</code> de la clase <code>Canvas</code>.</p>
<h3><strong>6.4.2. Acciones de juegos</strong></h3>
<p>Tenemos tambi&eacute;n definidas lo que se conoce como acciones de juegos (<em>game 
  actions</em>) con las que representaremos las teclas que se utilizan normalmente 
  para controlar los juegos, a modo de <em>joystick</em>. Las acciones de juegos 
  principales son:</p>
<table width="90%" border="0" align="center">
  <tr> 
    <td><code>Canvas.LEFT</code></td>
    <td>Movimiento a la izquierda</td>
  </tr>
  <tr> 
    <td><code>Canvas.RIGHT</code></td>
    <td>Movimiento a la derecha</td>
  </tr>
  <tr> 
    <td><code>Canvas.UP</code></td>
    <td>Movimiento hacia arriba</td>
  </tr>
  <tr> 
    <td><code>Canvas.DOWN</code></td>
    <td>Movimiento hacia abajo</td>
  </tr>
  <tr> 
    <td><code>Canvas.FIRE</code></td>
    <td>Fuego</td>
  </tr>
</table>
<p>Una misma acci&oacute;n puede estar asociada a varias teclas del tel&eacute;fono, 
  de forma que el usuario pueda elegir la que le resulte m&aacute;s c&oacute;moda. 
  Las teclas asociadas a cada acci&oacute;n de juego ser&aacute;n dependientes 
  de la implementaci&oacute;n, cada modelo de tel&eacute;fono puede asociar a 
  las teclas las acciones de juego que considere m&aacute;s apropiadas seg&uacute;n 
  la distribuci&oacute;n del teclado, para que el manejo sea c&oacute;modo. Por 
  lo tanto, el utilizar estas acciones har&aacute; la aplicaci&oacute;n m&aacute;s 
  portable, ya que no tendremos que adaptar los controles del juego para cada 
  modelo de m&oacute;vil.</p>
<p>Para conocer la acci&oacute;n de juego asociada a un c&oacute;digo de tecla 
  dado utilizaremos el siguiente m&eacute;todo:</p>
<pre class="codigo">int accion = <strong>getGameAction</strong>(keyCode);</pre>
<p>De esta forma podremos realizar de una forma sencilla y portable aplicaciones 
  que deban controlarse utilizando este tipo de acciones.</p>
<p>Podemos hacer la transformaci&oacute;n inversa con:</p>
<pre class="codigo">int codigo = <strong>getKeyCode</strong>(accion);</pre>
<p>Hemos de resaltar que una acci&oacute;n de c&oacute;digo puede estar asociada 
  a m&aacute;s de una tecla, pero con este m&eacute;todo s&oacute;lo podremos 
  obtener la tecla principal que realiza dicha acci&oacute;n.</p>
<h3><strong>6.4.3. Punteros</strong></h3>
<p>Algunos dispositivos tienen punteros como dispositivos de entrada. Esto es 
  com&uacute;n en los PDAs, pero no en los tel&eacute;fonos m&oacute;viles. Los 
  <em>callbacks</em> que deberemos redefinir para dar respuesta a los eventos 
  del puntero son los siguientes:</p>
<p></p>
<table width="90%" border="0" align="center">
  <tr> 
    <td width="43%"><code>pointerPressed(int x, int y)</code></td>
    <td width="57%">Se ha pinchado con el puntero en <em>(x,y)</em></td>
  </tr>
  <tr> 
    <td><code>pointerDragged(int x, int y)</code></td>
    <td>Se ha arrastrado el puntero a <em>(x,y)</em></td>
  </tr>
  <tr> 
    <td><code>pointerReleased(int x, int y)</code></td>
    <td>Se ha soltado el puntero en <em>(x,y)</em></td>
  </tr>
</table>
<p>En todos estos m&eacute;todos se proporcionar&aacute;n las coordenadas <em>(x,y) 
  </em>donde se ha producido el evento del puntero.</p>
<h2 class="subsection">6.5. APIs propietarias</h2>
<p>Existen APIs propietarias de diferentes vendedores, que a&ntilde;aden funcionalidades 
  no soportadas por la especificaci&oacute;n de MIDP. Los desarrolladores de estas 
  APIs propietarias no deben incluir en ellas nada que pueda hacerse con MIDP. 
  Estas APIs deben ser &uacute;nicamente para permitir acceder a funcionalidades 
  que MIDP no ofrece.</p>
<p>Es recomendable no utilizar estas APIs propietarias siempre que sea posible, 
  para hacer aplicaciones que se ajusten al est&aacute;ndar de MIDP. Lo que podemos 
  hacer es desarrollar aplicaciones que cumplan con el est&aacute;ndar MIDP, y 
  en el caso que detecten que hay disponible una determinada API propietaria la 
  utilicen para obtener alguna mejora. A continuaci&oacute;n veremos como detectar 
  en tiempo de ejecuci&oacute;n si tenemos disponible una determinada API.</p>
<p>Vamos a ver la API Nokia UI, disponible en gran parte de los modelos de tel&eacute;fonos 
  Nokia, que incorpora nuevas funcionalidades para la programaci&oacute;n de la 
  interfaz de usuario no disponibles en MIDP 1.0. Esta API est&aacute; contenida 
  en el paquete <code>com.nokia.mid</code>.</p>
<h3><strong>6.5.1. Gr&aacute;ficos</strong></h3>
<p>En cuanto a los gr&aacute;ficos, tenemos disponibles una serie de mejoras respecto 
  a MIDP.</p>
<p>A&ntilde;ade soporte para crear un <em>canvas</em> a pantalla completa. Para 
  crear este <em>canvas</em> utilizaremos la clase <code>FullCanvas</code> de 
  la misma forma que utiliz&aacute;bamos <code>Canvas</code>.</p>
<p>Define una extensi&oacute;n de la clase <code>Graphics</code>, en la clase 
  <code>DirectGraphics</code>. Para obtener este contexto gr&aacute;fico extendido 
  utilizaremos el siguiente m&eacute;todo: </p>
<pre class="codigo">DirectGraphics dg = DirectUtils.<strong>getDirectGraphics</strong>(g);
</pre>
<p>Siendo <code>g </code>el objeto de contexto gr&aacute;fico <code>Graphics</code> 
  en el que queremos dibujar. Este nuevo contexto gr&aacute;fico a&ntilde;ade:</p>
<ul>
  <li>Soporte para nuevos tipos de primitivas geom&eacute;tricas (tri&aacute;ngulos 
    y pol&iacute;gonos).<br>
  </li>
  <li>Soporte para transparencia, incorporando un canal <em>alpha</em> al color. 
    Ahora tenemos colores de 32 bits, cuya forma empaquetada se codifica como 
    <code>0xAARRGGBB</code>.<br>
  </li>
  <li>Acceso directo a los <em>pixels</em> del <em>raster</em> de pantalla. Podremos 
    dibujar <em>pixels</em> en pantalla proporcionando directamente el <em>array</em> 
    de <em>pixels</em> a dibujar, o bien obtener los <em>pixels</em> de la pantalla 
    en forma de un <em>array</em> de <em>pixels</em>. Cada <em>pixel</em> de este 
    <em>array</em> ser&aacute; un valor <code>int</code>, <code>short</code> o 
    <code>byte</code> que codificar&aacute; el color de dicho <em>pixel</em>. 
    <br>
  </li>
  <li>Permite transformar las im&aacute;genes a dibujar. Podremos hacer rotaciones 
    de 90, 180 o 270 grados y transformaciones de espejo con las im&aacute;genes 
    al mostrarlas.</li>
</ul>
<h3><strong>6.5.2. Sonido</strong></h3>
<p>Una limitaci&oacute;n de MIDP 1.0 es que no soporta sonido. Por ello para incluir 
  sonido en las aplicaciones de dispositivos que s&oacute;lo soporten MIDP 1.0 
  como API est&aacute;ndar deberemos recurrir a APIs propietarias para tener estas 
  funcionalidades. La API Nokia UI nos permitir&aacute; solucionar esta carencia.</p>
<p>Nos permitir&aacute; reproducir sonidos como tonos o ficheros de onda (WAV). 
  Los tipos de formatos soportados ser&aacute;n dependientes de cada dispositivo.</p>
<h3><strong>6.5.3. Control del dispositivo</strong></h3>
<p>Adem&aacute;s de las caracter&iacute;sticas anteriores, esta API nos permitir&aacute; 
  utilizar funciones propias de los dispositivos. En la clase <code>DeviceControl</code> 
  tendremos m&eacute;todos para controlar la vibraci&oacute;n del m&oacute;vil 
  y el parpadeo de las luces de la pantalla.</p>
<h3><strong>6.5.4. Detecci&oacute;n de la API propietaria</strong></h3>
<p>Si utilizamos una API propietaria reduciremos la portabilidad de la aplicaci&oacute;n. 
  Por ejemplo, si usamos la API Nokia UI la aplicaci&oacute;n s&oacute;lo funcionar&aacute; 
  en algunos dispositivos de Nokia. Hay una forma de utilizar estas APIs propietarias 
  sin afectar a la portabilidad de la aplicaci&oacute;n. Podemos detectar en tiempo 
  de ejecuci&oacute;n si la API propietaria est&aacute; disponible de la siguiente 
  forma:</p>
<pre class="codigo">boolean hayNokiaUI = false;<br><br>try {<br>    Class.forName(&quot;com.nokia.mid.sound.Sound&quot;);<br>    hayNokiaUI = true;<br>} catch(ClassNotFoundException e) {}</pre>
<p>De esta forma, si la API propietaria est&aacute; disponible podremos utilizarla 
  para incorporar m&aacute;s funcionalidades a la aplicaci&oacute;n. En caso contrario, 
  no deberemos ejecutar nunca ninguna instrucci&oacute;n que acceda a esta API 
  propietaria.</p>
<h2>6.6. Gr&aacute;ficos 3D</h2>
<p>Podemos crear aplicaciones que muestren gr&aacute;ficos en 3D utilizando la 
  API opcional Mobile 3D Graphics for J2ME (JSR-184).</p>
<div align="center"><img src="imagenes/graficos/m3g_ej2.gif" width="149" height="177">&nbsp; 
  &nbsp;<img src="imagenes/graficos/m3g_ej1.gif" width="149" height="177"> </div>
<p class="caption">Figura 8. Ejemplos de aplicaciones 3D para dispositivos m&oacute;viles</p>
<p>Esta API nos permitir&aacute; a&ntilde;adir contenido 3D a las aplicaciones 
  de dos modos distintos:</p>
<ul>
  <li><strong>Modo inmediato</strong>: Este modo nos servir&aacute; para crear 
    los gr&aacute;ficos 3D a bajo nivel, creando directamente los pol&iacute;gonos 
    que va a tener nuestro mundo 3D. Este modo nos permitir&aacute; tener un control 
    absoluto sobre los pol&iacute;gonos que se dibujan, pero el tener que definir 
    manualmente estos pol&iacute;gonos hace que este modo no sea adecuado cuando 
    tengamos que mostrar objetos complejos (por ejemplo personajes de un juego). 
    Este modo resultar&aacute; &uacute;til por ejemplo para generar gr&aacute;ficos 
    3D para representar datos. <br>
  </li>
  <li><strong>Modo <em>retained</em></strong>: En este modo contaremos con una 
    serie de objetos ya creados que podremos a&ntilde;adir a la escena. Estos 
    objetos que utilizamos los podremos cargar de ficheros en los que tendremos 
    almacenados los distintos objetos 3D que vayamos a mostrar. La escena se representar&aacute; 
    como un grafo, del que colgar&aacute;n todos los objetos que queramos mostrar 
    en ella. Este modo ser&aacute; &uacute;til para aplicaciones como juegos, 
    en las que tenemos que mostrar objetos complejos, como por ejemplo los personajes 
    del juego. </li>
</ul>
<p>M&aacute;s adelante estudiaremos con m&aacute;s detalle c&oacute;mo mostrar 
  gr&aacute;ficos 3D utilizando cada uno de estos modos.</p>
<h3><strong>6.6.1. Renderizaci&oacute;n 3D</strong></h3>
<p>Para renderizar gr&aacute;ficos 3D en el m&oacute;vil utilizaremos un objeto 
  de tipo <code>Graphics3D</code>. Para obtener este objeto utilizaremos el siguiente 
  m&eacute;todo est&aacute;tico:</p>
<pre class="codigo"><strong>Graphics3D</strong> g3d;
... 
g3d = <strong>Graphics3D</strong>.<strong>getInstance</strong>();</pre>
<p>Podremos declarar este objeto como campo global de la clase y obtenerlo una 
  &uacute;nica vez durante la inicializaci&oacute;n de la misma.</p>
<p>Para poder utilizar este objeto, deberemos decirle en qu&eacute; contexto gr&aacute;fico 
  queremos que vuelque el contenido 3D que genere. Normalmente estableceremos 
  como objetivo donde volcar el contexto gr&aacute;fico asociado a la pantalla 
  del m&oacute;vil. </p>
<p>Esto lo haremos en el m&eacute;todo <code>paint</code>, como se muestra a continuaci&oacute;n:</p>
<pre class="codigo">protected void <strong>paint</strong>(Graphics g) {<br>  try {<br>    g3d.<strong>bindTarget</strong>(g);<br>    ...
    g3d.<strong>render</strong>(escena);<br>  } finally {<br>    g3d.<strong>releaseTarget</strong>();			<br>  }<br>}<br></pre>
<p>Con <code>bindTarget</code> establecemos en qu&eacute; contexto gr&aacute;fico 
  vamos a volver los gr&aacute;ficos 3D. Una vez hecho esto podremos renderizar 
  la escena que hayamos definido utilizando el m&eacute;todo <code>render</code> 
  del objeto <code>Graphics3D</code>. M&aacute;s adelante veremos c&oacute;mo 
  definir esta escena utilizando tanto el modo inmediato como el modo <em>retained</em>. 
  Por &uacute;ltimo, con <code>releaseTarget</code> liberamos el contexto gr&aacute;fico 
  que estabamos utilizando para volcar los gr&aacute;ficos. </p>
<h3><strong>6.6.2. Transformaciones geom&eacute;tricas</strong></h3>
<p>Cuando queramos establecer la posici&oacute;n de un objeto 3D en el mundo, 
  deberemos transformar sus coordenadas para que &eacute;stas est&eacute;n en 
  la posici&oacute;n deseada. Para representar estas transformaciones geom&eacute;tricas 
  en el espacio tenemos la clase <code>Transform</code>.</p>
<p>Utilizaremos objetos <code>Transform</code> para indicar la posici&oacute;n 
  y el tama&ntilde;o que van a tener los objetos en el mundo. En la transformaci&oacute;n 
  podemos establecer traslaciones del objeto, rotaciones, y cambios de escala. 
</p>
<p>Normalmente asociaremos a cada objeto que tengamos en el mundo 3D una transformaci&oacute;n, 
  donde se indicar&aacute; la posici&oacute;n de dicho objeto. Adem&aacute;s, 
  esto nos servir&aacute; para hacer animaciones, ya que simplemente cambiando 
  los valores de la transformaci&oacute;n en el tiempo podremos hacer que el objeto 
  cambie de posici&oacute;n o tama&ntilde;o.</p>
<p>Utilizando el constructor de <code>Transform</code> podemos crear una transformaci&oacute;n 
  identidad:</p>
<pre class="codigo"><strong>Trasform</strong> trans = new <strong>Transform</strong>();</pre>
<p>Con esta transformaci&oacute;n, el objeto al que se aplique permanecer&aacute; 
  en sus coordenadas iniciales. Podremos modificar esta transformaci&oacute;n 
  para cambiar la posici&oacute;n o el tama&ntilde;o del objeto mediante:</p>
<ul>
  <li><strong>Traslaci&oacute;n</strong>: Especificamos la traslaci&oacute;n en 
    (x,y,z) que queremos hacer con el objeto.</li>
</ul>
<pre class="codigo">trans.<strong>postTranslate</strong>(tx, ty, tz);</pre>
<ul>
  <li><strong>Rotaci&oacute;n</strong>: Especificamos un eje de rotaci&oacute;n 
    del objeto, dado con el vector (x,y,z) que representa el eje, un un &aacute;ngulo 
    de rotaci&oacute;n alrededor de dicho eje dado en grados.</li>
</ul>
<pre class="codigo">trans.<strong>postRotate</strong>(angulo, vx, vy, vz);</pre>
<ul>
  <li><strong>Escala</strong>: Especificamos el factor de escala a aplicar en 
    cada una de las tres coordenadas. Con factor 1.0 mantendr&aacute; su tama&ntilde;o 
    actual, y reduciendo o aumentando este valor conseguiremos reducir o agrandar 
    el objeto en dicha coordenada. </li>
</ul>
<pre class="codigo">trans.<strong>postScale</strong>(sx, sy, sz);</pre>
<p>Podemos hacer que la transformaci&oacute;n vuelva a ser la identidad para volver 
  a la posici&oacute;n original del objeto:</p>
<pre class="codigo">trans.<strong>setIdentity</strong>();</pre>
<h3><strong>6.6.3. C&aacute;mara</strong></h3>
<p>Para poder renderizar una escena es imprescindible establecer previamente el 
  punto de vista desde el que la queremos visualizar. Para hacer esto tendremos 
  que definir una c&aacute;mara, encapsulada en el objeto <code>Camera</code>.</p>
<p>Crearemos la c&aacute;mara utilizando el constructor vac&iacute;o de esta clase:</p>
<pre class="codigo"><strong>Camera</strong> cam;
... 
cam = new <strong>Camera</strong>();</pre>
<p>Con esto tendremos la c&aacute;mara, que siempre estar&aacute; apuntando hacia 
  la coordenada Z negativa (0, 0, -1). Si queremos mover o rotar la c&aacute;mara, 
  deberemos hacerlo mediante un objeto <code>Transform</code> que aplicaremos 
  a la c&aacute;mara:</p>
<pre class="codigo"><strong>Transform</strong> tCam;
...
tCam = new <strong>Transform</strong>();
tCam.<strong>postTranslate</strong>(0.0f, 0.0f, 2.0f);</pre>
<p>De la c&aacute;mara deberemos especificar el tipo de proyecci&oacute;n que 
  queremos utilizar y una serie de par&aacute;metros. Podemos establecer dos tipos 
  de proyecciones:</p>
<ul>
  <li><strong>Paralela</strong>: En este tipo de proyecciones, el centro de proyecci&oacute;n 
    est&aacute; en el infinito. Las l&iacute;neas que son paralelas en el espacio, 
    se mantienen paralelas en la imagen proyectada. Estableceremos este tipo de 
    proyecci&oacute;n con:</li>
</ul>
<pre class="codigo">cam.<strong>setParallel</strong>(campoDeVision, relacionAspecto, <br>                planoFrontal, planoPosterior);</pre>
<ul>
  <li><strong>Perspectiva</strong>: El centro de proyecci&oacute;n es un punto 
    finito. En este caso, las l&iacute;neas que son paralelas en el espacio, en 
    la imagen proyectada convergen en alg&uacute;n punto. Estableceremos este 
    tipo de proyecci&oacute;n con:</li>
</ul>
<pre class="codigo">cam.<strong>setPerspective</strong>(campoDeVision, relacionAspecto, <br>                planoFrontal, planoPosterior);
</pre>
<p>En el par&aacute;metro <code>campoDeVision</code> indicaremos el campo visual 
  de la c&aacute;mara en grados. Este valor normalmente ser&aacute; 45&ordm; o 
  60&ordm;. Valores superiores a 60&ordm; distorsionan la imagen. En <code>relacionAspecto</code> 
  indicaremos la proporci&oacute;n entre el ancho y el alto de la pantalla donde 
  se van a mostrar los gr&aacute;ficos. Adem&aacute;s deberemos establecer dos 
  planos de recorte: uno cercano (<code>planoFrontal</code>) y uno lejano (<code>planoPosterior</code>), 
  de forma que s&oacute;lo se ver&aacute;n los objetos que est&eacute;n entre 
  estos dos planos. Todo aquello m&aacute;s cercano al plano frontal, y m&aacute;s 
  lejano al plano posterior ser&aacute; recortado.</p>
<p>Por ejemplo, podemos utilizar una proyecci&oacute;n perspectiva como la siguiente:</p>
<pre class="codigo">cam.<strong>setPerspective</strong>(60.0f, (float)getWidth()/(float)getHeight(), <br>                   1.0f, 1000.0f);</pre>
<p>Una vez definida la c&aacute;mara, deberemos establecerla en el objeto <code>Graphics3D</code> 
  de la siguiente forma:</p>
<pre class="codigo"> g3d.<strong>setCamera</strong>(cam, tCam);</pre>
<p>Vemos que al establecer la c&aacute;mara, adem&aacute;s de el objeto <code>Camera</code>, 
  deberemos especificar la transformaci&oacute;n que se va a aplicar sobra la 
  misma. Si queremos hacer movimientos de c&aacute;mara no tendremos m&aacute;s 
  que modificar la transformaci&oacute;n que utilizamos para posicionarla en la 
  escena.</p>
<p>Si vamos a dejar la c&aacute;mara fija, podemos establecer la c&aacute;mara 
  en el objeto <code>Graphics3D</code> una &uacute;nica vez durante la inicializaci&oacute;n. 
  Sin embargo, si queremos mover la c&aacute;mara, deberemos establecerla dentro 
  del m&eacute;todo <code>paint</code>, para que cada vez que se redibuje se sit&uacute;e 
  la c&aacute;mara en su posici&oacute;n actual. </p>
<h3><strong>6.6.4. Luces</strong></h3>
<p>Deberemos tambi&eacute;n definir la iluminaci&oacute;n del mundo. Para crear 
  luces utilizaremos el objeto <code>Light</code>. Podemos crear una luz utilizando 
  su constructor vac&iacute;o:</p>
<pre class="codigo"><strong>Light</strong> luz;
...
luz = new <strong>Light</strong>();</pre>
<p>La luz tendr&aacute; un color y una intensidad, que podremos establecer utilizando 
  los siguientes m&eacute;todos:</p>
<pre class="codigo">luz.<strong>setColor</strong>(0x0ffffff);
luz.<strong>setIntensity</strong>(1.0f);</pre>
<p>Como color podremos especificar cualquier color RGB, y como intensidad deberemos 
  introducir un valor dentro del rango [0.0, 1.0]. Estos atributos son comunes 
  para cualquier tipo de luces.</p>
<p>Adem&aacute;s, podemos utilizar diferentes tipos de luces con distintas propiedades. 
  Estos tipos son:</p>
<ul>
  <li><strong>Ambiente</strong> (<code>Light.AMBIENT</code>): Esta luz afectar&aacute; 
    a todos los objetos por igual en todas las direcciones. Es la luz m&iacute;nima 
    del ambiente, que incide en todas las partes de los objetos. Simula la reflexi&oacute;n 
    de la luz sobre los objetos que produce dicha luz que est&aacute; &quot;en 
    todas partes&quot;.<br>
  </li>
  <li><strong>Direccional</strong> (<code>Light.DIRECTIONAL</code>): Esta luz 
    incide en todos los objetos en una misma direcci&oacute;n. Con est&aacute; 
    luz podemos modelar una fuente de luz muy lejana (en el infinito). Por ejemplo, 
    nos servir&aacute; para modelar la iluminaci&oacute;n el sol, que incide en 
    todos los objetos en la misma direcci&oacute;n en cada momento. La luz estar&aacute; 
    apuntando en la direcci&oacute;n del eje de las Z negativo (0, 0, -1).<br>
  </li>
  <li><strong>Omnidireccional</strong> (<code>Light.OMNI</code>): Se trata de 
    una fuente de luz que ilumina en todas las direcciones. Por ejemplo con esta 
    luz podemos modela una bombilla, que es un punto que emana luz en todas las 
    direcciones.<br>
  </li>
  <li><strong>Foco</strong> (<code>Light.SPOT</code>): Este tipo produce un cono 
    de luz. El foco ilumina en una determinada direcci&oacute;n, produciendo un 
    cono de luz. El foco estar&aacute; orientado en la direcci&oacute;n del eje 
    de las Z negativo (0, 0, -1).</li>
</ul>
<p>Para establecer el tipo de luz que queremos utilizar tenemos el m&eacute;todo 
  <code>setMode</code>:</p>
<pre class="codigo">luz.<strong>setMode</strong>(Light.DIRECTIONAL);</pre>
<p>Dentro de los tipos de luces anteriores, podemos distinguir dos grupos seg&uacute;n 
  la posici&oacute;n de la fuente. Tenemos luces sin posici&oacute;n (ambiente 
  y direccional) y luces con posici&oacute;n (omnidireccional y foco). En el caso 
  de las luces con posici&oacute;n, podemos utilizar el m&eacute;todo <code>setAttenuation</code> 
  para dar una atenuaci&oacute;n a la luz en funci&oacute;n a la distancia de 
  la fuente. Con esto haremos que los objetos que est&eacute;n m&aacute;s lejos 
  de la fuente de luz est&eacute;n menos iluminados que los que est&eacute;n m&aacute;s 
  cerca. Esto no se puede hacer en el caso de las fuentes de luz sin posici&oacute;n, 
  ya que en ese caso la distancia de cualquier objeto a la fuente es infinito 
  o no existe.</p>
<p>Otra clasificaci&oacute;n que podemos hacer es entre fuentes de luz sin direcci&oacute;n 
  (ambiente y omnidireccional) y con direcci&oacute;n (direccional y foco). Hemos 
  visto que las fuentes con direcci&oacute;n siempre est&aacute;n apuntando en 
  la direcci&oacute;n del eje de las Z negativo. Si queremos modificar este direcci&oacute;n 
  podemos aplicar una rotaci&oacute;n a la luz mediante un objeto <code>Transform</code>. 
  De la misma forma, en las fuentes con posici&oacute;n podremos aplicar una traslaci&oacute;n 
  para modificar la posici&oacute;n de la fuente de luz con este objeto.</p>
<pre class="codigo"><strong>Transform</strong> tLuz;
...
tLuz = new <strong>Transform</strong>();</pre>
<p>Para a&ntilde;adir las luces al mundo utilizaremos el m&eacute;todo <code>addLight</code> 
  sobre el objeto de contexto gr&aacute;fico 3D, en el que especificaremos la 
  luz y la transformaci&oacute;n que se va a realizar:</p>
<pre class="codigo">g3d.<strong>addLight</strong>(luz, tLuz);</pre>
<p>Si como transformaci&oacute;n especificamos <code>null</code>, se aplicar&aacute; 
  la identidad. Por ejemplo en el caso de una luz ambiente no tiene sentido aplicar 
  ninguna transformaci&oacute;n a la luz, ya que no tiene ni posici&oacute;n ni 
  direcci&oacute;n.</p>
<pre class="codigo">g3d.<strong>addLight</strong>(luzAmbiente, null);</pre>
<p>Al igual que ocurr&iacute;a en el caso de la c&aacute;mara, si las luces van 
  a permanecer fijas s&oacute;lo hace falta que las a&ntilde;adamos una vez durante 
  la inicializaci&oacute;n. Sin embargo, si se van a mover, tendremos que establecer 
  la posici&oacute;n de la luz cada vez que se renderiza para que se apliquen 
  los cambios. En este caso si a&ntilde;adimos las luces dentro del m&eacute;todo 
  <code>paint</code> deberemos llevar cuidado, ya que el m&eacute;todo <code>addLight</code> 
  a&ntilde;ade luces sobre las que ya tiene definidas el mundo. Para evitar que 
  las luces se vayan acumulando, antes de volver a a&ntilde;adirlas tendremos 
  que eliminar las que ten&iacute;amos en la iteraci&oacute;n anterior con <code>resetLights</code>. 
  Una vez hecho esto podremos a&ntilde;adir las dem&aacute;s luces:</p>
<pre class="codigo">g3d.<strong>resetLights</strong>();<br>g3d.<strong>addLight</strong>(luz, tLuz);<br>g3d.<strong>addLight</strong>(luzAmbiente, null);</pre>
<h3><strong>6.6.5. Fondo</strong></h3>
<p>Tambi&eacute;n deberemos establecer un fondo para el visor antes de renderizar 
  en &eacute;l los gr&aacute;ficos 3D. Como fondo podemos poner un color s&oacute;lido 
  o una imagen. El fondo lo representaremos mediante un objeto de la clase <code>Background</code>:</p>
<pre class="codigo"><strong>Background</strong> fondo;
...
fondo = new <strong>Background</strong>();</pre>
<p>Con el constructor vac&iacute;o construiremos el fondo por defecto que consiste 
  en un fondo negro. Podemos cambiar el color de fondo con el m&eacute;todo <code>setColor</code>, 
  o establecer una imagen de fondo con <code>setImage</code>. </p>
<p>Cada vez que vayamos a renderizar los gr&aacute;ficos en <code>paint</code> 
  es importante que vaciemos todo el &aacute;rea de dibujo con el color (o la 
  imagen) de fondo. Para ello utilizaremos el m&eacute;todo <code>clear</code>:</p>
<pre class="codigo">g3d.<strong>clear</strong>(fondo);</pre>
<p>Si no hici&eacute;semos esto, es posible que tampoco se visualizasen los gr&aacute;ficos 
  3D que se rendericen posteriormente. Si no queremos crear ning&uacute;n fondo 
  y utilizar el fondo negro por defecto, podremos llamar a este m&eacute;todo 
  proporcionando <code>null</code> como par&aacute;metro:</p>
<pre class="codigo">g3d.<strong>clear</strong>(null);</pre>
<p>Vamos a recapitular todo lo visto hasta ahora, y a ver c&oacute;mo quedar&aacute; 
  el m&eacute;todo <code>paint</code> a&ntilde;adiendo luces, c&aacute;mara y 
  fondo:</p>
<pre class="codigo">protected void <strong>paint</strong>(Graphics g) { 
  try { 
    g3d.<strong>bindTarget</strong>(g);
<br>    g3d.<strong>setCamera</strong>(cam, tCam);
<br>    g3d.<strong>resetLights</strong>();
    g3d.<strong>addLight</strong>(luz, tLuz);
    g3d.<strong>addLight</strong>(luzAmbiente, null);
<br>    g3d.<strong>clear</strong>(fondo);<br><br>    g3d.<strong>render</strong>(vb, tsa, ap, tCubo); 
  } finally { 
    g3d.<strong>releaseTarget</strong>();
  } 
}</pre>
<h3><strong>6.6.6. Modo inmediato</strong></h3>
<p>Para crear gr&aacute;ficos utilizando este modo deberemos definir la lista 
  de v&eacute;rtices (x, y, z) de nuestro gr&aacute;fico, y una lista de &iacute;ndices 
  en la que definimos las caras (pol&iacute;gonos) que se van a mostrar. Cada 
  cara se construir&aacute; a partir de un conjunto de v&eacute;rtices. Los &iacute;ndices 
  con los que se define cada cara en la lista de caras, har&aacute;n referencia 
  a los &iacute;ndices de los v&eacute;rtices que la componen en la lista de v&eacute;rtices.</p>
<p>A continuaci&oacute;n se muestra un ejemplo de c&oacute;mo crear un cubo utilizando 
  modo inmediato:</p>
<pre class="codigo">// Lista de vertices<br>short [] vertexValues = {
   0, 0, 0, // 0 
   0, 0, 1, // 1
   0, 1, 0, // 2
   0, 1, 1, // 3
   1, 0, 0, // 4 
   1, 0, 1, // 5 
   1, 1, 0, // 6 
   1, 1, 1  // 7
};<br><br>// Lista de caras<br>int [] faceIndices = {
   0, 1, 2, 3,
   7, 5, 6, 4,
   4, 5, 0, 1,
   3, 7, 2, 6,
   0, 2, 4, 6,
   1, 5, 3, 7
};</pre>
<p>En la lista de v&eacute;rtices podemos ver que tenemos definidas las coordenadas 
  de las 8 esquinas del cubo. En la lista de caras se definen las 6 caras del 
  cubo. Cada cara se define a partir de los 4 v&eacute;rtices que la forman. De 
  estos v&eacute;rtices especificaremos su &iacute;ndice en la lista de v&eacute;rtices.</p>
<p>En M3G representaremos las caras y v&eacute;rtices de nuestros objetos mediante 
  los objetos <code>VertexBuffer</code> e <code>IndexBuffer</code> respectivamente. 
  Estos objetos los crearemos a partir de los arrays de v&eacute;rtices y caras 
  definidos anteriormente.</p>
<p>Para crear el objeto <code>VertexBuffer</code> es necesario que le pasemos 
  los arrays de datos necesarios en forma de objetos <code>VertexArray</code>. 
  Para construir el objeto <code>VertexArray</code> como par&aacute;metros deberemos 
  proporcionar:</p>
<pre class="codigo"><strong>VertexArray</strong> va = new <strong>VertexArray</strong>(numVertices, 
                                 numComponentes, bytesComponente);</pre>
<p>Debemos decir en <code>numVertices</code> el n&uacute;mero de v&eacute;rtices 
  que hemos definido, en <code>numComponentes</code> el n&uacute;mero de componentes 
  de cada v&eacute;rtice (al tratarse de coordenadas 3D en este caso ser&aacute; 
  siempre 3: x, y ,z) y el n&uacute;mero de bytes por componente. Es decir, si 
  se trata de una array de tipo <code>byte</code> tendr&aacute; un byte por componente, 
  mientras que si es de tipo <code>short</code> tendr&aacute; 2 bytes por componente. 
</p>
<p>Una vez creado el array, deberemos llenarlo de datos. Para ello utilizaremos 
  el siguiente m&eacute;todo:</p>
<pre class="codigo">va.<strong>set</strong>(verticeInicial, numVertices, listaVertices);</pre>
<p>Proporcionaremos un array de v&eacute;rtices (<code>listaVertices</code>) como 
  el visto en el ejemplo anterior para insertar dichos v&eacute;rtices en el objeto 
  <code>VertexArray</code>. Adem&aacute;s diremos, dentro de este array de v&eacute;rtices, 
  cual es el v&eacute;rtice inicial a partir del cual queremos empezar a insertar 
  (<code>verticeInicial</code>) y el n&uacute;mero de v&eacute;rtices, a partir 
  de dicho v&eacute;rtice, que vamos a insertar (<code>numVertices</code>).</p>
<p>En el caso del array de v&eacute;rtices de nuestro ejemplo, utilizaremos los 
  siguientes datos:</p>
<pre class="codigo"><strong>VertexArray</strong> va = new <strong>VertexArray</strong>(8, 3, 2);
va.<strong>set</strong>(0, 8, vertexValues);</pre>
<p>Con esto tendremos construido un objeto <code>VertexArray</code> en el que 
  tendremos el array de posiciones de los v&eacute;rtices. </p>
<p>Ahora podremos crear un objeto <code>VertexBuffer</code> y utilizar el objeto 
  anterior para establecer su lista de coordenadas de los v&eacute;rtices. </p>
<pre class="codigo"><strong>VertexBuffer</strong> vb;
...
vb = new <strong>VertexBuffer</strong>();
vb.<strong>setPositions</strong>(va, 1.0f, null);</pre>
<p>Al m&eacute;todo <code>setPositions</code> le podemos proporcionar como segundo 
  y tercer par&aacute;metro un factor de escala y una traslaci&oacute;n respectivamente, 
  para transformar las coordenadas de los puntos que hemos proporcionado. Si no 
  queremos aplicar ninguna transformaci&oacute;n geom&eacute;trica a estos puntos, 
  simplemente proporcionaremos como escala <code>1.0f</code> y como traslaci&oacute;n 
  <code>null</code>. </p>
<p>Una vez creado este objeto, necesitaremos el objeto de &iacute;ndices en el 
  que se definen las caras. Este objeto ser&aacute; de tipo <code>IndexBuffer</code>, 
  sin embargo esta clase es abstracta, por lo que deberemos utilizar una de sus 
  subclases. La &uacute;nica subclase disponible por el momento es <code>TriangleStripArray</code> 
  que representa las caras a partir de tiras (strips) de tri&aacute;ngulos. </p>
<p>Para definir cada tira de tri&aacute;ngulos podremos especificar 3 o m&aacute;s 
  v&eacute;rtices. Si indicamos m&aacute;s de 3 v&eacute;rtices se ir&aacute;n 
  tomando como tri&aacute;ngulos cada trio adyacente de v&eacute;rtices. Por ejemplo, 
  si utilizamos la tira <code>{ 1,2,3,4 }</code>, se crear&aacute;n los tri&aacute;ngulos 
  <code>{ 1,2,3 }</code> y <code>{ 2,3,4 }</code>. </p>
<div align="center"><img src="imagenes/graficos/faces.gif" width="251" height="183"> 
</div>
<p class="caption">Figura 9. Tira de tri&aacute;ngulos para una cara del cubo.</p>
<p>El orden en el que indiquemos los v&eacute;rtices de cada pol&iacute;gono ser&aacute; 
  importante. Seg&uacute;n el sentido de giro en el que se defina su cara frontal 
  y cara trasera ser&aacute; una u otra. La cara frontal ser&aacute; aquella para 
  la que el sentido de giro de los v&eacute;rtices vaya en el sentido de las agujas 
  del reloj. </p>
<p>Cuando creemos este objeto deberemos proporcionar, a parte de la lista de &iacute;ndices, 
  un array con el tama&ntilde;o de cada strip. </p>
<p>Por ejemplo, en el caso del ejemplo del cubo, como cada strip se compone de 
  4 &iacute;ndices, el array de tama&ntilde;os tendr&aacute; el valor 4 para cada 
  uno de los 6 strips que ten&iacute;amos definidos:</p>
<pre class="codigo">int [] stripSizes = {
   4, 4, 4, 4, 4, 4 
};</pre>
<p>Con esta informaci&oacute;n ya podremos crear el objeto <code>TriangleStripArray</code>:</p>
<pre class="codigo"><strong>TriangleStripArray</strong> tsa;
... 
tsa = new <strong>TriangleStripArray</strong>(faceIndices, stripSizes);
</pre>
<p>Adem&aacute;s de la informaci&oacute;n de v&eacute;rtices y caras, deberemos 
  darle una apariencia al objeto creado. Para ello podremos utilizar el objeto 
  <code>Appearance</code>. Podemos crear un objeto con la apariencia por defecto:</p>
<pre class="codigo"><strong>Appaerance</strong> ap;
...
ap = new <strong>Appaerance</strong>();</pre>
<p>Sobre este objeto podremos cambiar el material o la textura de nuestro objeto 
  3D. </p>
<p>Para renderizar el gr&aacute;fico 3D que hemos construido, utilizaremos la 
  siguiente variante del m&eacute;todo <code>render</code>:</p>
<pre class="codigo">g3d.<strong>render</strong>(VertexBuffer vertices, IndexBuffer indices, <br>           Appaerance apariencia, Transform transformacion);</pre>
<p>En ella especificaremos los distintos componentes de nuestra figura 3D, conocida 
  como <em>submesh</em>: lista de v&eacute;rtices (<code>VertexBuffer</code>), 
  lista de caras (<code>IndexBuffer</code>) y apariencia (<code>Appaerance</code>). 
  Adem&aacute;s especificaremos tambi&eacute;n un objeto <code>Transform</code> 
  con la transformaci&oacute;n geom&eacute;trica que se le aplicar&aacute; a nuestro 
  objeto al a&ntilde;adirlo a la escena 3D. Podemos crear una transformaci&oacute;n 
  identidad utilizando el constructor vac&iacute;o de esta clase:</p>
<pre class="codigo"><strong>Transform</strong> tCubo;
...
tCubo = new <strong>Transform</strong>();</pre>
<p>Aplicando esta transformaci&oacute;n se dibujar&aacute; el cubo en sus coordenadas 
  originales. Si posteriormente queremos moverlo en el espacio (trasladarlo o 
  rotarlo) o cambiar su tama&ntilde;o, podremos hacerlo simplemente modificando 
  esta transformaci&oacute;n.</p>
<p>Para renderizar nuestro ejemplo del cubo utilizaremos el m&eacute;todo <code>render</code> 
  como se muestra a continuaci&oacute;n:</p>
<pre class="codigo">g3d.<strong>render</strong>(vb, tsa, ap, tCubo);
</pre>
<p>Con lo que hemos visto hasta ahora, si mostramos el cubo que hemos creado aparecer&aacute; 
  con el siguiente aspecto:</p>
<div align="center"><img src="imagenes/graficos/cubo.gif" width="180" height="177"> 
</div>
<p>Esta es la apariencia (<code>Appaerance</code>) definida por defecto. En ella 
  no hay ning&uacute;n material ni textura definidos para el objeto. Al no haber 
  ning&uacute;n material establecido (el material es <code>null</code>), la iluminaci&oacute;n 
  no afecta al objeto. </p>
<p>Vamos ahora a establecer un material para el objeto. Creamos un material (objeto 
  <code>Material</code>):</p>
<pre class="codigo"><strong>Material</strong> mat = new <strong>Material</strong>();</pre>
<p>Esto nos crea un material blanco por defecto. Podremos modificar en este objeto 
  el color de ambiente, el color difuso, el color especular, y el color emitido 
  del material.</p>
<p>Cuando hayamos establecido un material para el objeto, la iluminaci&oacute;n 
  afectar&aacute; sobre &eacute;l. En este caso ser&aacute; necesario definir 
  las normales de los v&eacute;rtices del objeto. Si estas normales no estuviesen 
  definidas, se producir&aacute; un error al renderizar.</p>
<p>Para asignar las normales a los v&eacute;rtices del objeto utilizaremos un 
  objeto <code>VertexArray</code> que a&ntilde;adiremos al <code>VertexBuffer</code> 
  de nuestro objeto utilizando el m&eacute;todo <code>setNormals</code>.</p>
<pre class="codigo">byte [] normalValues = {
   -1, -1, -1,
   -1, -1, 1,
   -1, 1, -1,
   -1, 1, 1,
   1, -1, -1,
   1, -1, 1,
   1, 1, -1,
   1, 1, 1
};
<br>...<br>   
<strong>VertexArray</strong> na = new <strong>VertexArray</strong>(8, 3, 1);
na.<strong>set</strong>(0, 8, normalValues); 
<br>...<br>   
vb.<strong>setNormals</strong>(na);</pre>
<p>Con esto, al visualizar nuestro cubo con una luz direccional apuntando desde 
  nuestro punto de vista hacia el cubo, se mostrar&aacute; con el siguiente aspecto:</p>
<div align="center"><img src="imagenes/graficos/cubo_mat.gif" width="180" height="177"><br>
</div>
<p>Vamos a ver ahora como a&ntilde;adir textura al objeto. Para ello lo primero 
  que debemos hacer es a&ntilde;adir coordenadas de textura a cada v&eacute;rtice. 
  Para a&ntilde;adir estas coordenadas utilizaremos tambi&eacute;n un objeto <code>VertexArray</code> 
  que a&ntilde;adiremos al <code>VertexBuffer</code> mediante el m&eacute;todo 
  <code>setTexCoords</code>. </p>
<pre class="codigo">short [] tex = {
   0,0, 0,0, 0,1, 0,1,
   1,0, 1,0, 1,1, 1,1
};
   
<strong>VertexArray</strong> ta = new <strong>VertexArray</strong>(8, 2, 2);
ta.set(0, 8, tex);
   
vb.<strong>setTexCoords</strong>(0, ta, 1.0f, null);</pre>
<p>El primer par&aacute;metro que toma <code>setTexCoords</code> es el &iacute;ndice 
  de la unidad de textura a la que se van a asignar esas coordenadas. Como segundo 
  par&aacute;metro se proporcionan las coordenadas en forma de <code>VertexArray</code>. 
  El tercer y cuarto par&aacute;metro nos permiten realizar escalados y traslaciones 
  de estas coordenadas respectivamente.</p>
<p>Una vez hecho esto podemos crear la textura a partir de una imagen y a&ntilde;adirla 
  a la apariencia:</p>
<pre class="codigo">try {
  Image img = Image.createImage(&quot;/texture.png&quot;);
  <strong>Image2D</strong> img2d = new <strong>Image2D</strong>(Image2D.RGB, img);
   
  <strong>Texture2D</strong> tex2d = new <strong>Texture2D</strong>(img2d);
  ap.<strong>setTexture</strong>(0, tex2d);
} catch (IOException e) { }</pre>
<p>La textura se establece en el objeto <code>Appaerance</code> mediante el m&eacute;todo 
  <code>setTexture</code>. A este m&eacute;todo le proporcionamos como par&aacute;metros 
  el &iacute;ndice de la unidad de textura, y la textura que vamos a establecer 
  en dicha unidad de textura. De esta forma se podr&aacute;n definir varias unidades 
  de textura, teniendo cada una de ellas unas coordenadas y una imagen.</p>
<p>Con esto el aspecto del cubo ser&aacute; el siguiente:</p>
<div align="center"><img src="imagenes/graficos/cubo_tex.gif" width="180" height="177"> 
</div>
<p>Podemos a&ntilde;adir animaci&oacute;n al objeto modificando su transformaci&oacute;n 
  a lo largo del tiempo. Para ello podemos crear un hilo como el siguiente:</p>
<pre class="codigo">public void <strong>run</strong>() {
  while(true) {
    tCubo.<strong>postTranslate</strong>(0.5f, 0.5f, 0.5f);
    tCubo.<strong>postRotate</strong>(1.0f, 1.0f, 1.0f, 1.0f);
    tCubo.<strong>postTranslate</strong>(-0.5f, -0.5f, -0.5f);
    <strong>repaint</strong>();
    try {
      Thread.<strong>sleep</strong>(25);
    } catch (InterruptedException e) { }
  }
}</pre>
<p>A continuaci&oacute;n mostramos el c&oacute;digo completo del canvas de este 
  ejemplo:</p>
<pre class="codigo">package es.ua.j2ee.m3d;<br><br>import java.io.IOException;<br><br>import javax.microedition.lcdui.*;
import javax.microedition.m3g.*;
<br>public class Visor3DInmediate extends Canvas implements Runnable {<br><br>  MIDlet3D owner;
   
  Graphics3D g3d;
  Transform tCam;
  Transform tLuz;
  Transform tCubo;
  VertexBuffer vb;
  IndexBuffer tsa;
  Appearance ap;
  Camera cam;
  Light luz;
  Light luzAmbiente;
  Background fondo;
   
  short [] vertexValues = {
    0, 0, 0, // 0 
    0, 0, 1, // 1
    0, 1, 0, // 2
    0, 1, 1, // 3
    1, 0, 0, // 4 
    1, 0, 1, // 5 
    1, 1, 0, // 6 
    1, 1, 1 // 7
  };<br><br>  byte [] normalValues = {
    -1, -1, -1,
    -1, -1, 1,
    -1, 1, -1,
    -1, 1, 1,
    1, -1, -1,
    1, -1, 1,
    1, 1, -1,
    1, 1, 1
  };
   
  int [] faceIndices = {
    0, 1, 2, 3,
    7, 5, 6, 4,
    4, 5, 0, 1,
    3, 7, 2, 6,
    0, 2, 4, 6,
    1, 5, 3, 7
  };<br><br>  int [] stripSizes = {
    4, 4, 4, 4, 4, 4 
  };
   
  short [] tex = {
    0,0, 0,0, 0,1, 0,1,
    1,0, 1,0, 1,1, 1,1
  };
   
  public Visor3DInmediate(MIDlet3D owner) {
    this.owner = owner; 
    init3D();
  }<br><br>  public void init3D() {
   
    g3d = Graphics3D.getInstance();
    tCubo = new Transform();
    tCam = new Transform();
    tLuz = new Transform();<br><br>    cam = new Camera();
    cam.setPerspective(60.0f, (float)getWidth()/(float)getHeight(), 1.0f, 10.0f);
    tCam.postTranslate(0.0f, 0.0f, 2.0f);<br><br>    luz = new Light();
    luz.setColor(0x0ffffff);
    luz.setIntensity(1.0f);
    luz.setMode(Light.DIRECTIONAL);
    tLuz.postTranslate(0.0f, 0.0f, 5.0f); 
   
    luzAmbiente = new Light();
    luzAmbiente.setColor(0x0ffffff);
    luzAmbiente.setIntensity(0.5f);
    luzAmbiente.setMode(Light.AMBIENT);
   
    fondo = new Background();
   
    VertexArray va = new VertexArray(8, 3, 2);
    va.set(0, 8, vertexValues);<br><br>    VertexArray na = new VertexArray(8, 3, 1);
    na.set(0, 8, normalValues);<br><br>    VertexArray ta = new VertexArray(8, 2, 2);
    ta.set(0, 8, tex);
   
    vb = new VertexBuffer();
    vb.setPositions(va, 1.0f, null);
    vb.setNormals(na);
    vb.setTexCoords(0, ta, 1.0f, null);
   
    tsa = new TriangleStripArray(faceIndices, stripSizes);
   
    ap = new Appearance();
    Material mat = new Material();
    ap.setMaterial(mat);
   
    try {
      Image img = Image.createImage(&quot;/texture.png&quot;);
      Image2D img2d = new Image2D(Image2D.RGB, img);
   
      Texture2D tex2d = new Texture2D(img2d);
      ap.setTexture(0, tex2d);
    } catch (IOException e) { }
   
    tCubo.postTranslate(-0.5f, -0.5f, -0.5f);
  }
   
  protected void showNotify() {
    Thread t = new Thread(this);
    t.start();
  } <br><br>  public void run() {
    while(true) {
      tCubo.postTranslate(0.5f, 0.5f, 0.5f);
      tCubo.postRotate(1.0f, 1.0f, 1.0f, 1.0f);
      tCubo.postTranslate(-0.5f, -0.5f, -0.5f);
      repaint();
      try {
        Thread.sleep(25);
      } catch (InterruptedException e) { }
    }
  }
   
  protected void paint(Graphics g) {
    try {
      g3d.bindTarget(g);
   
      g3d.setCamera(cam, tCam);
      g3d.resetLights();
      g3d.addLight(luz, tLuz);
      g3d.addLight(luzAmbiente, null);
      g3d.clear(fondo);
   
      g3d.render(vb, tsa, ap, tCubo);
    } finally {
      g3d.releaseTarget(); 
    }
  }<br>}</pre>
<h3><strong>6.6.7. Modo retained</strong></h3>
<p>Utilizando este modo trabajaremos con un grafo en el que tendremos los distintos 
  elementos de la escena 3D: objetos 3D, luces, c&aacute;maras, etc. Este grafo 
  estar&aacute; compuesto por objetos derivados de <code>Node</code> (nodos). 
  Tenemos los siguientes tipos de nodos disponibles:</p>
<ul>
  <li><strong><code>World</code></strong>: El nodo ra&iacute;z de este grafo es 
    del tipo <code>World</code>, que representa nuestro mundo 3D completo. De 
    &eacute;l colgaremos todos los objetos del mundo, las c&aacute;maras y las 
    luces. Adem&aacute;s, el nodo <code>World</code> tendr&aacute; asociado el 
    fondo (<code>Background</code>) de la escena.<br>
  </li>
  <li><strong><code>Group</code></strong>: Grupo de nodos. Nos permite crear grupos 
    de nodos dentro del grafo. De &eacute;l podremos colgar varios nodos. El tener 
    los nodos agrupados de esta forma nos permitir&aacute;, aplicando transformaciones 
    geom&eacute;tricas sobre el grupo, mover todos estos nodos como un &uacute;nico 
    bloque. Podemos crear un nuevo grupo creando un nuevo objeto <code>Group</code>, 
    y a&ntilde;adir nodos hijos mediante su m&eacute;todo <code>addChild</code>.<br>
  </li>
  <li><strong><code>Camera</code></strong>: Define una c&aacute;mara (punto de 
    vista) en la escena. Las c&aacute;maras definen la posici&oacute;n del espectador 
    en la escena. Podemos tener varias c&aacute;maras en el mundo, pero en un 
    momento dado s&oacute;lo puede haber una c&aacute;mara activa, que ser&aacute; 
    la que se utilice para renderizar. Se crean como hemos visto en apartados 
    anteriores. El objeto correspondiente al mundo (<code>World</code>) tiene 
    un m&eacute;todo <code>setActiveCamera</code> con el que podremos establecer 
    cu&aacute;l ser&aacute; la c&aacute;mara activa en cada momento.<br>
  </li>
  <li><strong><code>Light</code></strong>: Define las luces de la escena. Se crean 
    como hemos visto en apartados anteriores. <br>
  </li>
  <li><strong><code>Mesh</code></strong>: Define un objeto 3D. Este objeto se 
    puede crear a partir de sus v&eacute;rtices y caras como vimos en el apartado 
    anterior.</li>
</ul>
<pre class="codigo"><strong>Mesh</strong> obj = new <strong>Mesh</strong>(vb, tsa, ap);</pre>
<ul>
  <li><strong><code>Sprite3D</code></strong>: Representa una imagen 2D posicionada 
    dentro de nuestro mundo 3D y alineada con la pantalla.</li>
</ul>
<div align="center"><img src="imagenes/graficos/nodos.gif" width="337" height="211"> 
</div>
<p class="caption">Figura 10. Ejemplo de grafo de la escena.</p>
<p>En este modo normalmente cargaremos estos componentes de la escena 3D de un 
  fichero con formato M3G. Para crear mundo en este formato podremos utilizar 
  herramientas como Swerve Studio. De este modo podremos modelar objetos 3D complejos 
  utilizando una herramienta adecuada, y posteriormente importarlos en nuestra 
  aplicaci&oacute;n.</p>
<p>Para cargar objetos 3D de un fichero M3G utilizaremos un objeto <code>Loader</code> 
  de la siguiente forma:</p>
<pre class="codigo"><strong>World</strong> mundo;<br>...<br>try {
  <strong>Object3D</strong> [] objs = <strong>Loader</strong>.<strong>load</strong>(&quot;/mundo.m3g&quot;); 
  mundo = (<strong>World</strong>)objs[0];
} catch (IOException e) {
  System.out.println(&quot;Error al cargar modelo 3D: &quot; + e.getMessage());
}</pre>
<p>Con <code>load</code> cargaremos del fichero M3G especificado los objetos 3D 
  que contenga. La clase <code>Object3D</code> es la superclase de todos los tipos 
  de objetos que podemos utilizar para definir nuestra escena. De esta forma permitimos 
  que esta funci&oacute;n nos devuelva cualquier tipo de objeto, seg&uacute;n 
  lo que haya almacenado en el fichero. Estos objetos pueden ser nodos como los 
  vistos anteriormente, animaciones, im&aacute;genes, etc.</p>
<p>Por ejemplo, si tenemos un fichero M3G que contiene un mundo 3D completo (objeto 
  <code>World</code>), cogeremos el primer objeto devuelto y haremos una conversi&oacute;n 
  cast al tipo adecuado (<code>World</code>).</p>
<p>Como en este objeto se define la escena completa, no har&aacute; falta a&ntilde;adir 
  nada m&aacute;s, podemos renderizarlo directamente con:</p>
<pre class="codigo">protected void <strong>paint</strong>(Graphics g) {
  try {
    g3d.<strong>bindTarget</strong>(g);   
    g3d.<strong>render</strong>(mundo);
  } finally {
    g3d.<strong>releaseTarget</strong>(); 
  }
}</pre>
<p>En el mundo 3D del fichero, a parte de los modelos 3D de los objetos, luces 
  y c&aacute;maras, podemos almacenar animaciones predefinidas sobre elementos 
  del mundo. Para utilizar esta animaci&oacute;n llamaremos al m&eacute;todo <code>animate</code> 
  sobre el mundo que queremos animar:</p>
<pre class="codigo">protected void <strong>paint</strong>(Graphics g) {
  try {
    g3d.<strong>bindTarget</strong>(g);<br>    mundo.<strong>animate</strong>(tiempo);
    g3d.<strong>render</strong>(mundo);
  } finally {
    g3d.<strong>releaseTarget</strong>(); 
  }
}</pre>
<p>Le deberemos proporcionar un valor de tiempo, que deberemos ir incrementando 
  cada vez que se pinta. Podemos crear un hilo que cada cierto periodo incremente 
  este valor y llame a <code>repaint</code> para volver a renderizar la escena. 
</p>
<p>A continuaci&oacute;n vemos el c&oacute;digo completo el ejemplo de mundo que 
  utiliza modo <em>retained</em>:</p>
<pre class="codigo">package es.ua.j2ee.m3d;<br><br>import java.io.IOException;<br><br>import javax.microedition.lcdui.*;
import javax.microedition.m3g.*;<br><br>public class Visor3DRetained extends Canvas implements Runnable {<br><br>  MIDlet3D owner;
<br>  Graphics3D g3d;
  World mundo;
<br>  int tiempo = 0;
   
  public Visor3DRetained(MIDlet3D owner) {
    this.owner = owner;   
    init3D();
  }<br><br>  public void init3D() {  
    g3d = Graphics3D.getInstance();
   
    try {
      Object3D [] objs = Loader.load(&quot;/mundo.m3g&quot;); 
      mundo = (World)objs[0];
    } catch (IOException e) {
      System.out.println(&quot;Error al cargar modelo 3D: &quot; + e.getMessage());
    }
  }
   
  protected void showNotify() {
    Thread t = new Thread(this);
    t.start();
  }<br><br>  public void run() {
    while(true) {
      tiempo+=10;
      repaint();
      try {
        Thread.sleep(25);
      } catch (InterruptedException e) { }
    }
  }
   
  protected void paint(Graphics g) {
    try {
      g3d.bindTarget(g);
   
      mundo.animate(tiempo);
      g3d.render(mundo);
    } finally {
      g3d.releaseTarget(); 
    }
  }<br>}</pre>
</body>
</html>
