<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Ejercicios de red</title>
<link rel="stylesheet" href="../apuntes.css" type="text/css">
</head>
<body>

<h2> A.10. Red</h2>
             
<p><strong>10.1.</strong> Vamos a ver como ejemplo una aplicaci&oacute;n de chat 
  para el m&oacute;vil. En el directorio <code>ejemplos</code> de las plantillas 
  de la sesi&oacute;n se encuentra una aplicaci&oacute;n web con todos los servlets 
  que necesitaremos para probar los ejemplos. Podremos desplegar esta aplicaci&oacute;n 
  en Tomcat para hacer pruebas con nuestro propio servidor.</p>
<p>Podemos encontrar la aplicaci&oacute;n de chat implementada en el directorio 
  <code>Chat</code>, que realiza las siguientes tareas:</p>
<ul>
  <li>Lo primero que se mostrar&aacute; ser&aacute; una pantalla de <em>login</em>, 
    donde el usuario deber&aacute; introducir el <em>login</em> con el que participar 
    en el chat. Deberemos enviar este <em>login</em> al servidor para iniciar 
    la sesi&oacute;n. Para ello abriremos una conexi&oacute;n con la URL del <em>servlet</em> 
    proporcionando los siguientes par&aacute;metros:</li>
</ul>
<blockquote>
  <p><code>?accion=login&amp;id=&lt;nick_del_usuario&gt;</code></p>
  <p>Si el <em>login</em> es correcto, el servidor nos devolver&aacute; un c&oacute;digo 
    de respuesta <code>200 OK</code>. Adem&aacute;s deberemos leer la cabecera 
    <code>URL-Reescrita</code>, donde nos habr&aacute; enviado la URL rescrita 
    que deberemos utilizar de ahora en adelante para mantener la sesi&oacute;n.</p>
</blockquote>
<ul>
  <li> Una vez hemos entrado en el chat, utilizaremos la t&eacute;cnica de <em>polling</em> 
    para obtener los mensajes escritos en el chat y mostrarlos en la pantalla. 
    Utilizando la URL rescrita, conectaremos al <em>servlet</em> del chat proporcionando 
    el siguiente par&aacute;metro:</li>
</ul>
<blockquote> 
  <p><code>?accion=lista</code></p>
  <p>Esto nos devolver&aacute; como respuesta una serie de mensajes, codificados 
    mediante un objeto <code>DataOutputStream</code> de la siguiente forma:</p>
  <p><code>&lt;nick1&gt; &lt;mensaje1&gt;<br>
    &lt;nick2&gt; &lt;mensaje2&gt;</code> <code><br>
    ...<br>
    &lt;nickN&gt; &lt;mensajeN&gt;</code></p>
  <p>De esta forma podremos utilizar un objeto <code>DataInputStream</code> para 
    ir leyendo con el m&eacute;todo <code>readUTF</code> las cadenas del <em>nick</em> 
    y del texto de cada mensaje del chat:</p>
  <pre class="codigo">String nick = dis.readUTF();
String texto = dis.readUTF();</pre>
</blockquote>
<ul>
  <li>Para enviar mensajes al chat utilizaremos el bloque de contenido, conect&aacute;ndonos 
    a la URL rescrita proporcionando el siguiente par&aacute;metro:</li>
</ul>
<blockquote> 
  <p><code>?accion=enviar</code></p>
  <p>El mensaje se deber&aacute; codificar en binario, escribiendo la cadena del 
    mensaje con el m&eacute;todo <code>writeUTF</code> de un objeto <code>DataOutputStream</code>. 
    Si obtenemos una respuesta <code>200 OK</code> el mensaje habr&aacute; sido 
    enviado correctamente.</p>
</blockquote>
<h2></h2>
<p><strong>10.2.</strong> Vamos a acceder desde el m&oacute;vil a nuestra tienda 
  virtual. Mostraremos en el m&oacute;vil una pantalla en la que aparecer&aacute; 
  la lista de productos que hay disponibles en nuestra tienda. Al pulsar sobre 
  cada uno de ellos nos mostrar&aacute; informaci&oacute;n detallada sobre el 
  producto.</p>
<p>Tenemos la aplicaci&oacute;n base implementada en el directorio <code>Tienda</code>. 
  Deberemos a&ntilde;adir en el m&eacute;todo <code>leeProductos</code> de la 
  clase <code>ListaProductos</code> el c&oacute;digo necesario para leer la lista 
  de productos de la red.</p>
<p>Para ello conectaremos a la URL donde tenemos el <em>servlet</em> de nuestra 
  tienda y leeremos la informaci&oacute;n de los productos que nos env&iacute;a 
  en la respuesta. La informaci&oacute;n que se env&iacute;a consiste en una serie 
  de objetos <code>Producto</code> serializados. Para leerlos podremos deserializar 
  objetos <code>Producto</code> del flujo de entrada hasta que se produzca una 
  <code>EOFException</code>, indic&aacute;ndonos que se ha llegado al final del 
  flujo.</p>
<p><strong>10.3.</strong> En el directorio <code>PruebaBT</code> podemos encontrar 
  una aplicaci&oacute;n sencilla de ejemplo que establece una conexi&oacute;n 
  bluetooth. Podemos cargar varios emuladores que se conecten como esclavos y 
  un emulador que haga el papel de maestro. Realizaremos lo siguiente:</p>
<ul>
  <li>Cargar un emulador que se comporte como esclavo, publicando su servicio 
    y esperando una conexi&oacute;n entrante.</li>
  <li>Cargar un emulador que se comporte como maestro, descubriendo los dispositivos 
    y servicios de su entorno.</li>
  <li>Establecer una conexi&oacute;n con el dispositivo esclavo que habr&aacute; 
    localizado. </li>
</ul>

<p>Una vez probada la aplicaci&oacute;n, se pide:</p>
<p><em>a)</em> Convertir la aplicaci&oacute;n en un chat. Para ello se crear&aacute; un nuevo 
  formulario para la pantalla de chat, que tendr&aacute; como items un cuadro de texto
  donde podremos introducir nuevos mensajes, y a continuaci&oacute;n una lista de los 
  mensajes enviados por los usuarios.</p>

<p>Este formulario de chat utilizar&aacute; los flujos de entrada y salida abiertos por 
  la conexi&oacute;n bluetooth para recibir y enviar mensajes respectivamente.</p>

<p>AYUDA: El formulario puede tener un <code>TextField</code> para enviar mensajes y a continuaci&oacute;n
  una serie de <code>StringItem</code> con los mensajes que se intercambian en la conversaci&oacute;n. Cada 
  vez que se recibe un mensaje, se puede insertar en la segunda posici&oacute;n del formulario,
  justo despu&eacute;s del cuadro de texto, para tener siempre arriba los &uacute;ltimos 
  mensajes recibidos.</p>

<p>Cada vez que se escribe un mensaje, se puede enviar a trav&eacute;s del flujo de 
  salida como una cadena UTF. Para recibir mensajes, podemos tener un hilo ejecut&aacute;ndose
  indefinidamente esperando leer cadenas UTF del flujo de entrada. Cada vez que llegue una
  nueva cadena se mostrar&aacute; como mensaje en el formulario.</p>

<p><em>b)</em> Hacer que el chat realice una conexi&oacute;n punto-a-multipunto, para permitir tener
  conectados m&uacute;ltiples usuarios. Para ello el maestro deber&aacute; conectarse a 
  todos los esclavos que haya localizado durante la busqueda, manteniendo abierto un par
  de flujos entrada/salida para cada uno de ellos.</p>

<p>El maestro ser&aacute; el responsable de reenviar los mensajes que le lleguen de cada esclavo
  a todos los esclavos conectados. Para ello se propone el siguiente mecanismo:</p>

<ul>
  <li>Cuando se escriba un mensaje en un dispositivo esclavo, este mensaje ser&aacute; enviado
  al maestro.</li>
  <li>Los esclavos esperar&aacute;n recibir del maestro los mensajes publicados por cualquier
  usuario, incluido &eacute;l mismo y el usuario del dispositivo maestro.</li>
  <li>Cuando el maestro reciba un mensaje de cualquier esclavo, lo añadir&aacute; a la lista de
  mensajes recibidos y adem&aacute;s lo difundir&aacute; a todos los esclavos conectados. </li>
  <li>Cuando se escriba un mensaje en el dispositivos maestro, se har&aacute; lo mismo que en
  el caso anterior: lo añadir&aacute; a la lista de mensajes recibidos y lo difundir&aacute; 
  a todos los esclavos conectados. </li>
</ul>

<p>RECOMENDACIONES: Como recomandaci&oacute;n para el diseño de las clases, se recomienda crear una
  interfaz <code>ConexionChat</code>, que incorpore dos m&eacute;todos <code>envia</code> y 
  <code>recibe</code> que sirvan para enviar y recibir respectivamente mensajes a trav&eacute;s 
  de la red. Se har&aacute;n dos implementaciones de esta interfaz: <code>ConexionCliente</code> y 
  <code>ConexionServidor</code>, que gestionen la conexi&oacute;n de los esclavos y del maestro 
  respectivamente.</p>

<p>En el caso del cliente (esclavos), los m&eacute;todos <code>envia</code> y <code>recibe</code> 
  siemplemente enviar&aacute;n y recibir&aacute;n cadenas UTF a trav&eacute;s de los flujos de
  entrada/salida.</p>

<p>El caso del servidor (maestro) ser&aacute; m&aacute;s complejo. La clase <code>ConexionServidor</code>
  deber&aacute; gestionar una lista de clientes conectados. De cada uno de ellos se almacenar&aacute;n
  los flujos de entrada/salida para comunicarse con &eacute;l. Deber&aacute; haber un hilo por cada
  cliente conectado, esperando recibir datos de ese cliente. Cada vez que se reciba algo de un cliente,
  se añadir&aacute; a una lista de mensajes recibidos y se difundir&aacute; a los dem&aacute;s clientes.</p>
  
<p>El m&eacute;todo <code>recibe</code> comprobar&aacute; si hay mensajes en la lista de mensajes 
  recibidos, y de ser as&iacute; sacar&aacute; el primero de la lista y lo devolver&aacute;. Si no, se
  quedar&aacute; esperando hasta que se reciba un mensaje.</p>

<p>El m&eacute;todo <code>envia</code> añadir&aacute; el mensaje a la lista de mensajes recibidos (para
  que lo reciba tambi&eacute;n el mismo servidor), y difundir&aacute; el mensaje a todos los clientes
  conectados.</p>
<p><strong>10.4.</strong> En el directorio <code>PruebaSW</code> se encuentra 
  una aplicaci&oacute;n que utiliza un servicio web sencillo. El servicio web 
  que se utiliza se puede encontrar en el directorio <code>HolaMundoSW</code>, 
  implementado con JWSDP. Desplegar el servicio en JWSDP y probar la aplicaci&oacute;n 
  <code>PruebaSW</code> en un emulador. Comprobar que se conecta correctamente 
  al servicio.</p>
</body>
</html>
