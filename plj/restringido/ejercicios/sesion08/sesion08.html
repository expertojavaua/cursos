<html>
<head>
<title>Tema 2: Caracter&iacute;sticas b&aacute;sicas</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../apuntes.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
 <!-- OneStat -->
<!--ONESTAT SCRIPTCODE START-->
<script type="text/javascript">
<!--
// Account ID : 221957
// Website URL: http://www.jtech.ua.es
// Copyright (C) 2002-2005 OneStat.com All Rights Reserved
function OneStat_Pageview()
{
    var d=document;
    var sid="221957";
    var CONTENTSECTION="";
    var CUSTOMDATA="";
    var osp_URL=d.URL;
    var osp_Title=d.title;
    var t=new Date();
    var p="http"+(d.URL.indexOf('https:')==0?'s':'')+"://stat.onestat.com/stat.aspx?tagver=2&sid="+sid;
    p+="&url="+escape(osp_URL);
    p+="&ti="+escape(osp_Title);
    p+="&section="+escape(CONTENTSECTION);
    p+="&custom="+escape(CUSTOMDATA);
    p+="&rf="+escape(parent==self?window.document.referrer:top.document.referrer);
    p+="&tz="+escape(t.getTimezoneOffset());
    p+="&ch="+escape(t.getHours());
    p+="&js=1";
    p+="&ul="+escape(navigator.appName=="Netscape"?navigator.language:navigator.userLanguage);
    if(osp_URL!=d.URL) p+="&ol="+escape(d.URL);
    if(typeof(screen)=="object"){
       p+="&sr="+screen.width+"x"+screen.height;p+="&cd="+screen.colorDepth;
       p+="&jo="+(navigator.javaEnabled()?"Yes":"No");
    }
    d.write('<img id="ONESTAT_TAG" border="0" width="1" height="1" src="'+p+'" />');
}

OneStat_Pageview();
//-->
</script>
<noscript>
</noscript>
<!--ONESTAT SCRIPTCODE END-->
<h1>Sesi&oacute;n 8. Entrada/salida</h1>
<p>Los programas muy a menudo necesitan enviar datos a un determinado destino, 
  o bien leerlos de una determinada fuente externa, como por ejemplo puede ser 
  un fichero para almacenar datos de forma permanente, o bien enviar datos a través 
  de la red, a memoria, o a otros programas. Esta entrada/salida de datos en Java 
  la realizaremos por medio de <i>flujos (streams)</i> de datos, a través de los 
  cuales un programa podrá recibir o enviar datos en serie.&nbsp;</p>
<h2 class="section">Flujos de datos de entrada/salida</h2>
<p>Existen varios objetos que hacen de flujos de datos, y que se distinguen por 
  la finalidad del flujo de datos y por el tipo de datos que viajen a través de 
  ellos. Según el tipo de datos&nbsp; que transporten podemos distinguir:</p>
<ul>
  <li>Flujos de caracteres</li>
  <li>Flujos de bytes</li>
</ul>
<p>Dentro de cada uno de estos grupos tenemos varios pares de objetos, de los 
  cuales uno nos servirá para leer del flujo y el otro para escribir en él. Cada 
  par de objetos será utilizado para comunicarse con distintos elementos (memoria, 
  ficheros, red u otros programas). Estas clases, según sean de entrada o salida 
  y según sean de caracteres o de bytes llevarán distintos sufijos, según se muestra 
  en la siguiente tabla:</p>
<table border="1" width="100%">
  <tr> 
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Flujo de entrada / lector</b></td>
    <td width="34%"><b>Flujo de salida / escritor</b></td>
  </tr>
  <tr> 
    <td width="33%"><b>Caracteres</b></td>
    <td width="33%">XXXXReader</td>
    <td width="34%">XXXXWriter</td>
  </tr>
  <tr> 
    <td width="33%"><b>Bytes</b></td>
    <td width="33%">XXXXInputStream</td>
    <td width="34%">XXXXOutputStream</td>
  </tr>
</table>
<p>Donde XXXX se referirá a la fuente o sumidero de los datos. Puede tomar 
  valores como los que se muestran a continuación:</p>
<table border="1" width="100%">
  <tr> 
    <td width="18%"><b>File</b></td>
    <td width="82%">Acceso a ficheros</td>
  </tr>
  <tr> 
    <td width="18%"><b>Piped</b></td>
    <td width="82%">Comunicación entre programas mediante tuberías (pipes)</td>
  </tr>
  <tr> 
    <td width="18%"><b>String</b></td>
    <td width="82%">Acceso a una cadena en memoria (solo caracteres)</td>
  </tr>
  <tr> 
    <td width="18%"><b>CharArray</b></td>
    <td width="82%">Acceso a un array de caracteres en memoria (solo caracteres)</td>
  </tr>
  <tr> 
    <td width="18%"><b>ByteArray</b></td>
    <td width="82%">Acceso a un array de bytes en memoria (solo bytes)</td>
  </tr>
</table>
<p>Además podemos distinguir los flujos de datos según su propósito, pudiendo 
  ser:</p>
<ul>
  <li>Canales de datos, simplemente para leer o escribir datos directamente en 
    una fuente o sumidero externo.</li>
  <li>Flujos de procesamiento, que además de enviar o recibir datos realizan algún 
    procesamiento con ellos. Tenemos por ejemplo flujos que realizan un filtrado 
    de los datos que viajan a través de ellos (con prefijo Filter), conversores 
    datos (con prefijo Data), bufferes de datos (con prefijo Buffered), preparados 
    para la impresión de elementos (con prefijo Print), etc.</li>
</ul>
<p>Un tipo de filtros de procesamiento a destacar son aquellos que nos permiten 
  convertir un flujo de bytes a flujo de caracteres. Estos objetos son <b>InputStreamReader</b> 
  y <b>OutputStreamWriter</b>. Como podemos ver en su sufijo, son flujos de caracteres, 
  pero se construyen a partir de flujos de bytes, permitiendo de esta manera acceder 
  a nuestro flujo de bytes como si fuese un flujo de caracteres.</p>
<p>Para cada uno de los tipos básicos de flujo que hemos visto existe una superclase, 
  de la que heredaran todos sus subtipos, y que contienen una serie de métodos 
  que serán comunes a todos ellos. Entre estos métodos encontramos los métodos 
  básicos para leer o escribir caracteres o bytes en el flujo a bajo nivel. En 
  la siguiente tabla se muestran los métodos más importantes de cada objeto:</p>
<table border="1" width="100%">
  <tr> 
    <td width="29%"><b>InputStream</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>available</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>OutputStream</b></td>
    <td width="71%"><b>write</b>(int b), <b>flush</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>Reader</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>close</b>()</td>
  </tr>
  <tr> 
    <td width="29%"><b>Writer</b></td>
    <td width="71%"><b>write</b>(int c), <b>flush</b>(), <b>close</b>()</td>
  </tr>
</table>
<p>Aparte de estos métodos podemos encontrar variantes de los métodos de lectura 
  y escritura, otros métodos, y además cada tipo específico de flujo contendrá 
  sus propios métodos. Todas estas clases se encuentran en el paquete <b>java.io</b>. 
  Para más detalles sobre ellas se puede consultar la especificación de la API 
  de Java.</p>
<h2 class="section">Entrada, salida y salida de error estándar</h2>
<p>Al igual que en C, en Java también existen los conceptos de entrada, salida, 
  y salida de error estándar. La entrada estándar normalmente se refiere a lo 
  que el usuario escribe en la consola, aunque el sistema operativo puede hacer 
  que se tome de otra fuente. De la misma forma la salida y la salida de error 
  estándar lo que hacen normalmente es mostrar los mensajes y los errores del 
  programa respectivamente en la consola, aunque el sistema operativo también 
  podrá redirigirlas a otro destino.</p>
<p>En Java esta entrada, salida y salida de error estándar se tratan de la misma 
  forma que cualquier otro flujo de datos, estando estos tres elementos encapsulados 
  en tres objetos de flujo de datos que se encuentran como propiedades estáticas 
  de la clase <b>System</b>:</p>
<table border="1" width="61%">
  <tr> 
    <td width="52%">&nbsp;</td>
    <td width="23%"><b>Tipo</b></td>
    <td width="25%"><b>Objeto</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Entrada estándar</b></td>
    <td width="23%">InputStream</td>
    <td width="25%">System.<b>in</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Salida estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>out</b></td>
  </tr>
  <tr> 
    <td width="52%"><b>Salida de error estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>err</b></td>
  </tr>
</table>
<p>Para la entrada estándar vemos que se utiliza un objeto <b>InputStream</b> 
  básico, sin embargo para la salida se utilizan objetos <b>PrintWriter</b> que 
  facilitan la impresión de texto ofreciendo a parte del método común de bajo 
  nivel <i>write(int b)</i> <b> </b>para escribir bytes, dos métodos más: <i>print(s)</i> 
  <b> </b>y <i>println(s)</i>. Estas funciones nos permitirán escribir cualquier 
  cadena, tipo básico, o bien cualquier objeto que defina el método <i>toString()</i> 
  que devuelva una representación del objeto en forma de cadena. La única diferencia 
  entre los dos métodos es que el segundo añade automáticamente un salto de línea 
  al final del texto impreso, mientras que en el primero deberemos especificar 
  explícitamente este salto.</p>
<p>Para escribir texto en la consola normalmente utilizaremos:</p>
<pre class="codigo">System.out.println(&quot;Hola mundo&quot;);</pre>
<p>En el caso de la impresión de errores por la salida de error de estándar, deberemos 
  utilizar:&nbsp;</p>
<pre class="codigo">System.err.println(&quot;Error: Se ha producido un error&quot;);</pre>
<p>Además la clase <b>System</b> nos permite sustituir estos flujos por defecto 
  por otros flujos, cambiando de esta forma la entrada, salida y salida de error 
  estándar.</p>
<h2 class="section">Acceso a ficheros</h2>
<p>Podremos acceder a ficheros bien por caracteres, o bien de forma binaria (por 
  bytes). Las clases que utilizaremos en cada caso son:</p>
<table border="1" width="100%">
  <tr> 
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Lectura</b></td>
    <td width="34%"><b>Escritura</b></td>
  </tr>
  <tr> 
    <td width="33%"><b>Caracteres</b></td>
    <td width="33%">FileReader</td>
    <td width="34%">FileWriter</td>
  </tr>
  <tr> 
    <td width="33%"><b>Binarios</b></td>
    <td width="33%">FileInputStream</td>
    <td width="34%">FileOutputStream</td>
  </tr>
</table>
<p>Para crear un lector o escritor de ficheros deberemos proporcionar al constructor 
  el fichero del que queremos leer o en el que queramos escribir. Podremos proporcionar 
  esta información bien como una cadena de texto con el nombre del fichero, o 
  bien construyendo un objeto <b>File</b> representando al fichero al que queremos 
  acceder. Este objeto nos permitirá obtener información adicional sobre el fichero, 
  a parte de permitirnos realizar operaciones sobre el sistema de ficheros.</p>
<p>A continuación vemos un ejemplo simple de la copia de un fichero carácter a 
  carácter:</p>
<pre class="codigo">public void copia_fichero() <br>{
   int c;
   try <br>   {
      <b>FileReader</b> in = new <b>FileReader</b>(&quot;fuente.txt&quot;);
      <b>FileWriter</b> out = new <b>FileWriter</b>(&quot;destino.txt&quot;);
      while( (c = in.<b>read</b>()) != -1)
      {
         out.write(c);
      }
      in.<b>close</b>();
      out.<b>close</b>();
   } catch(<b>FileNotFoundException</b> e1) {
      System.err.println(&quot;Error: No se encuentra el fichero&quot;);
   } catch(<b>IOException</b> e2) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
      System.err.println(&quot;Error leyendo/escribiendo fichero&quot;);
   }
}</pre>
<p> En el ejemplo podemos ver que para el acceso a un fichero es necesario capturar 
  dos excepciones, para el caso de que no exista el fichero al que queramos acceder 
  y por si se produce un error en la E/S.</p>
<p>Para la escritura podemos utilizar el método anterior, aunque muchas veces 
  nos resultará mucho más cómodo utilizar un objeto <b>PrintWriter </b>con el 
  que podamos escribir directamente líneas de texto:</p>
<pre class="codigo">public void escribe_fichero() <br>{
   <b>FileWriter</b> out = null;
   <b>PrintWriter</b> p_out = null;
   try <br>   {
      out = new <b>FileWriter</b>(&quot;result.txt&quot;);
      p_out = new <b>PrintWriter</b>(out);
      p_out.<b>println</b>(&quot;Este texto será escrito en el fichero de salida&quot;);
   } catch(<b>IOException</b> e) {
      System.err.println(&quot;Error al escribir en el fichero&quot;);
   } finally {
      p_out.<b>close</b>();
   }
}</pre>
<p>Observad también el uso del bloque <i>finally</i>, para cerrar el fichero
tanto si se produce un error al escribir en él como si no.</p>
<hr>
<h3>Ejercicio 1: Lectura y escritura b&aacute;sicas</h3>
<p>En este primer ejercicio practicaremos la lectura y escritura b&aacute;sica con ficheros, utilizando las dos posibles alternativas: <i>Streams</i> y <i>Readers/Writers</i>.</p>
<p>Echa un vistazo a la clase <em>sesion08.</em><i>Ej6</i> que se proporciona en la plantilla de la sesi&oacute;n. Ver&aacute;s que hay un constructor vac&iacute;o, y un campo llamado <i>cabecera</i>, que contiene una cadena de texto. Tambi&eacute;n hay dos m&eacute;todos vac&iacute;os, <i>leeEscribeStream</i> y <i>leeEscribeWriter</i>, y un m&eacute;todo <i>main</i> que crea un objeto de tipo <i>Ej6</i> y llama a estos dos m&eacute;todos. Lo que vamos a hacer es rellenar esos dos m&eacute;todos de la forma que se nos indica a continuaci&oacute;n.</p>
<p>El primero de los m&eacute;todos <i>leeEscribeStream</i> va a leer un fichero de entrada (el fichero <i>entrada.dat</i> que se os proporciona en la plantilla), y lo va a volcar a un fichero de salida (fichero <i>salidaStream.dat</i>), pero a&ntilde;adi&eacute;ndole la cadena <i>cabecera</i> como encabezado del fichero. Para hacer todo eso emplear&aacute; flujos de tipo <i>stream</i> (<i>InputStream</i> para leer, <i>OutputStream</i> para escribir, o cualquier subclase derivada de &eacute;stas).</p>
<ul>
  <li>Primero obtendremos el flujo de entrada para leer del fichero. Utilizaremos un objeto de tipo <i>FileInputStream</i>, que es el stream preparado para leer de ficheros:
  </li>
</ul>
<blockquote>
  <pre class="codigo">FileInputStream in = new FileInputStream(&quot;entrada.dat&quot;);</pre>
  <p>NOTA IMPORTANTE: vigilad d&oacute;nde pon&eacute;is el fichero <em>entrada.dat</em>, porque puede que no lo encuentre. Una buena idea para que esta l&iacute;nea de c&oacute;digo os funcione es ponerlo en la carpeta ra&iacute;z del proyecto, y no dentro del paquete <em>sesion08</em>. De todas formas, pod&eacute;is ponerlo en cualquier parte, siempre que despu&eacute;s sep&aacute;is c&oacute;mo encontrarlo desde Java. </p>
</blockquote>
<ul>
  <li>Despu&eacute;s obtendremos el flujo de salida, para escribir en el fichero destino. Emplearemos un objeto de tipo <i>FileOutputStream</i>, que es el stream preparado para volcar datos a ficheros:
    <pre class="codigo">FileOutputStream out = new FileOutputStream(&quot;salidaStream.dat&quot;);</pre>
  </li>
</ul>
<blockquote>
  <p>Aqu&iacute; tendremos que tener las mismas consideraciones que con el fichero de entrada, en cuanto a c&oacute;mo localizarlo. En este caso no es tan importante, porque el fichero lo crear&aacute; de todas formas, en un lugar u otro, pero debemos saber d&oacute;nde lo va a crear. Con una l&iacute;nea como &eacute;sta, lo crear&aacute; en la carpeta ra&iacute;z del proyecto tambi&eacute;n. </p>
</blockquote>
<ul>
  <li>El siguiente paso es leer el contenido de la entrada, e irlo volcando en la salida. Para leer datos de la entrada emplearemos el m&eacute;todo <i>read()</i> de <i>FileInputStream</i>, que ir&aacute; leyendo caracteres (transformados en enteros). Para escribir, utilizaremos el m&eacute;todo <i>write()</i> de <i>FileOutputStream</i>, que vuelca esos mismos enteros que leemos:
    <pre class="codigo">int c;
while ((c = in.read()) != -1)
{
   out.write(c);
}
</pre>
    <p>Echa un vistazo a la documentaci&oacute;n sobre el m&eacute;todo <i>read. </i>&iquest;Por qu&eacute; se compara el dato que se lee con -1?</p>
  </li>
  <li>Finalmente, lo que nos queda es cerrar tanto el flujo de entrada como el de salida:
    <pre class="codigo">in.close();
out.close();</pre>
  </li>
  <li>Compila el programa. Te dar&aacute; errores porque se deben capturar ciertas excepciones cuando se trabaja con m&eacute;todos de entrada salida en fichero (<i>FileNotFoundException</i> e <i>IOException</i>, concretamente).&nbsp;
Arr&eacute;glalo y prueba el resultado.</li>
</ul>
<ul>
  <li>Al ejercicio le falta algo, porque si recuerdas, aparte de leer y volcar el contenido del fichero, debemos a&ntilde;adir a la salida como cabecera el contenido del campo <i>cabecera</i>.<br>
    <br>
    Observa en la API que la clase <i>FileOutputStream</i> no tiene m&eacute;todos para escribir directamente una cadena a fichero. Lo que vamos a hacer es convertir la cadena a un array de <i>bytes</i>, y luego utilizar el m&eacute;todo <i>write(byte[ ] b)</i> para volcarla. Todo esto lo haremos justo antes de empezar a leer el fichero de entrada, y volcar su contenido:
    <pre class="codigo">byte[] b = cabecera.getBytes();
out.write(b);</pre>
  </li>
  <li>Prueba el m&eacute;todo ya completo, y comprueba que el fichero de salida (<i>salidaStream.dat</i>) deja algo como:</li>
</ul>
<blockquote>
  <pre class="codigo"># Esto es la cabecera del fichero que hay que introducir
Hola, este es el texto
del fichero de entrada
que deber&iacute;a copiarse en el fichero de salida</pre>
</blockquote>
<p>El segundo m&eacute;todo, <i>leeEscribeWriter</i>, leer&aacute; el mismo fichero de entrada (<i>entrada.dat</i>), y lo volcar&aacute; a otro fichero de salida diferente (<i>salidaWriter.dat</i>), empleando flujos de tipo <i>Reader</i> y <i>Writer</i> (como <i>FileReader</i> o <i>FileWriter</i>, o cualquier otro subtipo).</p>
<ul>
  <li>Igual que en el m&eacute;todo anterior, primero obtendremos las variables para leer de la entrada y escribir en la salida. Para leer podr&iacute;amos utilizar la clase <i>FileReader</i>, pero en su lugar vamos a utilizar la clase <i>BufferedReader</i> que nos va a permitir leer l&iacute;neas enteras del fichero, en lugar de leer car&aacute;cter a car&aacute;cter. Para escribir, vamos a utilizar la clase <i>PrintWriter</i>, que tambi&eacute;n nos permitir&aacute; escribir l&iacute;neas enteras en la salida. 
    <pre class="codigo">BufferedReader br =  new BufferedReader(new FileReader(&quot;entrada.dat&quot;));
PrintWriter pw = new PrintWriter(new FileWriter(&quot;salidaWriter.dat&quot;));</pre>
    <p>Observad que para construir tanto el <i>BufferedReader</i> como el <i>PritWriter</i> nos valemos de un objeto <i>FileReader</i> o <i>FileWriter</i>, respectivamente. Lo que hacemos es simplemente crear un buffer de entrada (<i>BufferedReader</i>) o de salida <i>(PrintWriter</i>) sobre el <i>FileReader</i> o el <i>FileWriter </i>para poder acumular cadenas de texto enteras antes de leerlas o escribirlas. Deberemos tener las mismas consideraciones que con el m&eacute;todo anterior sobre d&oacute;nde poner los ficheros para que el programa los encuentre. </p>
  </li>
  <li>El siguiente paso es leer el contenido de la entrada, e irlo volcando en la salida. Para leer datos de la entrada emplearemos el m&eacute;todo <i>readLine()</i> de <i>BufferedReader</i>, que ir&aacute; leyendo l&iacute;neas enteras del fichero. Para escribir, utilizaremos el m&eacute;todo <i>println()</i> de <i>PrintWriter</i>, que vuelca esas mismas l&iacute;neas que leemos: 
    <pre class="codigo">String linea = &quot;&quot;;
while ((linea = br.readLine()) != null)
{
   pw.println(linea);
}</pre>
    <p>El uso de <i>PrintWriter</i> permite formatear la salida de la misma forma que si la estuvi&eacute;semos sacando por pantalla, puesto que tiene los mismos m&eacute;todos que el campo <i>System.out</i> (m&eacute;todos <i>println, print</i>, etc).<br>
      <br>
    Echa un vistazo a la documentaci&oacute;n sobre el m&eacute;todo <i>readLinea. </i>&iquest;Por qu&eacute; se compara el dato que se lee con <i>null</i>?</p>
  </li>
  <li>Finalmente, lo que nos queda es cerrar tanto el flujo de entrada como el de salida:
    <pre class="codigo">br.close();
pw.close();</pre>
  </li>
  <li>Compila el programa. Te dar&aacute; errores porque se deben capturar las mismas excepciones que antes (<i>FileNotFoundException</i> e <i>IOException</i>).&nbsp;Capt&uacute;ralas y prueba el resultado.</li>
</ul>
<ul>
  <li>Para completar el ejercicio, nos falta a&ntilde;adir la cabecera antes de volcar el fichero. Observa que con <i>PrintWriter</i> no hace falta que convirtamos la cadena a <i>bytes</i> y luego la escribamos, podemos escribir directamente la cadena, antes de empezar a leer el fichero:
    <pre class="codigo">pw.print(cabecera);</pre>
    <p>Prueba el m&eacute;todo ya completo, y comprueba que el fichero de salida (<i>salidaWriter.dat</i>) deja el mismo resultado que con el m&eacute;todo anterior.</p>
  </li>
</ul>
<p>NOTA: observa la API de la clase <i>PrintWriter</i>, y ver&aacute;s que tiene constructores que permiten crear este tipo de objetos a partir de <i>Writers</i> (como hemos hecho aqu&iacute;) como a partir de <i>OuputStreams</i> (como habr&iacute;amos hecho en el paso 2), con lo que podemos utilizar esta clase para dar formato a la salida de un fichero en cualquiera de los casos.</p>
<hr/>
<h3 class="subsection">Un caso particular: ficheros de propiedades</h3>
<p>La clase <b>java.util.Properties </b>permite manejar de forma muy sencilla lo
que se conoce como <i>ficheros de propiedades</i>. Dichos ficheros permiten
almacenar una serie de pares <i>nombre=valor</i>, de forma que tendría una
apariencia como esta:</p>
<pre class="codigo">#Comentarios
elemento1=valor1
elemento2=valor2
...
elementoN=valorN</pre>
<p>Para leer un fichero de este tipo, basta con crear un objeto <i>Properties</i>,
y llamar a su método <i>load()</i>, pasándole como parámetro el fichero que
queremos leer, en forma de flujo de entrada (<i>InputStream</i>):</p>
<pre class="codigo">Properties p = new Properties();
p.load(new FileInputStream(&quot;datos.txt&quot;);</pre>
<p align="left">Una vez leído, podemos acceder a todos los elementos del
fichero desde el objeto <i>Properties</i> cargado. Tenemos los métodos <i>getProperty</i>
y <i>setProperty</i> para acceder a y modificar valores:</p>
<pre class="codigo">String valorElem1 = p.getProperty(&quot;elemento1&quot;);
p.setProperty(&quot;elemento2&quot;, &quot;otrovalor&quot;);</pre>
<p align="left">También podemos obtener todos los nombres de elementos que hay,
y recorrerlos, mediante el método <i>propertyNames()</i>, que nos devuelve una <i>Enumeration</i>
para ir recorriendo:</p>
<pre class="codigo">Enumeration en = p.propertyNames();
while (en.hasMoreElements())
{
   String nombre = (String)(en.nextElement());
   String valor = p.getProperty(nombre);
}</pre>
<p align="left">Una vez hayamos leído o modificado lo que quisiéramos, podemos
volver a guardar el fichero de propiedades, con el método <i>store </i>de <i>Properties</i>,
al que se le pasa un flujo de salida (<i>OutputStream</i>) y una cabecera para
el fichero:</p>
<pre class="codigo">p.store(new FileOutputStream(&quot;datos.txt&quot;), &quot;Fichero de propiedades&quot;);</pre>
<p><strong>Propiedades del sistema </strong></p>
<p>Como se ha visto en la sesi&oacute;n de utilidades, la clase <strong>System</strong> tiene m&eacute;todos como <strong>getProperty</strong>, <strong>setProperty</strong> a los que se les pasa un nombre de propiedad del sistema, y permiten obtener o cambiar su valor, respectivamente. Adem&aacute;s, tenemos un m&eacute;todo</p>
<pre class="codigo">Properties getProperties();</pre>
<p>que devuelve un objeto <em>Properties</em> con todas las propiedades del sistema. Podremos recorrerlas, ver cu&aacute;les son, y aprovechar sus valores en nuestros programas.</p>
<hr>
<h3>Ejercicio 2: Trabajar con propiedades</h3>
<p>En este segundo ejercicio practicaremos el uso de ficheros de propiedades, y el uso de la entrada y salida est&aacute;ndares. Echa un vistazo a la clase <i>sesion08.Ej7</i> que se proporciona en la plantilla de la sesi&oacute;n. S&oacute;lo tiene un constructor vac&iacute;o, y un m&eacute;todo <i>main</i> que le llama. Vamos a completar el constructor de la forma que veremos a continuaci&oacute;n. </p>
<p>Lo que vamos a hacer en el constructor es leer un fichero de propiedades (el fichero <i>prop.txt</i> que se proporciona en la plantilla), y luego pedirle al usuario que, por teclado, indique qu&eacute; valores quiere que tengan las propiedades. Una vez establecidos los valores, volveremos a guardar el fichero de propiedades.</p>
<p>Lo primero que vamos a hacer es leer el fichero de propiedades. Para ello utilizaremos un objeto <i>java.util.Properties</i>, lo crearemos y llamaremos a su m&eacute;todo <i>load()</i> para cargar las propiedades del fichero <i>prop.txt</i>:
</p>
<pre class="codigo">Properties p = new Properties();
p.load(new FileInputStream(&quot;prop.txt&quot;));</pre>
<p>Observa que para cargar las propiedades, al m&eacute;todo <i>load</i> le debemos pasar un <i>InputStream</i> desde el que leerlas. En este caso le pasamos un <i>FileInputStream</i> con el fichero <i>prop.txt</i>.</p>
<p>Ahora ya tenemos en el objeto <i>p</i> todas las propiedades del fichero. Vamos a irlas recorriendo una a una, e indicando al usuario que teclee su valor. Para recorrer las propiedades obtendremos un <i>Enumeration</i> con sus nombres, y luego lo iremos recorriendo, y sac&aacute;ndolo por pantalla:
</p>
<pre class="codigo">Enumeration en = p.propertyNames();
while (en.hasMoreElements())
{
   String prop = (String)(en.nextElement());
   System.out.println(&quot;Introduzca valor para propiedad &quot; + prop);
}</pre>
<p>Observa el orden en que van mostr&aacute;ndose las propiedades. &iquest;Es el mismo que el que hay en el fichero? &iquest;A qu&eacute; crees que puede deberse? (AYUDA: cuando nosotros <i>enumeramos</i> una serie de caracter&iacute;sticas, no tenemos que seguir un orden necesariamente. Del mismo modo, cuando introducimos valores en una tabla hash, el orden en que se guardan no es el mismo que el orden en que los introducimos).</p>
<p>Lo que hacemos con este bucle es s&oacute;lo recorrer los nombres de las propiedades y sacarlos por pantalla. Nos falta hacer que el usuario teclee los valores correspondientes. Para ello utilizaremos un objeto de tipo <i>BufferedReader</i>, que en este caso leer&aacute; l&iacute;neas de texto que el usuario entre desde teclado:</p>
<pre class="codigo">...
Enumeration en = p.propertyNames();
<b>BufferedReader in =  new BufferedReader(new InputStreamReader(System.in));		
</b>...	
</pre>
<p>observad que construimos el <i>BufferedReader</i> para leer de un <i>InputStream</i> (no de un <i>Reader</i>). Esto lo podemos hacer si nos ayudamos de la &quot;clase puente&quot; <i>InputStreamReader</i>, que transforma un tipo de lector en otro.<br>
  <br>
  Lo que nos queda por hacer es pedirle al usuario que, para cada nombre de propiedad, introduzca su valor, y luego asignarlo a la propiedad correspondiente:</p>
<pre class="codigo">...	
while (en.hasMoreElements())
{
   String prop = (String)(en.nextElement());
   System.out.println(&quot;Introduzca valor para propiedad &quot; + prop);
<b>   String valor = in.readLine();
   p.setProperty(prop, valor);</b>
}</pre>
<p>Finalmente, cerramos el buffer de entrada, y guardamos las propiedades en el fichero.</p>
<pre class="codigo">in.close();
p.store(new FileOutputStream(&quot;prop.txt&quot;), &quot;Cabecera del fichero&quot;);
</pre>
<p>Compilad y ejecutad el programa. Para que os compile deber&eacute;is capturar las excepciones que se os indique en los errores de compilaci&oacute;n.</p>
<p>A&ntilde;adid el c&oacute;digo necesario al ejercicio para que, adem&aacute;s de poder modificar los valores de las propiedades, podamos a&ntilde;adir por teclado nuevas propiedades al fichero, y guardarlas con las existentes.</p>
<hr/>
<h2 class="section">Lectura de tokens</h2>
<p>Hemos visto como leer un fichero carácter a carácter, pero en el caso de ficheros 
  con una gramática medianamente compleja, esta lectura a bajo nivel hará muy 
  difícil el análisis de este fichero de entrada. Necesitaremos leer del fichero 
  elementos de la gramática utilizada, los llamados <b>tokens</b>, como pueden 
  ser palabras, número y otros símbolos.</p>
<p>La clase <b>StreamTokenizer </b>se encarga de partir la entrada en <b>tokens</b> 
  y nos permitirá realizar la lectura del fichero directamente como una secuencia 
  de <b>tokens</b>. Esta clase tiene una serie de constantes identificando los 
  tipos de <b>tokens</b> que puede leer:</p>
<table border="1" width="100%">
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_WORD</b></td>
    <td width="72%">Palabra</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_NUMBER</b></td>
    <td width="72%">Número real o entero</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_EOL</b></td>
    <td width="72%">Fin de línea</td>
  </tr>
  <tr> 
    <td width="28%">StreamTokenizer.<b>TT_EOF</b></td>
    <td width="72%">Fin de fichero</td>
  </tr>
  <tr> 
    <td width="28%">Carácter de comillas establecido</td>
    <td width="72%">Cadena de texto encerrada entre comillas</td>
  </tr>
  <tr> 
    <td width="28%">Símbolos</td>
    <td width="72%">Vendrán representados por el código del carácter ASCII del 
      símbolo</td>
  </tr>
</table>
<p>Dado que un <b>StreamTokenizer </b>se utiliza para analizar un fichero de texto, 
  siempre habrá que crearlo a partir de un objeto <b>Reader</b> (o derivados).</p>
<pre class="codigo">StreamTokenizer st = new StreamTokenizer(reader);</pre>
<p>El método <b>nextToken() </b>leerá el siguiente token que encuentre en el fichero 
  y nos devolverá el tipo de <b> token</b> del que se trata. Según este tipo podremos 
  consultar las propiedades <b>sval </b>o <b>nval</b> para ver qué cadena o número 
  respectivamente se ha leído del fichero. Tanto cuando se lea un <b> token</b> 
  de tipo <b>TT_WORD </b>como de tipo cadena de texto entre comillas el valor 
  de este <b> token</b> estará almacenado en <b>sval</b>. En caso de la lectura
sea un número, su valor se almacenará en <b>nval </b>que es de tipo <b>double</b>. 
  Como los demás símbolos ya devuelven el código del símbolo como tipo de <b> 
  token</b> no será necesario acceder a su valor por separado. Podremos consultar 
  el tipo del último <b> token</b> leído en la propiedad <b>ttype</b>.</p>
<p>Un bucle de procesamiento básico será el siguiente:</p>
<pre class="codigo">while(st.<b>nextToken</b>() != StreamTokenizer.<b>TT_EOF</b>) <br>{
   switch(st.<b>ttype</b>) <br>   {
      case StreamTokenizer.<b>TT_WORD</b>:
         System.out.println(&quot;Leida cadena: &quot; + st.<b>sval</b>);
         break;
      case StreamTokenizer.<b>TT_NUMBER</b>:
         System.out.println(&quot;Leido numero: &quot; + st.<b>nval</b>);
         break;
   }
}&nbsp;</pre>
<p>Podemos distinguir tres tipos de caracteres:</p>
<table border="1" width="100%" height="71">
  <tr> 
    <td width="36%" height="17">Ordinarios (<b>ordinaryChars</b>)</td>
    <td width="64%" height="17">Caracteres que forman parte de los <i>tokens</i>.</td>
  </tr>
  <tr> 
    <td width="36%" height="18">De palabra (<b>wordChars</b>)</td>
    <td width="64%" height="18">Una secuencia formada enteramente por este tipo 
      de caracteres se considerará una palabra.</td>
  </tr>
  <tr> 
    <td width="36%" height="18">De espacio en blanco (<b>whitespaceChars</b>)</td>
    <td width="64%" height="18">Estos caracteres no son interpretados como <i>tokens</i>, 
      simplemente se utilizan para separar <i>tokens</i>. Normalmente estos caracteres 
      son el espacio, tabulador, y salto de línea.</td>
  </tr>
</table>
<p>Para establecer qué caracteres pertenecerán a cada uno de estos tipos utilizaremos 
  los métodos <i>ordinaryChars</i>, <i>wordChars</i> y <i>whitespaceChars</i> 
  del objeto <b>StreamTokenizer<i> </i></b>respectivamente. A cada uno de estos 
  métodos le pasamos un rango de caracteres (según su código ASCII), que serán 
  establecidos al tipo correspondiente al método que hayamos llamado. Por ejemplo, 
  si queremos que una palabra sea una secuencia de cualquier carácter imprimible 
  (con códigos ASCII desde 32 a 127) haremos lo siguiente:</p>
<pre class="codigo">st.<strong>wordChars</strong>(32,127);</pre>
<p>Los caracteres pueden ser especificados tanto por su código ASCII numérico 
  como especificando ese carácter entre comillas simples. Si ahora queremos hacer 
  que las palabras sean separadas por el caracter ':' (dos puntos) hacemos la 
  siguiente llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>(':', ':');</pre>
<p>De esta forma, si hemos hecho las llamadas anteriores el <i>tokenizer</i> leerá 
  palabras formadas por cualquier carácter imprimible separadas por los dos puntos 
  ':'. Al querer cambiar un único carácter, como siempre deberemos especificar 
  un rango, deberemos especificar un rango formado por ese único carácter como 
  inicial y final del rango. Si además quisieramos utilizar el guión '-' para 
  separar palabras, no siendo caracteres consecutivos guión y dos puntos en la 
  tabla ASCII, tendremos que hacer una tercera llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>('-', '-');</pre>
<p>Así tendremos tanto el guión como los dos puntos como separadores, y el resto 
  de caracteres imprimibles serán caracteres de palabra. Podemos ver que el <b>StreamTokenizer</b> 
  internamente implementa una tabla, en la que asocia a cada carácter uno de los 
  tres tipos mencionados. Al llamar a cada uno de los tres métodos cambiará el 
  tipo de todo el rango especificado al tipo correspondiente al método. Por ello 
  es importante el orden en el que invoquemos este método. Si en el ejemplo en 
  el que hemos hecho estas tres llamadas las hubiésemos hecho en orden inverso, 
  al establecer todo el rango de caracteres imprimibles como <i>wordChars</i> 
  hubiésemos sobrescrito el resultado de las otras dos llamadas y por lo tanto 
  el guión y los dos puntos no se considerarían separadores.</p>
<p>Podremos personalizar el <i> tokenizer</i> indicando para cada carácter a que 
  tipo pertenece. Además de con los tipos anteriores, podemos especificar el carácter 
  que se utilice para encerrar las cadenas de texto (<b>quoteChar</b>), mediante 
  el método <i>quoteChar</i>, y el carácter para los comentarios (<b>commentChar</b>), 
  mediante <i>commentChar</i>. Esto nos permitirá definir comentarios de una línea 
  que comiencen por un determinado carácter, como por ejemplo los comentarios 
  estilo Pascal comenzados por el carácter almohadilla ('#'). Además tendremos 
  otros métodos para activar comentarios tipo C como los comentarios <i>barra-barra 
  </i>(<i>//</i>)<i> </i>y <i>barra-estrella </i>(<i>/* */</i>).</p>
<hr>
<h3>Ejercicio 3: Leyendo matrices</h3>
<p>Vamos a practicar  la lectura de tokens de un fichero, y su almacenamiento para realizar alguna operaci&oacute;n. Echa un vistazo a la clase <i>sesion08.Ej8</i> que se proporciona en la plantilla de la sesi&oacute;n. Ver&aacute;s que hay un constructor vac&iacute;o, y un m&eacute;todo <i>main</i> que le llama. Rellenaremos el constructor como se indica en los siguientes pasos.</p>
<p>Lo que vamos a hacer es que el constructor acceda a un fichero (fichero <i>matriz.txt</i> de la plantilla) que tiene una matriz <i>m x n</i>. Dicho fichero tiene la siguiente estructura:
</p>
<pre class="codigo">; Comentario de cabecera
m n
A11 A12 A13...
A21 A22 A23...
...
        </pre>
<p>donde <i>m</i> son las filas, <i>n </i>las columnas, y despu&eacute;s aparece la matriz puesta por filas, con un espacio en blanco entre cada elemento.<br>
  <br>
El ejercicio leer&aacute; la matriz (utilizando un <i>StreamTokenizer</i> sobre el fichero), construir&aacute; una matriz (array) con los datos le&iacute;dos, despu&eacute;s elevar&aacute; al cuadrado cada componente, y volcar&aacute; el resultado en un fichero de salida.</p>
<p>Primero obtendremos el flujo de entrada para leer del fichero, y el <i>StreamTokenizer</i>:
</p>
<pre class="codigo">StreamTokenizer st =  new StreamTokenizer(new FileReader(&quot;matriz.txt&quot;));</pre>
<p>Despu&eacute;s establecemos qu&eacute; caracteres van a identificar las l&iacute;neas de comentarios. En este caso, los comentarios se identifican por punto y coma:&nbsp;
</p>
<pre class="codigo">st.commentChar(';');
</pre>
<p>Despu&eacute;s del comentario ir&aacute;n el n&uacute;mero de filas y de columnas. Utilizamos el m&eacute;todo <i>nextToken</i> del <i>tokenizer</i> para leerlos, y luego accedemos al campo <i>nval</i> para obtener qu&eacute; valor num&eacute;rico se ha le&iacute;do en cada caso: </p>
<pre class="codigo">int filas, columnas;
	
st.nextToken();
filas = (int)(st.nval);                  // Filas

st.nextToken();
columnas = (int)(st.nval);         // Columnas
</pre>
<p>NOTA: asumimos que el fichero va a tener un formato correcto, y no tenemos que controlar que haya elementos no deseados por enmedio.<br>
  <br>
&iquest;Qu&eacute; se habr&iacute;a le&iacute;do en primer lugar si no hubi&eacute;semos identificado la primera l&iacute;nea como comentario? &iquest;D&oacute;nde podr&iacute;amos haber consultado ese valor le&iacute;do?</p>
<p>Lo siguiente es ir leyendo los elementos de la matriz. Construimos un array de enteros de <i>filas </i>x <i>columnas</i>, y luego lo vamos rellenando con los valores que nos d&eacute; el <i>StreamTokenizer</i>:
</p>
<pre class="codigo">int[][] matriz = new int[filas][columnas];
int t;
			
for (int i = 0; i &lt; filas; i++)
   for (int j = 0; j &lt; columnas; j++)
   {
      t = st.nextToken();
      if (t != StreamTokenizer.TT_EOF)
      {
         matriz[i][j] = (int)(st.nval);
      }
   }				</pre>
<p>Por &uacute;ltimo, calculamos el cuadrado de cada elemento de la matriz (utilizamos el m&eacute;todo <i>pow</i> de la clase <i>Math</i>), y guardamos la matriz resultado en otro fichero de salida (<i>matrizSal.txt</i>), con el mismo formato que el de entrada. Utiliza un objeto <em>PrintWriter</em> para facilitar el volcado de la matriz al fichero.</p>
<p>Compila y ejecuta el programa (captura las excepciones adecuadas para que te compile bien). Comprueba que el fichero de salida genera el resultado adecuado:&nbsp;
</p>
<pre class="codigo">; Matriz resultado
3 3
1 4 9 
16 25 36 
49 64 81 </pre>
<p>Prueba tambi&eacute;n a pasarle este mismo fichero como entrada al programa, y que genere otro fichero de salida diferente. </p>
<hr/>
<h2 class="section">Acceso a ficheros o recursos dentro de un JAR</h2>
<p>Los ficheros JAR son una forma de empaquetar clases Java y otros recursos en un solo fichero, con un formato similar a los ficheros TAR que se suelen utilizar en Linux. De hecho los comandos <em>jar</em> (que viene con Java y se utiliza para crear ficheros JAR) y <em>tar </em>(de Linux) tienen los mismos par&aacute;metros.</p>
<p>De esta forma podremos hacer un programa m&aacute;s portable, al usar un s&oacute;lo fichero. Tambi&eacute;n hay formas de hacer que el JAR auto-ejecute las clases que lleva dentro, con lo que aumenta la facilidad de uso. </p>
<p>Hemos visto como leer y escribir ficheros, pero cuando ejecutamos una
  aplicación contenida en un fichero JAR, puede que necesitemos leer recursos
  contenidos dentro de este JAR.</p>
<p>Para acceder a estos recursos deberemos abrir un flujo de entrada que se
encargue de leer su contenido. Para ello utilizaremos el método <code>getResourceAsStream</code>
de la clase <code>Class</code>:</p>
<pre class="codigo">InputStream in = getClass().<strong>getResourceAsStream</strong>(&quot;/datos.txt&quot;);</pre>
<p>De esta forma podremos utilizar el flujo de entrada obtenido para leer el
contenido del fichero que hayamos indicado. Este fichero deberá estar contenido
en el JAR de la aplicación.</p>
<p>Especificamos el carácter '<code>/</code>' delante del nombre del recurso
para referenciarlo de forma relativa al directorio raíz del JAR. Si no lo
especificásemos de esta forma se buscaría de forma relativa al directorio
correspondiente al paquete de la clase actual.</p>
<h2 class="section">Codificación de datos</h2>
<p class="subsection">Si queremos guardar datos en un fichero binario deberemos
codificar estos datos en forma de <em>array</em> de <em>bytes</em>. Los flujos
de procesamiento <code>DataInputStream</code> y <code>DataOutputStream</code>
nos permitirán codificar y descodificar respectivamente los tipos de datos
simples en forma de <em>array</em> de <em>bytes</em> para ser enviados a través
de un flujo de datos.</p>
<p class="subsection">Por ejemplo, podemos codificar datos en un <em>array</em>
en memoria (<code>ByteArrayOutputStream</code>) de la siguiente forma:</p>
<pre class="codigo">String nombre = &quot;Jose&quot;;
String edad = 25;

<strong>ByteArrayOutputStream</strong> baos = new <strong>ByteArrayOutputStream</strong>();
<strong>DataOutputStream</strong> dos = new <strong>DataOutputStream</strong>(baos);

dos.<strong>writeUTF</strong>(nombre);
dos.<strong>writeInt</strong>(edad);

dos.close();
baos.close();

byte [] datos = baos.<strong>toByteArray</strong>();</pre>
<p class="subsection">Podremos descodificar este <em>array</em> de <em>bytes</em>
realizando el procedimiento inverso, con un flujo que lea un <em>array</em> de <em>bytes</em>
de memoria (<code>ByteArrayInputStream</code>):</p>
<pre class="codigo"><strong>ByteArrayInputStream</strong> bais = new <strong>ByteArrayInputStream</strong>(datos);
<strong>DataInputStream</strong> dis = new <strong>DataInputStream</strong>(bais);

String nombre = dis.<strong>readUTF</strong>();
int edad = dis.<strong>readInt</strong>();
</pre>
<p class="subsection">Si en lugar de almacenar estos datos codificados en una <em>array</em>
en memoria queremos guardarlos codificados en un fichero, haremos lo mismo
simplemente sustituyendo el flujo canal de datos <code>ByteArrayOutputStream</code>
por un <code>FileOutputStream</code>. De esta forma podremos utilizar cualquier
canal de datos para enviar estos datos codificados a través de él.</p>
<h2 class="section">Serialización de objetos</h2>
<p>Si queremos enviar un objeto complejo a través de un flujo de datos, deberemos convertirlo 
  en una serie de bytes. Esto es lo que se conoce como serialización de objetos, 
  que nos permitirá leer y escribir objetos. </p>
<p>Para leer o escribir objetos podemos utilizar los objetos <b>ObjectInputStream 
  </b>y <b>ObjectOutputStream</b> que incorporan los métodos <b>readObject() </b>y 
  <b>writeObject(Object obj) </b>respectivamente. Los objetos que escribamos en 
  dicho flujo deben tener la capacidad de ser <i>serializables</i>. </p>
<p>Serán <i>serializables </i>aquellos objetos que implementan la interfaz <b>Serializable</b>. 
  Cuando queramos hacer que una clase definida por nosotros sea <i>serializable 
  </i>deberemos implementar dicho interfaz, que no define ninguna función, sólo 
  se utiliza para identificar las clases que son <i>serializables</i>. Para que 
  nuestra clase pueda ser <i>serializable</i>, todas sus propiedades deberán ser 
de tipos de datos básicos o bien objetos que también sean<i><b> </b>serializables</i>. </p>
<hr/>
<h3>Ejercicio 4: Guardar datos personales</h3>
<p>En este  ejercicio practicaremos c&oacute;mo utilizar los ficheros para almacenar y leer objetos complejos. Hasta ahora s&oacute;lo hemos trabajado con enteros o cadenas, y para leerlos basta con leer un stream de bytes, o utilizar un <i>tokenizer</i> y procesar el fichero de la forma que nos convenga.<br>
<br>
Imaginemos que trabajamos con un objeto complejo que encapsula diferentes tipos de datos (enteros, cadenas, vectores, etc). A la hora de guardar este elemento en fichero, se nos plantea el problema de c&oacute;mo representar su informaci&oacute;n para volcarla. De la misma forma, a la hora de leerlo, tambi&eacute;n debemos saber c&oacute;mo extraer y recomponer la informaci&oacute;n del objeto. Veremos que hay clases Java que hacen todo este trabajo mucho m&aacute;s sencillo. </p>
<p>Vamos a retomar la clase <em>datos.Persona </em>que hicimos en la sesi&oacute;n 7. Por otro lado, tenemos en la plantilla de esta sesi&oacute;n la clase <em>io.LeeGuardaPersona</em>. Tiene dos m&eacute;todos <em>leePersonas</em> y <em>guardaPersonas</em> que deberemos implementar:</p>
<ul>
  <li>El m&eacute;todo <em>leePersonas</em> deber&aacute; crear un <em>ObjectInputStream</em> y leer de un fichero que se le pase como par&aacute;metro una serie de objetos de tipo <em>datos.Persona</em>, y guardarlos en un <em>ArrayList</em>, que devolver&aacute; cuando termine de leer </li>
</ul>
<blockquote>
  <pre class="codigo">ArrayList al = new ArrayList();<br>try
{<br>   ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fichero));<br>   while (true)<br>   {
      Persona p = (Persona)(ois.readObject());<br>      al.add(p);<br>   }
} catch (Exception e) {<br>}<br>return al;
</pre>
  <p>Te parecer&aacute; raro utilizar un bucle infinito para leer el fichero. El motivo es sencillo. Cuando trabajamos con <em>ObjectInputStreams</em> no hay forma de saber cu&aacute;ndo acaba el fichero, porque leemos objetos complejos enteros, hasta que ya no hay m&aacute;s. En ese momento, se provoca una excepci&oacute;n, y el bucle terminar&aacute; cuando dicha excepci&oacute;n salte, lo que indicar&aacute; el fin de fichero. Despu&eacute;s de eso, devolvemos la lista con los objetos que haya guardados y listo. </p>
</blockquote>
<ul>
  <li>El m&eacute;todo <em>guardaPersonas</em> recibir&aacute; como par&aacute;metro un <em>ArrayList</em> con objetos de tipo <em>datos.Persona</em>, y un nombre de fichero, y deber&aacute; guardar los objetos <em>Persona </em>del <em>ArrayList </em>en el fichero que se le dice mediante un <em>ObjectOutputStream</em>.</li>
  <li>Para que todo esto te funcione bien, la clase <em>datos.Persona</em> debe ser serializable, es decir, debe implementar la interfaz <em>java.io.Serializable</em>. Haz que la implemente.</li>
  <li>Una vez lo tenga todo listo, utiliza el m&eacute;todo <em>main</em> que viene con la clase para probar su funcionamiento. Dicho m&eacute;todo crea un <em>ArrayList</em>, lo llena con algunas <em>Personas</em>, y luego llama a <em>guardaPersonas</em>. Aqu&iacute; vuestro m&eacute;todo deber&aacute; guardar los datos adecuadamente en fichero. Despu&eacute;s, el <em>main </em>llama al m&eacute;todo <em>leePersonas</em> para leer las personas del fichero que se indique, y mostrar sus datos por pantalla. Ejecuta la clase cuando la tengas terminada, para ver si tus m&eacute;todos funcionan como deben. </li>
  <li>Opcionalmente, haz que el m&eacute;todo <em>main</em> de <em>LeeGuardaPersona</em> muestre ordenadamente las personas, seg&uacute;n los criterios de ordenacion vistos en la sesi&oacute;n 7 cuando hiciste la clase <em>Persona</em>. </li>
</ul>
<p>&iquest;Qu&eacute; pasar&iacute;a si <i>Persona</i> no implementase la interfaz <i>Serializable</i>? &iquest;Qu&eacute; excepci&oacute;n saltar&iacute;a al ejecutar?</p>
<hr/>
<p><b>PARA ENTREGAR</b></p>
<p>Guarda en la carpeta <strong>modulo3</strong> de tu CVS los siguientes elementos para esta sesi&oacute;n: </p>
<ul>
  <li>Todos los ficheros fuente (<b>sesion08.Ej6, sesion08.Ej7, sesion08.Ej8 </b>e <strong>io.LeeGuardaPersona</strong>), dentro de los paquetes correspondientes, cada uno con las modificaciones que se han ido solicitando.</li>
  <li>Fichero de texto <b>respuestas.txt</b> de esta sesi&oacute;n contestando a todas las preguntas formuladas.</li>
</ul>
<p>&nbsp;
</p>
</body>
</html>