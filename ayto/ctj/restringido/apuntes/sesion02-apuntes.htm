<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Sesi&oacute;n 2: Tipos de datos y colecciones</title>
<link rel="stylesheet" href="../apuntes.css" type="text/css"></head>
<body>

<h1> 2. Tipos de datos y colecciones </h1>
             
<p>&nbsp; </p>
<p>La plataforma Java nos proporciona un amplio conjunto de clases  dentro del que podemos encontrar tipos de datos que nos  resultar&aacute;n muy &uacute;tiles para realizar la  programaci&oacute;n de aplicaciones en Java. Estos tipos de datos nos  ayudar&aacute;n a generar c&oacute;digo m&aacute;s limpio de una forma  sencilla. </p>
<p>Se proporcionan una serie de operadores para acceder a los elementos  de estos tipos de datos. Decimos que dichos operadores son <em>polim&oacute;rficos</em>,  ya que un mismo operador se puede emplear para acceder a distintos  tipos de datos. Por ejemplo, un operador <em>add</em> utilizado para  a&ntilde;adir un elemento, podr&aacute; ser empleado tanto si estamos  trabajando con una lista enlazada, con un array, o con un conjunto por  ejemplo. </p>
<p>Este <em>polimorfismo</em> se debe a la definici&oacute;n de  interfaces que deben implementar los distintos tipos de datos. Siempre  que el tipo de datos contenga una colecci&oacute;n de elementos,  implementar&aacute; la interfaz <strong>Collection</strong>. Esta interfaz  proporciona m&eacute;todos para acceder a la colecci&oacute;n de  elementos, que podremos utilizar para cualquier tipo de datos que sea  una colecci&oacute;n de elementos, independientemente de su  implementaci&oacute;n concreta.</p>
<p>Podemos encontrar los siguientes elementos dentro del marco de  colecciones de Java:</p>
<ul>
  <li>Interfaces para distintos tipos de datos: Definir&aacute;n las  operaciones que se pueden realizar con dichos tipos de datos. Podemos  encontrar aqu&iacute; la interfaz para cualquier colecci&oacute;n de  datos, y de manera m&aacute;s concreta para listas (secuencias) de  datos, conjuntos, etc.</li>
  <li>Implementaciones de tipos de datos reutilizables: Son clases que  implementan tipos de datos concretos que podremos utilizar para  nuestras aplicaciones, implementando algunas de las interfaces  anteriores para acceder a los elementos de dicho tipo de datos. Por  ejemplo, dentro de las listas de elementos, podremos encontrar  distintas implementaciones de la lista como puede ser listas enlazadas,  o bien arrays de capacidad variable, pero al implementar la misma  interfaz podremos acceder a sus elementos mediante las mismas  operaciones (polimorfismo).</li>
  <li>Algoritmos para trabajar con dichos tipos de datos, que nos  permitan realizar una ordenaci&oacute;n de los elementos de una lista,  o diversos tipos de b&uacute;squeda de un determinado elemento por  ejemplo.</li>
</ul>
<h2>2.1 Enumeraciones e iteradores</h2>
<p>Antes de ver los tipos de datos vamos a ver dos elementos utilizados  comunmente en Java para acceder a colecciones de datos. </p>
<p>Las enumeraciones, definidas mediante la interfaz <strong>Enumeration</strong>,  nos permiten consultar los elementos que contiene una colecci&oacute;n  de datos. Muchos m&eacute;todos de clases Java que deben devolver  m&uacute;ltiples valores, lo que hacen es devolvernos una  enumeraci&oacute;n que podremos consultar mediante los m&eacute;todos  que ofrece dicha interfaz.</p>
<p>La enumeraci&oacute;n ir&aacute; recorriendo secuencialmente los  elementos de la colecci&oacute;n. Para leer cada elemento de la  enumeraci&oacute;n deberemos llamar al m&eacute;todo:</p>
<pre class="codigo">Object item = enum.<strong>nextElement()</strong>;</pre>
<p>Que nos proporcionar&aacute; en cada momento el siguiente elemento  de la enumeraci&oacute;n a leer. Adem&aacute;s necesitaremos saber si  quedan elementos por leer, para ello tenemos el m&eacute;todo:</p>
<pre class="codigo">enum.<strong>hasMoreElements()</strong></pre>
<p>Normalmente, el bucle para la lectura de una enumeraci&oacute;n  ser&aacute; el siguiente:</p>
<pre class="codigo">while (enum.<strong>hasMoreElements()</strong>) 
{
	Object item = enum.<strong>nextElement()</strong>;  
	// Hacer algo con el item leido
}</pre>
<p>Vemos como en este bucle se van leyendo y procesando elementos de la  enumeraci&oacute;n uno a uno mientras queden elementos por leer en ella.</p>
<p>Otro elemento para acceder a los datos de una colecci&oacute;n son  los iteradores. La diferencia est&aacute; en que los iteradores  adem&aacute;s de leer los datos nos permitir&aacute;n eliminarlos de la  colecci&oacute;n. Los iteradores se definen mediante la interfaz<strong> Iterator</strong>, que proporciona de forma an&aacute;loga a la  enumeraci&oacute;n el m&eacute;todo:</p>
<pre class="codigo">Object item = iter.<strong>next()</strong>;</pre>
<p>Que nos devuelve el siguiente elemento a leer por el iterador, y  para saber si quedan m&aacute;s elementos que leer tenemos el  m&eacute;todo:</p>
<pre class="codigo">iter.<strong>hasNext()</strong></pre>
<p>Adem&aacute;s, podemos borrar el &uacute;ltimo elemento que hayamos  leido. Para ello tendremos el m&eacute;todo:</p>
<pre class="codigo">iter.<strong>remove()</strong>;</pre>
<p>Por ejemplo, podemos recorrer todos los elementos de una  colecci&oacute;n utilizando un iterador y eliminar aquellos que cumplan  ciertas condiciones:</p>
<pre class="codigo">while (iter.<strong>hasNext()</strong>) 
{ 
	Object item = iter.<strong>next()</strong>;
	if(condicion_borrado(item))
		iter.<strong>remove()</strong>;
}</pre>
<p>Las enumeraciones y los iteradores no son tipos de datos, sino  elementos que nos servir&aacute;n para acceder a los elementos dentro  de los tipos de datos que veremos a continuaci&oacute;n.</p>
<h2>2.2 Colecciones</h2>
<p>Las colecciones representan grupos de objetos, denominados  elementos. Podemos encontrar diversos tipos de colecciones,  seg&uacute;n si sus elementos est&aacute;n ordenados, o si permitimos  repetici&oacute;n de elementos o no.</p>
<p>Es el tipo m&aacute;s gen&eacute;rico en cuanto a que se refiere a  cualquier tipo que contenga un grupo de elementos. Viene definido por  la interfaz <strong>Collection</strong>, de la cual heredar&aacute;  cada subtipo espec&iacute;fico. En esta interfaz encontramos una serie  de m&eacute;todos que nos servir&aacute;n para acceder a los elementos  de cualquier colecci&oacute;n de datos, sea del tipo que sea. Estos  m&eacute;todos generales son:</p>
<pre class="codigo">boolean <strong>add(Object o)</strong></pre>
<p>A&ntilde;ade un elemento (objeto) a la colecci&oacute;n. Nos devuelve<em> true</em> si tras a&ntilde;adir el elemento la colecci&oacute;n ha  cambiado, es decir, el elemento se ha a&ntilde;adido correctamente, o <em>false</em> en caso contrario.</p>
<pre class="codigo">void <strong>clear()</strong></pre>
<p>Elimina todos los elementos de la colecci&oacute;n.</p>
<pre class="codigo">boolean <strong>contains(Object o)</strong></pre>
<p>Indica si la colecci&oacute;n contiene el elemento (objeto) indicado.</p>
<pre class="codigo">boolean <strong>isEmpty()</strong></pre>
<p>Indica si la colecci&oacute;n est&aacute; vac&iacute;a (no tiene  ning&uacute;n elemento). </p>
<pre class="codigo">Iterator <strong>iterator()</strong></pre>
<p>Proporciona un iterador para acceder a los elementos de la  colecci&oacute;n.</p>
<pre class="codigo">boolean <strong>remove(Object o)</strong></pre>
<p>Elimina un determinado elemento (objeto) de la colecci&oacute;n,  devolviendo <em>true</em> si dicho elemento estaba contenido en la  colecci&oacute;n, y <em>false</em> en caso contrario.</p>
<pre class="codigo">int <strong>size()</strong></pre>
<p>Nos devuelve el n&uacute;mero de elementos que contiene la  colecci&oacute;n.</p>
<pre class="codigo">Object [] <strong>toArray()</strong></pre>
<p>Nos devuelve la colecci&oacute;n de elementos como un array de  objetos. Si sabemos de antemano que los objetos de la colecci&oacute;n  son todos de un determinado tipo (como por ejemplo de tipo <strong>String</strong>)  podremos obtenerlos en un array del tipo adecuado, en lugar de usar un  array de objetos gen&eacute;ricos. En este caso NO podremos hacer una  conversi&oacute;n cast descendente de array de objetos a array de un  tipo m&aacute;s concreto, ya que el array se habr&aacute; instanciado  simplemente como array de objetos:</p>
<pre class="codigo">// <strong>Esto no se puede hacer!!!</strong>
String [] cadenas = (String []) coleccion.toArray();</pre>
<p>Lo que si podemos hacer es instanciar nosotros un array del tipo  adecuado y hacer una conversi&oacute;n cast ascendente (de tipo  concreto a array de objetos), y utilizar el siguiente m&eacute;todo:</p>
<pre class="codigo">String [] cadenas = new String[coleccion.size()];
coleccion.<strong>toArray</strong>(cadenas);		// Esto si que funcionar&aacute;</pre>
<p>Esta interfaz es muy gen&eacute;rica, y por lo tanto no hay  ning&uacute;n tipo de datos que la implemente directamente, sino que  implementar&aacute;n subtipos de ellas. A continuaci&oacute;n veremos  los subtipos m&aacute;s comunes.</p>
<h3>2.2.1 Listas de elementos</h3>
<p>Este tipo de colecci&oacute;n se refiere a listas en las que los  elementos de la colecci&oacute;n tienen un orden, existe una secuencia  de elementos. En ellas cada elemento estar&aacute; en una determinada  posici&oacute;n (&iacute;ndice) de la lista.</p>
<p>Las listas vienen definidas en la interfaz <strong>List</strong>,  que adem&aacute;s de los m&eacute;todos generales de las colecciones,  nos ofrece los siguientes para trabajar con los &iacute;ndices:</p>
<pre class="codigo">void <strong>add(int indice, Object obj)</strong></pre>
<p>Inserta un elemento (objeto) en la posici&oacute;n de la lista dada  por el &iacute;ndice indicado. </p>
<pre class="codigo">Object <strong>get(int indice)</strong></pre>
<p>Obtiene el elemento (objeto) de la posici&oacute;n de la lista dada  por el &iacute;ndice indicado. </p>
<pre class="codigo">int <strong>indexOf(Object obj)</strong></pre>
<p>Nos dice cual es el &iacute;ndice de dicho elemento (objeto) dentro  de la lista. Nos devuelve -1 si el objeto no se encuentra en la lista.</p>
<pre class="codigo">Object <strong>remove(int indice)</strong></pre>
<p>Elimina el elemento que se encuentre en la posici&oacute;n de la  lista indicada mediante dicho &iacute;ndice, devolvi&eacute;ndonos el  objeto eliminado.</p>
<pre class="codigo">Object <strong>set(int indice, Object obj)</strong></pre>
<p>Establece el elemento de la lista en la posici&oacute;n dada por el  &iacute;ndice al objeto indicado, sobrescribiendo el objeto que hubiera  anteriormente en dicha posici&oacute;n. Nos devolver&aacute; el  elemento que hab&iacute;a previamente en dicha posici&oacute;n.</p>
<p>Podemos encontrar diferentes implementaciones de listas de elementos  en Java:</p>
<p><strong>ArrayList</strong></p>
<p>Implementa una lista de elementos mediante un array de tama&ntilde;o  variable. Conforme se a&ntilde;aden elementos el tama&ntilde;o del  array ir&aacute; creciendo si es necesario. El array tendr&aacute; una  capacidad inicial, y en el momento en el que se rebase dicha capacidad,  se aumentar&aacute; el tama&ntilde;o del array.</p>
<p>Las operaciones de a&ntilde;adir un elemento al final del array (<em>add</em>),  y de establecer u obtener el elemento en una determinada  posici&oacute;n (<em>get</em>/<em>set</em>) tienen un coste temporal  constante. Las inserciones y borrados tienen un coste lineal <em>O(n)</em>,  donde <em>n</em> es el n&uacute;mero de elementos del array.</p>
<p>Hemos de destacar que la implementaci&oacute;n de <strong>ArrayList</strong> no est&aacute; sincronizada, es decir, si m&uacute;ltiples hilos  acceden a un mismo <strong>ArrayList</strong> concurrentemente  podriamos tener problemas en la consistencia de los datos. Por lo  tanto, deberemos tener en cuenta cuando usemos este tipo de datos que  debemos controlar la concurrencia de acceso. </p>
<p><strong>Vector</strong></p>
<p>El <strong>Vector</strong> es una implementaci&oacute;n similar al <strong>ArrayList</strong>,  con la diferencia de que el <strong>Vector</strong> s&iacute; que <strong>est&aacute;  sincronizado</strong>. Este es un caso especial, ya que la  implementaci&oacute;n b&aacute;sica del resto de tipos de datos no  est&aacute; sincronizada.</p>
<p>Esta clase existe desde las primeras versiones de Java, en las que  no exist&iacute;a el marco de las colecciones descrito anteriormente.  En las &uacute;ltimas versiones el <strong>Vector</strong> se ha  acomodado a este marco implementando la interfaz <strong>List</strong>.</p>
<p>Sin embargo, si trabajamos con versiones previas de JDK, hemos de  tener en cuenta que dicha interfaz no exist&iacute;a, y por lo tanto  esta versi&oacute;n previa del vector no contar&aacute; con los  m&eacute;todos definidos en ella. Los m&eacute;todos propios del vector  para acceder a su contenido, que han existido desde las primeras  versiones, son los siguientes:</p>
<pre class="codigo">void <strong>addElement(Object obj)</strong></pre>
<p>A&ntilde;ade un elemento al final del vector.</p>
<pre class="codigo">Object <strong>elementAt(int indice)</strong></pre>
<p>Devuelve el elemento de la posici&oacute;n del vector indicada por  el &iacute;ndice.</p>
<pre class="codigo">void <strong>insertElementAt(Object obj, int indice)</strong></pre>
<p>Inserta un elemento en la posici&oacute;n indicada.</p>
<pre class="codigo">boolean <strong>removeElement(Object obj)</strong></pre>
<p>Elimina el elemento indicado del vector, devolviendo <em>true</em> si dicho elemento estaba contenido en el vector, y <em>false</em> en  caso contrario.</p>
<pre class="codigo">void <strong>removeElementAt(int indice)</strong></pre>
<p>Elimina el elemento de la posici&oacute;n indicada en el  &iacute;ndice.</p>
<pre class="codigo">void <strong>setElementAt(Object obj, int indice)</strong></pre>
<p>Sobrescribe el elemento de la posici&oacute;n indicada con el objeto  especificado.</p>
<pre class="codigo">int <strong>size()</strong></pre>
<p>Devuelve el n&uacute;mero de elementos del vector.</p>
<p>Por lo tanto, si programamos para versiones antiguas de la  m&aacute;quina virtual Java, ser&aacute; recomendable utilizar estos  m&eacute;todos para asegurarnos de que nuestro programa funcione. Esto  ser&aacute; importante en la programaci&oacute;n de Applets, ya que la  m&aacute;quina virtual incluida en muchos navegadores corresponde a  versiones antiguas.</p>
<p>Sobre el vector se construye el tipo pila (<strong>Stack</strong>),  que apoy&aacute;ndose en el tipo vector ofrece m&eacute;todos para  trabajar con dicho vector como si se tratase de una pila, apilando y  desapilando elementos (operaciones <em>push </em>y<em> pop</em> respectivamente). La clase <strong>Stack</strong> hereda de <strong>Vector</strong>,  por lo que en realidad ser&aacute; un vector que ofrece m&eacute;todos  adicionales para trabajar con &eacute;l como si fuese una pila.</p>
<p><strong>LinkedList</strong></p>
<p>En este caso se implementa la lista mediante una lista doblemente  enlazada. Por lo tanto, el coste temporal de las operaciones  ser&aacute; el de este tipo de listas. Cuando realicemos inserciones,  borrados o lecturas en los extremos inicial o final de la lista el  tiempo ser&aacute; constante, mientras que para cualquier  operaci&oacute;n en la que necesitemos localizar un determinado  &iacute;ndice dentro de la lista deberemos recorrer la lista de inicio  a fin, por lo que el coste ser&aacute; lineal con el tama&ntilde;o de  la lista <em>O(n)</em>, siendo <em>n </em>el tama&ntilde;o de la  lista.</p>
<p>Para aprovechar las ventajas que tenemos en el coste temporal al  trabajar con los extremos de la lista, se proporcionan m&eacute;todos  propios para acceder a ellos en tiempo constante:</p>
<pre class="codigo">void <strong>addFirst(Object obj)</strong> / void <strong>addLast(Object obj)</strong></pre>
<p>A&ntilde;ade el objeto indicado al principio / final de la lista  respectivamente.</p>
<pre class="codigo">Object <strong>getFirst()</strong> / Object <strong>getLast()</strong></pre>
<p>Obtiene el primer / &uacute;ltimo objeto de la lista respectivamente.</p>
<pre class="codigo">Object <strong>removeFirst()</strong> / Object <strong>removeLast()</strong></pre>
<p>Extrae el primer / &uacute;ltimo elemento de la lista  respectivamente, devolvi&eacute;ndonos dicho objeto y  elimin&aacute;ndolo de la lista.</p>
<p>Hemos de destacar que estos m&eacute;todos nos permitir&aacute;n  trabajar con la lista como si se tratase de una pila o de una cola. En  el caso de la pila realizaremos la inserci&oacute;n y la  extracci&oacute;n de elementos por el mismo extremo, mientras que para  la cola insertaremos por un extremo y extraeremos por el otro.</p>
<h3>2.2.2 Conjuntos</h3>
<p>Los conjuntos son grupos de elementos en los que no encontramos  ning&uacute;n elemento repetido. Consideramos que un elemento  est&aacute; repetido si tenemos dos objetos <em>o1</em> y <em>o2</em> iguales, comparandolos mediante el operador <em>o1.equals(o2)</em>. De  esta forma, si el objeto a insertar en el conjunto estuviese repetido,  no nos dejar&aacute; insertarlo. Recordemos que el m&eacute;todo add  devolv&iacute;a un valor <em>booleano</em>, que servir&aacute; para  este caso, devolviendonos <em>true</em> si el elemento a a&ntilde;adir  no estaba en el conjunto y ha sido a&ntilde;adido, o <em>false</em> si  el elemento ya se encontraba dentro del conjunto. Un conjunto  podr&aacute; contener a lo sumo un elemento <em>null</em>.</p>
<p>Los conjuntos se definen en la interfaz <strong>Set</strong>, a  partir de la cual se construyen diferentes implementaciones:</p>
<p><strong>HashSet</strong> </p>
<p>Los objetos se almacenan en una tabla de dispersi&oacute;n (<em>hash</em>).  El coste de las operaciones b&aacute;sicas (inserci&oacute;n, borrado,  b&uacute;squeda) se realizan en tiempo constante siempre que los  elementos se hayan dispersado de forma adecuada. La iteraci&oacute;n a  trav&eacute;s de sus elementos es m&aacute;s costosa, ya que  necesitar&aacute; recorrer todas las entradas de la tabla de  dispersi&oacute;n, lo que har&aacute; que el coste est&eacute; en  funci&oacute;n tanto del n&uacute;mero de elementos insertados en el  conjunto como del n&uacute;mero de entradas de la tabla. El orden de  iteraci&oacute;n puede diferir del orden en el que se insertaron los  elementos.</p>
<p><strong>LinkedHashSet</strong> </p>
<p>Es similar a la anterior pero la tabla de dispersi&oacute;n es  doblemente enlazada. Los elementos que se inserten tendr&aacute;n  enlaces entre ellos. Por lo tanto, las operaciones b&aacute;sicas  seguir&aacute;n teniendo coste constante, con la carga adicional que  supone tener que gestionar los enlaces. Sin embargo habr&aacute; una  mejora en la iteraci&oacute;n, ya que al establecerse enlaces entre los  elementos no tendremos que recorrer todas las entradas de la tabla, el  coste s&oacute;lo estar&aacute; en funci&oacute;n del n&uacute;mero de  elementos insertados. En este caso, al haber enlaces entre los  elementos, estos enlaces definir&aacute;n el orden en el que se  insertaron en el conjunto, por lo que el orden de iteraci&oacute;n  ser&aacute; el mismo orden en el que se insertaron.</p>
<p><strong>TreeSet</strong> </p>
<p>Utiliza un &aacute;rbol para el almacenamiento de los elementos. Por  lo tanto, el coste para realizar las operaciones b&aacute;sicas  ser&aacute; logar&iacute;tmico con el n&uacute;mero de elementos que  tenga el conjunto <em>O(log n)</em>.</p>
<h3>2.2.3 Mapas</h3>
<p>Aunque muchas veces se hable de los mapas como una colecci&oacute;n,  en realidad no lo son, ya que no heredan de la interfaz <strong>Collection</strong>.</p>
<p>Los mapas se definen en la interfaz <strong>Map</strong>. Un mapa  es un objeto que relaciona una clave (<em>key</em>) con un valor.  Contendr&aacute; un conjunto de claves, y a cada clave se le  asociar&aacute; un determinado valor. En versiones anteriores este  mapeado entre claves y valores lo hac&iacute;a la clase <strong>Dictionary</strong>,  que ha quedado obsoleta. Tanto la clave como el valor puede ser  cualquier objeto.</p>
<p>Los m&eacute;todos b&aacute;sicos para trabajar con estos elementos  son los siguientes:</p>
<pre class="codigo">Object <strong>get(Object clave)</strong></pre>
<p>Nos devuelve el valor asociado a la clave indicada</p>
<pre class="codigo">Object <strong>put(Object clave, Object valor)</strong></pre>
<p>Inserta una nueva clave con el valor especificado. Nos devuelve el  valor que ten&iacute;a antes dicha clave, o <em>null</em> si la clave  no estaba en la tabla todav&iacute;a.</p>
<pre class="codigo">Object <strong>remove(Object clave)</strong></pre>
<p>Elimina una clave, devolviendonos el valor que ten&iacute;a dicha  clave.</p>
<pre class="codigo">Set <strong>keySet()</strong></pre>
<p>Nos devuelve el conjunto de claves registradas</p>
<pre class="codigo">int <strong>size()</strong></pre>
<p>Nos devuelve el n&uacute;mero de parejas (clave,valor) registradas.</p>
<p>Encontramos distintas implementaciones de los mapas:</p>
<p><strong>HashMap</strong></p>
<p>Utiliza una tabla de dispersi&oacute;n para almacenar la  informaci&oacute;n del mapa. Las operaciones b&aacute;sicas (<em>get</em> y <em>put</em>) se har&aacute;n en tiempo constante siempre que se  dispersen adecuadamente los elementos. Es coste de la iteraci&oacute;n  depender&aacute; del n&uacute;mero de entradas de la tabla y del  n&uacute;mero de elementos del mapa. No se garantiza que se respete el  orden de las claves.</p>
<p><strong>TreeMap</strong></p>
<p>Utiliza un &aacute;rbol rojo-negro para implementar el mapa. El  coste de las operaciones b&aacute;sicas ser&aacute; logar&iacute;tmico  con el n&uacute;mero de elementos del mapa <em>O(log n)</em>. En este  caso los elementos se encontrar&aacute;n ordenados por orden ascendente  de clave.</p>
<p><strong>Hashtable</strong></p>
<p>Es una implementaci&oacute;n similar a <strong>HashMap</strong>,  pero con alguna diferencia. Mientras las anteriores implementaciones no  est&aacute;n sincronizadas, esta si que lo est&aacute;. Adem&aacute;s  en esta implementaci&oacute;n, al contrario que las anteriores, no se  permitir&aacute;n claves nulas (<em>null</em>). Este objeto extiende la  obsoleta clase <strong>Dictionary</strong>, ya que viene de versiones  m&aacute;s antiguas de JDK. Ofrece otros m&eacute;todos adem&aacute;s  de los anteriores, como por ejemplo el siguiente:</p>
<pre class="codigo">Enumeration <strong>keys()</strong></pre>
<p>Este m&eacute;todo nos devolver&aacute; una enumeraci&oacute;n de  todas las claves registradas en la tabla.</p>
<h3>2.2.4 Algoritmos</h3>
<p>Como hemos comentado anteriormente, adem&aacute;s de las interfaces  y las implementaciones de los tipos de datos descritos en los apartados  previos, el marco de colecciones nos ofrece una serie de algoritmos  utiles cuando trabajamos con estos tipos de datos, especialmente para  las listas.</p>
<p>Estos algoritmos los podemos encontrar implementados como  m&eacute;todos est&aacute;ticos en la clase <strong>Collections</strong>.  En ella encontramos m&eacute;todos para la ordenaci&oacute;n de listas (<em>sort</em>),  para la b&uacute;squeda binaria de elementos dentro de una lista (<em>binarySearch</em>)  y otras operaciones que nos ser&aacute;n de gran utilidad cuando  trabajemos con colecciones de elementos.</p>
<h2>2.3 Wrappers de tipos b&aacute;sicos</h2>
<p>Hemos visto que en Java cualquier tipo de datos es un objeto,  excepto los tipos de datos b&aacute;sicos: <em>boolean, int, long,  float, double, byte, short, char</em>. </p>
<p>Cuando trabajamos con colecciones de datos los elementos que  contienen &eacute;stas son siempre objetos, por lo que en un principio  no podr&iacute;amos insertar elementos de estos tipos b&aacute;sicos.  Para hacer esto posible tenemos una serie de objetos que se  encargar&aacute;n de envolver a estos tipos b&aacute;sicos,  permiti&eacute;ndonos tratarlos como objetos y por lo tanto insertarlos  como elementos de colecciones. Estos objetos son los llamados wrappers,  y las clases en las que se definen tienen nombre similares al del tipo  b&aacute;sico que encapsulan, con la diferencia de que comienzan con  may&uacute;scula: <strong>Boolean, Integer, Long, Float, Double, Byte,  Short, Character</strong>.</p>
<p>Estas clases, adem&aacute;s de servirnos para encapsular estos datos  b&aacute;sicos en forma de objetos, nos proporcionan una serie de  m&eacute;todos e informaci&oacute;n &uacute;tiles para trabajar con  estos datos. Nos proporcionar&aacute;n m&eacute;todos por ejemplo para  convertir cadenas a datos num&eacute;ricos de distintos tipos y  viceversa, as&iacute; como informaci&oacute;n acerca del valor  m&iacute;nimo y m&aacute;ximo que se puede representar con cada tipo  num&eacute;rico.</p>
<p>Por ejemplo, si quisi&eacute;ramos a&ntilde;adir un entero a una lista (<em>ArrayList</em>, por ejemplo), lo har&iacute;amos con algo como:</p>
<pre class="codigo">int a;
ArrayList al = new ArrayList();
al.add(new Integer(a));</pre>
<p>Y luego lo recuperaríamos (por ejemplo, de la posición 3 de la lista), con:</p>
<pre class="codigo">Integer entero = (Integer)(al.get(3));
int valor = entero.intValue();</pre>
<h2>2.4 Clases &uacute;tiles</h2>
<p>En esta secci&oacute;n vamos a ver una serie de clases que conviene  conocer ya que nos ser&aacute;n de gran utilidad para realizar nuestros  programas:</p>
<p><strong>Object</strong></p>
<p>Esta es la clase base de todas las clases en Java, toda clase hereda  en &uacute;ltima instancia de la clase <strong>Object</strong>, por lo  que los m&eacute;todos que ofrece estar&aacute;n disponibles en  cualquier objeto Java, sea de la clase que sea.</p>
<p>En Java es importante distinguir claramente entre lo que es una  variable, y lo que es un objeto. Las variables simplemente son  referencias a objetos, mientras que los objetos son las entidades  instanciadas en memoria que podr&aacute;n ser manipulados mediante las  referencias que tenemos a ellos (mediante variable que apunten a ellos)  dentro de nuestro programa. Cuando hacemos lo siguiente:</p>
<pre class="codigo">new MiClase()</pre>
<p>Se est&aacute; instanciando en memoria un nuevo objeto de clase  MiClase y nos devuelve una referencia a dicho objeto. Nosotros  deberemos guardarnos dicha referencia en alguna variable con el fin de  poder acceder al objeto creado desde nuestro programa:</p>
<pre class="codigo">MiClase mc = new MiClase();</pre>
<p>Es importante declarar la referencia del tipo adecuado (en este caso  tipo MiClase) para manipular el objeto, ya que el tipo de la referencia  ser&aacute; el que indicar&aacute; al compilador las operaciones que  podremos realizar con dicho objeto. El tipo de esta referencia  podr&aacute; ser tanto el mismo tipo del objeto al que vayamos a  apuntar, o bien el de cualquier clase de la que herede o interfaz que  implemente nuestro objeto. Por ejemplo, si MiClase se define de la  siguiente forma:</p>
<pre class="codigo">public class MiClase extends Thread implements List 
{
	...
}</pre>
<p>Podremos hacer referencia a ella de diferentes formas:</p>
<pre class="codigo">MiClase mc = new MiClase();
Thread t = new MiClase();
List l = new MiClase();
Object o = new MiClase();</pre>
<p>Esto es as&iacute; ya que al heredar tanto de <strong>Thread</strong> como de <strong>Object</strong>, sabemos que el objeto tendr&aacute;  todo lo que tienen estas clases m&aacute;s lo que a&ntilde;ada <strong>MiClase</strong>,  por lo que podr&aacute; comportarse como cualquiera de las clases  anteriores. Lo mismo ocurre al implementar una interfaz, al forzar a  que se implementen sus m&eacute;todos podremos hacer referencia al  objeto mediante la interfaz ya que sabemos que va a contener todos esos  m&eacute;todos. Siempre vamos a poder hacer esta asignaci&oacute;n  'ascendente' a clases o interfaces de las que deriva nuestro objeto.</p>
<p>Si hacemos referencia a un objeto <strong>MiClase</strong> mediante  una referencia <strong>Object</strong> por ejemplo, s&oacute;lo  podremos acceder a los m&eacute;todos de <strong>Object</strong>,  aunque el objeto contenga m&eacute;todos adicionales definidos en <strong>MiClase</strong>.  Si conocemos que nuestro objeto es de tipo <strong>MiClase</strong>, y  queremos poder utilizarlo como tal, podremos hacer una  asignaci&oacute;n 'descendente' aplicando una conversi&oacute;n cast al  tipo concreto de objeto:</p>
<pre class="codigo">Object o = new MiClase();
...
MiClase mc = (MiClase) o;</pre>
<p>Si resultase que nuestro objeto no es de la clase a la que hacemos  cast, ni hereda de ella ni la implementa, esta llamada resultar&aacute;  en un <strong>ClassCastException</strong> indicando que no podemos  hacer referencia a dicho objeto mediante esa interfaz debido a que el  objeto no la cumple, y por lo tanto podr&aacute;n no estar disponibles  los m&eacute;todos que se definen en ella.</p>
<p>Una vez hemos visto la diferencia entre las variables (referencias)  y objetos (entidades) vamos a ver como se har&aacute; la  asignaci&oacute;n y comparaci&oacute;n de objetos. Si hiciesemos lo  siguiente:</p>
<pre class="codigo">MiClase mc1 = new MiClase();
MiClase mc2 = mc1;</pre>
<p>Puesto que hemos dicho que las variables simplemente son referencias  a objetos, la asignaci&oacute;n estar&aacute; copiando una referencia,  no el objeto. Es decir, tanto la variable <em>mc1 </em>como <em>mc2 </em>apuntar&aacute;n  a un mismo objeto.</p>
<p>Si lo que queremos es copiar un objeto, teniendo dos entidades  independientes, deberemos invocar el m&eacute;todo <strong>clone</strong> del objeto a copiar:</p>
<pre class="codigo">MiClase mc2 = <strong>(MiClase)</strong>mc1.<strong>clone()</strong>;</pre>
<p>El m&eacute;todo <strong>clone</strong> es un m&eacute;todo de la  clase <strong>Object </strong>que estar&aacute; disponible para  cualquier objeto Java, y nos devuelve un <strong>Object</strong> gen&eacute;rico, ya que al ser un m&eacute;todo que puede servir para  cualquier objeto nos debe devolver la copia de este tipo. De &eacute;l  tendremos que hacer una conversi&oacute;n cast a la clase de la que se  trate como hemos visto en el ejemplo. </p>
<p>Por otro lado, para la comparaci&oacute;n, si hacemos lo siguiente:</p>
<pre class="codigo">mc1 == mc2</pre>
<p>Estaremos comparando referencias, por lo que estaremos viendo si las  dos referencias apuntan a un mismo objeto, y no si los objetos a los  que apuntan son iguales. Para ver si los objetos son iguales, aunque  sean entidades distintas, tenemos:</p>
<pre class="codigo">mc1.<strong>equals</strong>(mc2)</pre>
<p>Este m&eacute;todo tambi&eacute;n es propio de la clase <strong>Object</strong>,  y ser&aacute; el que se utilice para comparar internamente los objetos.</p>
<p>Tanto <strong>clone</strong> como <strong>equals</strong>,  deber&aacute;n ser redefinidos en nuestras clases para adaptarse a  &eacute;stas. Deberemos especificar dentro de ellos como se copia  nuestro objeto y como se compara si son iguales:</p>
<pre class="codigo">public class Punto2D 
{
	public int x, y;	
	...
	public boolean <strong>equals</strong>(Object o) 
	{
		Punto2D p = (Punto2D)o;
		// Compara objeto this con objeto p
		return (x == p.x &amp;&amp; y == p.y);
	}
	
	public Object <strong>clone</strong>() 
	{
		Punto2D p = new Punto2D();
		// Construye nuevo objeto p 
		// copiando los atributos de this
		p.x = x;
		p.y = y;
		return p;
	}
}</pre>
<p>Un &uacute;ltimo m&eacute;todo interesante de la clase <strong>Object</strong> es <strong>toString</strong>. Este m&eacute;todo nos devuelve una cadena (<strong>String</strong>)  que representa dicho objeto. Por defecto nos dar&aacute; un  identificador del objeto, pero nosotros podemos sobrescribirla en  nuestras propias clases para que genere la cadena que queramos. De esta  manera podremos imprimir el objeto en forma de cadena de texto,  mostrandose los datos con el formato que nosotros les hayamos dado en<strong> toString</strong>. Por ejemplo, si tenemos una clase <strong>Punto2D</strong>,  ser&iacute;a buena idea hacer que su conversi&oacute;n a cadena muestre  las coordenadas <em>(x,y)</em> del punto:</p>
<pre class="codigo">public class Punto2D 
{
	public int x,y;
	...
	public String <strong>toString</strong>() 
	{
		String s = "(" + x + "," + y + ")";
		return s;
	}
}</pre>
<p><strong>Properties</strong></p>
<p>Esta clase es un subtipo de <strong>Hastable</strong>, que se  encarga de almacenar una serie de propiedades asociando un valor a cada  una de ellas. Estas propiedades las podremos utilizar para registrar la  configuraci&oacute;n de nuestra aplicaci&oacute;n. Adem&aacute;s esta  clase nos permite cargar o almacenar esta informaci&oacute;n en  alg&uacute;n dispositivo, como puede ser en disco, de forma que sea  persistente.</p>
<p>Puesto que hereda de <strong>Hashtable</strong>, podremos utilizar  sus m&eacute;todos, pero tambi&eacute;n aporta m&eacute;todos propios  para a&ntilde;adir propiedades:</p>
<pre class="codigo">Object <strong>setProperty(Object clave, Object valor)</strong></pre>
<p>Equivalente al m&eacute;todo <em>put</em>.</p>
<pre class="codigo">Object <strong>getProperty(Object clave)</strong></pre>
<p>Equivalente al m&eacute;todo <em>get</em>.</p>
<pre class="codigo">Object <strong>getProperty(Object clave, Object default)</strong></pre>
<p>Esta variante del m&eacute;todo resulta &uacute;til cuando queremos  que determinada propiedad devuelva alg&uacute;n valor por defecto si  todav&iacute;a no se le ha asignado ning&uacute;n valor.</p>
<p>Adem&aacute;s, como hemos dicho anteriormente, para hacer  persistentes estas propiedades de nuestra aplicaci&oacute;n, se  proporcionan m&eacute;todos para almacenarlas o leerlas de alg&uacute;n  dispositivo de E/S:</p>
<pre class="codigo">void <strong>load(InputStream entrada)</strong></pre>
<p>Lee las propiedades del flujo de entrada proporcionado. Este flujo  puede por ejemplo referirse a un fichero del que se leer&aacute;n los  datos.</p>
<pre class="codigo">void <strong>store(OutputStream salida, String cabecera)</strong></pre>
<p>Almacena las informaci&oacute;n de las propiedades escribiendolas en  el flujo de salida especificado. Este flujo puede por ejemplo referirse  a un fichero en disco, en el que se guardar&aacute; nuestro conjunto de  propiedades, pudiendo especificar una cadena que se pondr&aacute; como  cabecera en el fichero, y que nos permite a&ntilde;adir alg&uacute;n  comentario sobre dicho fichero.</p>
<p><strong>System</strong></p>
<p>Esta clase nos ofrece una serie de m&eacute;todos y campos  &uacute;tiles del sistema. Esta clase no se debe instanciar, todos  estos m&eacute;todos y campos son est&aacute;ticos.</p>
<p>Podemos encontrar los objetos que encapsulan la entrada, salida y  salida de error est&aacute;ndar, as&iacute; como m&eacute;todos para  redireccionarlas, que veremos con m&aacute;s detalle en el tema de  entrada/salida.</p>
<p>Tambi&eacute;n nos permite acceder al gestor de seguridad instalado,  como veremos en el tema sobre seguridad.</p>
<p>Otros m&eacute;todos &uacute;tiles que encontramos son:</p>
<pre class="codigo">void <strong>exit(int estado)</strong></pre>
<p>Finaliza la ejecuci&oacute;n de la aplicaci&oacute;n, devolviendo un  c&oacute;digo de estado. Normalmente el c&oacute;digo 0 significa que  ha salido de forma normal, mientras que con otros c&oacute;digos  indicaremos que se ha producido alg&uacute;n error. </p>
<pre class="codigo">void <strong>gc()</strong></pre>
<p>Fuerza una llamada al colector de basura para limpiar la memoria.  Esta es una operaci&oacute;n costosa. Normalmente no lo llamaremos  explicitamente, sino que dejaremos que Java lo invoque cuando sea  necesario.</p>
<pre class="codigo">long <strong>currentTimeMillis()</strong></pre>
<p>Nos devuelve el tiempo medido en el n&uacute;mero de milisegundos  transcurridos desde el 1 de Enero de 1970 a las 0:00.</p>
<pre class="codigo">void <strong>arraycopy(Object fuente, int pos_fuente, <br>				Object destino, int pos_dest, int n)</strong></pre>
<p>Copia n elementos del array fuente, desde la posici&oacute;n pos_fuente, al     array destino a partir de la posici&oacute;n pos_dest.</p>
<p><strong>Runtime</strong></p>
<p>Toda aplicaci&oacute;n Java tiene una instancia de la clase <strong>Runtime</strong> que se encargar&aacute; de hacer de interfaz con el entorno en el que  se est&aacute; ejecutando. Para obtener este objeto debemos utilizar el  siguiente m&eacute;todo est&aacute;tico:</p>
<pre class="codigo">Runtime rt = <strong>Runtime.getRuntime()</strong>;</pre>
<p>Una de las operaciones que podremos realizar con este objeto,  ser&aacute; ejecutar comandos como si nos encontr&aacute;semos en la  l&iacute;nea de comandos del sistema operativo. Para ello utilizaremos  el siguiente m&eacute;todo:</p>
<pre class="codigo">rt.<strong>exec</strong>(comando);</pre>
<p>De esta forma podremos invocar programas externos desde nuestra  aplicaci&oacute;n Java. </p>
<p><strong>Math</strong></p>
<p>La clase<strong> Math</strong> nos ser&aacute; de gran utilidad  cuando necesitemos realizar operaciones matem&aacute;ticas. Esta clase  no necesita ser instanciada, ya que todos sus m&eacute;todos son  est&aacute;ticos. Entre estos m&eacute;todos podremos encontrar todas  las operaciones matem&aacute;ticas b&aacute;sicas que podamos  necesitar, como logaritmos, exponenciales, funciones  trigonom&eacute;tricas, generaci&oacute;n de n&uacute;meros aleatorios,  conversi&oacute;n entre grados y radianes, etc. Adem&aacute;s nos  ofrece las constantes de los n&uacute;meros <em>PI</em> y <em>E</em>.</p>
<p><strong>Otras clases</strong></p>
<p>Si miramos dentro del paquete <strong>java.util</strong>, podremos  encontrar una serie de clases que nos podr&aacute;n resultar  &uacute;tiles para determinadas aplicaciones.</p>
<p>Entre ellas tenemos la clase <strong>Calendar</strong>, que nos  servir&aacute; cuando trabajemos con fechas y horas, para realizar  operaciones con fechas, comparar fechas, u obtener distintas  representaciones para mostrar la fecha en nuestra aplicaci&oacute;n. </p>
<p>Encontramos tambi&eacute;n la clase <strong>Currency</strong> con  informaci&oacute;n monetaria. La clase <strong>Locale</strong> almacena informaci&oacute;n sobre una determinada regi&oacute;n del  mundo, por lo que podremos utilizar esta clase junto a las anteriores  para obtener la moneda de una determinada zona, o las diferencias  horarias y de representaci&oacute;n de fechas.</p>
</body>
</html>
