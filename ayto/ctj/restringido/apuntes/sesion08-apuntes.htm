<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Nacho">
   <meta name="GENERATOR" content="Microsoft FrontPage 4.0">
   <title>Sesion 8: Java para MIDs. MIDlets</title>
<link rel="stylesheet" href="../apuntes.css" type="text/css">
</head>
<body>

<h1> 8. Introducción a Java para MIDs</h1>
             
<p>El c&oacute;digo Java, una vez compilado, puede llevarse sin modificaci&oacute;n 
  alguna sobre cualquier m&aacute;quina, y ejecutarlo. Esto se debe a que el c&oacute;digo 
  se ejecuta sobre una m&aacute;quina hipot&eacute;tica o virtual, la <b>Java 
  Virtual Machine</b>, que se encarga de interpretar el c&oacute;digo (ficheros 
  compilados <code>.class</code>)<i> </i>y convertirlo a c&oacute;digo particular 
  de la CPU que se est&eacute; utilizando (siempre que se soporte dicha m&aacute;quina 
  virtual). </p>
             
<p>Hemos visto que en el caso de los MIDs, este c&oacute;digo intermedio Java se ejecutar&aacute; 
  sobre una versi&oacute;n reducida de la m&aacute;quina virtual, la <strong>KVM</strong> 
  (<strong>Kilobyte Virtual Machine</strong>), lo cual producir&aacute; determinadas limitaciones en las aplicaciones desarrolladas para dicha m&aacute;quina virtual. </p>
             
<p>Cuando se programa con Java se dispone de antemano de un conjunto de clases 
  ya implementadas. Estas clases (aparte de las que pueda hacer el usuario) forman 
  parte del propio lenguaje (lo que se conoce como <b>API</b> (<i>Application 
  Programming Interface</i>) de Java). </p>
<p>La API que se utilizar&aacute; para programar las aplicaciones para MIDs ser&aacute; 
  la API de MIDP, que contendr&aacute; un conjunto reducido de clases que nos 
  permitan realizar las tareas fundamentales en estas aplicaciones. La implementaci&oacute;n 
  de esta API estar&aacute; optimizada para ejecutarse en este tipo de dispositivos. En CLDC tendremos un subconjunto reducido y simplificado de las clases de J2SE, mientras que en MIDP tendremos clases que son exclusivas de J2ME ya que van orientadas a la programaci&oacute;n de las caracter&iacute;sticas propias de los dispositivos m&oacute;viles. </p>
<p>En este punto estudiaremos las clases que CLDC toma de J2SE, y veremos las diferencias y limitaciones que tienen respecto a su versi&oacute;n en la plataforma est&aacute;ndar de Java. </p>
<h2><b>8.1. Tipos de datos</b></h2>
<p>En CLDC desaparecen los tipos <code>float</code> y <code>double</code> que pod&iacute;amos usar en otras ediciones de Java. Esto es debido a que 
    la <strong>KVM</strong> no tiene soporte para estos tipos, ya que las operaciones 
    con n&uacute;meros reales son complejas y estos dispositivos muchas veces 
  no tienen unidad de punto flotante.</p>
<p>Las aplicaciones J2ME para dispositivos CDC si que podr&aacute;n usar estos 
    tipos de datos, ya que funcionar&aacute;n con la m&aacute;quina virtual <strong>CVM</strong> que si que soporta estos tipos. Por lo tanto la limitaci&oacute;n no es de 
    J2ME, sino de la m&aacute;quina virtual <strong>KVM</strong> en la que se 
    basan las aplicaciones CLDC. </p>
<p>NOTA: En CLDC 1.1 se incorporan los tipos de datos <code>double</code> y 
  <code>float</code>. En los dispositivos que soporten esta versi&oacute;n de 
    la API podremos utilizar estos tipos de datos.</p>
<h2><b>8.2. N&uacute;meros reales</b></h2>
<p>En CLDC 1.0 echamos en falta el soporte para n&uacute;mero de coma flotante 
  (<code>float</code> y <code>double</code>). En principio podemos pensar que 
  esto es una gran limitaci&oacute;n, sobretodo para aplicaciones que necesiten 
  trabajar con valores de este tipo. Por ejemplo, si estamos trabajando con informaci&oacute;n 
  monetaria para mostrar el precio de los productos necesitaremos utilizar n&uacute;meros 
  como 13.95&euro;. </p>
<p>Sin embargo, en muchos casos podremos valernos de los n&uacute;meros enteros 
  para representar estos n&uacute;meros reales. Vamos a ver un truco con el que 
  implementar soporte para n&uacute;meros reales de coma fija mediante datos de 
  tipo entero (<code>int</code>).</p>
<p>Este truco consiste en considerar un n&uacute;mero <em>N</em> fijo de decimales, 
  por ejemplo en el caso de los precios podemos considerar que van a tener 2 decimales. 
  Entonces lo que haremos ser&aacute; trabajar con n&uacute;meros enteros, considerando 
  que las <em>N</em> &uacute;ltimas cifras son los decimales. Por ejemplo, si 
  un producto cuesta 13.95&euro;, lo guardaremos en una variable entera con valor 
  1395, es decir, en este caso es como si estuvi&eacute;semos guardando la informaci&oacute;n 
  en c&eacute;ntimos.</p>
<p>Cuando queramos mostrar este valor, deberemos separar la parte entera y la 
  fraccionaria para imprimirlo con el formato correspondiente a un n&uacute;mero 
  real. Haremos la siguiente transformaci&oacute;n:</p>
<pre class="codigo">public String imprimeReal(int numero) {
    int entero = numero / 100;
    int fraccion = numero % 100;
    return entero + &quot;.&quot; + (fraccion&lt;10?&quot;0&quot;:&quot;&quot;) + fraccion;
}</pre>
<p>Cuando el usuario introduzca un n&uacute;mero con formato real, y queramos 
  leerlo y guardarlo en una variable de tipo entero (<code>int</code>) deberemos 
  hacer la transformaci&oacute;n contraria:</p>
<pre class="codigo">public int leeReal(String numero) {
    int pos_coma = numero.indexOf('.');

    String entero = numero.substring(0, pos_coma - 1);

    String fraccion = numero.substring(pos_coma + 1, pos_coma + 2);

    return Integer.parseInt(entero)*100 + Integer.parseInt(fraccion);

}</pre>
<p>Es posible que necesitemos realizar operaciones b&aacute;sicas con estos n&uacute;meros 
  reales. Podremos realizar operaciones como suma, resta, multiplicaci&oacute;n 
  y divisi&oacute;n utilizando la representaci&oacute;n como enteros de estos 
  n&uacute;meros.</p>
<p>El caso de la suma y de la resta es sencillo. Si sumamos o restamos dos n&uacute;meros 
  con <em>N</em> decimales cada uno, podremos sumarlos como si fuesen enteros 
  y sabremos que las &uacute;ltimas <em>N</em> cifras del resultado son decimales. 
  Por ejemplo, si queremos a&ntilde;adir dos productos a la cesta de la compra, 
  cuyos precios son 13.95&euro; y 5.20&euro; respectivamente, deberemos sumar 
  estas cantidades para obtener el importe total. Para ello las trataremos como 
  enteros y hacemos la siguiente suma:</p>
<p><code>1395 + 520 = 1915</code></p>
<p>Por lo tanto, el resultado de la suma de los n&uacute;meros reales ser&aacute; 
  19.15&euro;.</p>
<p>El caso de la multiplicaci&oacute;n es algo m&aacute;s complejo. Si queremos 
  multiplicar dos n&uacute;meros, con <em>N</em> y <em>M</em> decimales respectivamente, 
  podremos hacer la multiplicaci&oacute;n como si fuesen enteros sabiendo que 
  el resultado tendr&aacute; <em>N+M</em> decimales. Por ejemplo, si al importe 
  anterior de 19.15&euro; queremos a&ntilde;adirle el IVA, tendremos que multiplicarlo 
  por 1.16. Haremos la siguiente operaci&oacute;n entera:</p>
<p><code>1915 * 116 = 222140</code></p>
<p>El resultado real ser&aacute; 22.2140&euro;, ya que si cada operando ten&iacute;a 
  2 decimales, el resultado tendr&aacute; 4.</p>
<p>Si estas operaciones b&aacute;sicas no son suficiente podemos utilizar una 
  librer&iacute;a como <strong>MathFP</strong>, que nos permitir&aacute; realizar 
  operaciones m&aacute;s complejas con n&uacute;meros de coma fija representados 
  como enteros. Entre ellas tenemos disponibles operaciones trigonom&eacute;tricas, 
  logar&iacute;tmicas, exponenciales, potencias, etc. Podemos descargar esta librer&iacute;a 
  de <code>http://www.jscience.net/</code> e incluirla libremente en nuestra aplicaciones 
  J2ME.</p>
<h2>8.3. Caracter&iacute;sticas b&aacute;sicas de CLDC</h2>
<p>Vamos a ver las caracter&iacute;sticas b&aacute;sicas del lenguaje Java (plataforma 
  J2SE) que tenemos disponibles en la API CLDC de los dispositivos m&oacute;viles. 
  Dentro de esta API tenemos la parte b&aacute;sica del lenguaje que debe estar 
  disponible en cualquier dispositivo conectado limitado.</p>
<p>Esta API b&aacute;sica se ha tomado directamente de J2SE, de forma que los 
  programadores que conozcan el lenguaje Java podr&aacute;n programar de forma 
  sencilla aplicaciones para dispositivos m&oacute;viles sin tener que aprender 
  a manejar una API totalmente distinta. S&oacute;lo tendr&aacute;n que aprender 
  a utilizar la parte de la API propia de estos dispositivos m&oacute;viles, que 
  se utiliza para caracter&iacute;sticas que s&oacute;lo est&aacute;n presentes 
  en estos dispositivos.</p>
<p>Dado que estos dispositivos tienen una capacidad muy limitada, en CLDC s&oacute;lo 
  est&aacute; disponible una parte reducida de esta API de Java. Vamos a ver en 
  este punto qu&eacute; caracter&iacute;sticas de las que ya conocemos del lenguaje 
  Java est&aacute;n presentes en CLDC para programar en dispositivos m&oacute;viles.</p>
<h3>8.3.1. Excepciones</h3>
<p>El manejo de las excepciones se realiza de la misma forma que en J2SE.</p>
<h3>8.3.2. Hilos</h3>
<p>En la API de CLDC no est&aacute;n presentes los grupos de hilos. La clase <code>ThreadGroup</code> de la API de J2SE no existe en la API de CLDC, por lo que no podremos utilizar esta caracter&iacute;stica desde los MIDs. Tampoco podemos ejecutar hilos como demonios (<em>daemon</em>).</p>
<h3>8.3.3. Colecciones </h3>
<p>En J2SE existe lo que se conoce como marco de colecciones, que comprende una 
  serie de tipos de datos. Estos tipos de datos se denominan colecciones por ser 
  una colecci&oacute;n de elementos, tenemos distintos subtipos de colecciones 
  como las listas (secuencias de elementos), conjuntos (colecciones sin elementos 
  repetidos) y mapas (conjunto de parejas <em>&lt;clave, valor&gt;</em>). Tendremos 
  varias implementaciones de estos tipos de datos, siendo sus operadores polim&oacute;rficos, 
  es decir, se utilizan los mismos operadores para distintos tipos de datos. Para 
  ello se definen interfaces que deben implementar estos tipos de datos, una serie 
  de implementaciones de estas interfaces y algoritmos para trabajar con ellos.</p>
<p>Sin embargo, en CLDC no tenemos este marco de colecciones. Al tener que utilizar 
  una API tan reducida como sea posible, tenemos solamente las clases <code>Vector</code> 
  (tipo lista), <code>Stack</code> (tipo pila) y <code>Hashtable</code> (mapa) 
  tal como ocurr&iacute;a en las primeras versiones de Java. Estas clases son 
  independientes, no implementan ninguna interfaz com&uacute;n.</p>
<h3><strong>8.3.4. Wrappers de tipos b&aacute;sicos</strong></h3>
<p>En CLDC tenemos <em>wrappers</em> para los tipos b&aacute;sicos soportados: <code>Boolean</code>, 
  <code>Integer</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, 
  <code>Character</code>.</p>
<p>NOTA: Dado que a partir de CLDC 1.1 se incorporan los tipos de datos <code>float</code> 
  y <code>double</code>, aparecer&aacute;n tambi&eacute;n sus correspondientes <em>wrappers</em>: <code>Float</code> y <code>Double</code>.</p>
<h3>8.3.5. Clases &uacute;tiles</h3>
<p>Vamos a ver ahora una serie de clases b&aacute;sicas del lenguaje Java que 
  siguen estando en CLDC. La versi&oacute;n de CLDC de estas clases estar&aacute; 
  normalmente m&aacute;s limitada, a continuaci&oacute;n veremos las diferencias 
  existentes entre la versi&oacute;n de J2SE y la de CLDC.</p>
<p><strong>Object</strong></p>
<p>En J2SE la clase <code>Object</code> tiene un m&eacute;todo <code>clone</code> que podemos utilizar para realizar una copia del objeto, de forma que tengamos 
  dos objetos independientes en memoria con el mismo contenido. Este m&eacute;todo 
  no existe en CLDC, por lo que si queremos realizar una copia de un objeto deberemos 
  definir un constructor de copia, es decir, un constructor que construya un nuevo 
  objeto copiando todas las propiedades de otro objeto de la misma clase. </p>
<p><strong>System</strong></p>
<p>Podemos encontrar los objetos que encapsulan la salida y salida de error est&aacute;ndar. A diferencia 
  de J2SE, en CLDC no tenemos entrada est&aacute;ndar.</p>
<p>Tampoco nos permite instalar un gestor de seguridad para la aplicaci&oacute;n. 
  La API de CLDC y MIDP ya cuenta con las limitaciones suficientes para que las 
  aplicaciones sean seguras.</p>
<p>En CLDC no tenemos una clase <code>Properties</code> con una colecci&oacute;n 
  de propiedades. Por esta raz&oacute;n, cuando leamos propiedades del sistema 
  no podremos obtenerlas en un objeto <code>Properties</code>, sino que tendremos 
  que leerlas individualmente. Estas son propiedades del sistema, no son los propiedades 
  del usuario que aparecen en el fichero JAD. En el pr&oacute;ximo tema veremos 
c&oacute;mo leer estas propiedades del usuario.</p>
<p><strong>Runtime</strong></p>
<p>En J2SE podemos utilizar esta clase para ejecutar comandos del sistema con 
  <code>exec</code>. En CLDC no disponemos de esta caracter&iacute;stica. Lo que 
  si podremos hacer con este objeto es obtener la memoria del sistema, y la memoria 
  libre.</p>
<p><strong>Math</strong></p>
<p>En CLDC 1.0, al no contar 
  con soporte para n&uacute;meros reales, esta clase contendr&aacute; muy pocos 
  m&eacute;todos, s&oacute;lo tendr&aacute; aquellas operaciones que trabajan 
  con n&uacute;meros enteros, como las operaciones de valor absoluto, m&aacute;ximo 
  y m&iacute;nimo.</p>
<p><strong>Random</strong></p>
<p>En CLDC 1.0 s&oacute;lo nos permitir&aacute; generar n&uacute;meros enteros 
  de forma aleatoria, ya que no tenemos soporte para reales.</p>
<p><strong>Fechas y horas</strong></p>
<p>Si miramos dentro del paquete <code>java.util</code>, podremos encontrar una 
  serie de clases que nos podr&aacute;n resultar &uacute;tiles para determinadas 
  aplicaciones.</p>
<p>Entre ellas tenemos la clase <code>Calendar</code>, que junto a <code>Date</code> 
  nos servir&aacute; cuando trabajemos con fechas y horas. La clase <code>Date</code> 
  representar&aacute; un determinado instante de tiempo, en tiempo absoluto. Esta 
  clase trabaja con el tiempo medido en milisegundos desde el desde el 1 de enero 
  de 1970 a las 0:00, por lo que ser&aacute; dif&iacute;cil trabajar con esta 
  informaci&oacute;n directamente.</p>
<p> Podremos utilizar la clase <code>Calendar</code> para obtener un determinado 
  instante de tiempo encapsulado en un objeto <code>Date</code>, proporcionando 
  informaci&oacute;n de alto nivel como el a&ntilde;o, mes, d&iacute;a, hora, 
  minuto y segundo.</p>
<p>Con <code>TimeZone</code> podemos representar una determinada zona horaria, 
  con lo que podremos utilizarla junto a las clases anteriores para obtener diferencias 
  horarias.</p>
<p><strong>Temporizadores</strong></p>
<p>Los temporizadores nos permitir&aacute;n planificar tareas para ser ejecutadas 
  por un hilo en segundo plano. Para trabajar con temporizadores tenemos las clases 
  <code>Timer</code> y <code>TimerTask</code>. </p>
<p>Lo primero que deberemos hacer es crear las tareas que queramos planificar. 
  Para crear una tarea crearemos una clase que herede de <code>TimerTask</code>, 
  y que defina un m&eacute;todo <code>run</code> donde incluiremos el c&oacute;digo 
  que implemente la tarea.</p>
<pre class="codigo">public class MiTarea extends <strong>TimerTask</strong> {
    public void <strong>run</strong>() {
        // C&oacute;digo de la tarea
    }
}</pre>
<p>Una vez definida la tarea, utilizaremos un objeto <code>Timer</code> para planificarla. 
  Para ello deberemos establecer el tiempo de comienzo de dicha tarea, cosa que 
  puede hacerse de dos formas diferentes:</p>
<ul>
  <li><strong>Retardo</strong> (<em>delay</em>): Nos permitir&aacute; planificar 
    la tarea para que comience a ejecutarse transcurrido un tiempo dado. Por ejemplo, 
    podemos hacer que una determinada tarea comience a ejecutarse dentro de 10 
    segundos.<br>
  </li>
  <li><strong>Fecha y hora</strong>: Podemos hacer que la tarea comience a una 
    determinada hora y fecha dada en tiempo absoluto. Por ejemplo, podemos hacer 
    que a las 8:00 se ejecute una tarea que haga de despertador.</li>
</ul>
<p>Tenemos diferentes formas de planificaci&oacute;n de tareas, seg&uacute;n el 
  n&uacute;mero de veces y la periodicidad con la que se ejecutan:</p>
<ul>
  <li><strong>Una sola ejecuci&oacute;n</strong>: Se ejecuta en el tiempo de inicio 
    especificado y no se vuelve a ejecutar a no ser que la volvamos a planificar.<br>
  </li>
  <li><strong>Repetida con retardo fijo</strong>: Se ejecuta repetidas veces, 
    con un determinado retardo entre cada dos ejecuciones consecutivas. Este retardo 
    podremos especificarlo nosotros. La tarea se volver&aacute; a ejecutar siempre 
    transcurrido este tiempo desde la &uacute;ltima vez que se ejecut&oacute;, 
    hasta que detengamos el temporizador.<br>
  </li>
  <li><strong>Repetida con frecuencia constante</strong>: Se ejecuta repetidas 
    veces con una frecuencia dada. Deberemos especificar el retardo que queremos 
    entre dos ejecuciones consecutivas. A diferencia del caso anterior, no se 
    toma como referencia el tiempo de ejecuci&oacute;n de la tarea anterior, sino 
    el tiempo de inicio de la primera ejecuci&oacute;n. De esta forma, si una 
    ejecuci&oacute;n se retrasa por alguna raz&oacute;n, como por ejemplo por 
    tener demasiada carga el procesador, la siguiente tarea comenzar&aacute; transcurrido 
    un tiempo menor, para mantener la frecuencia deseada.</li>
</ul>
<p>Deberemos como primer paso crear el temporizador y la tarea que vamos a planificar:</p>
<pre class="codigo">Timer t = new Timer();
TimerTask tarea = new MiTarea();</pre>
<p>Ahora podemos planificarla para comenzar con un retardo, o bien a una determinada 
  fecha y hora. Si vamos a hacerlo por retardo, utilizaremos uno de los siguientes 
  m&eacute;todos, seg&uacute;n la periodicidad:</p>
<pre class="codigo">t.<strong>schedule</strong>(tarea, retardo);                     // Una vez
t.<strong>schedule</strong>(tarea, retardo, periodo);            // Retardo fijo
t.<strong>scheduleAtFixedRate</strong>(tarea, retardo, periodo); // Frecuencia constante</pre>
<p>Si queremos comenzar a una determinada fecha y hora, deberemos utilizar un 
  objeto <code>Date</code> para especificar este tiempo de comienzo:</p>
<pre class="codigo">Calendar calendario = Calendar.getInstance();
calendario.set(Calendar.HOUR_OF_DAY, 8);
calendario.set(Calendar.MINUTE, 0);
calendario.set(Calendar.SECOND, 0);
calendario.set(Calendar.MONTH, Calendar.SEPTEMBER);
calendario.set(Calendar.DAY_OF_MONTH, 22);
Date fecha = calendario.getTime();</pre>
<p>Una vez obtenido este objeto con la fecha a la que queremos comenzar la tarea 
  (en nuestro ejemplo el d&iacute;a 22 de septiembre a las 8:00), podemos planificarla 
  con el temporizador igual que en el caso anterior:</p>
<pre class="codigo">t.<strong>schedule</strong>(tarea, fecha);                     // Una vez
t.<strong>schedule</strong>(tarea, fecha, periodo);            // Retardo fijo
t.<strong>scheduleAtFixedRate</strong>(tarea, fecha, periodo); // Frecuencia constante</pre>
<p>Los temporizadores nos ser&aacute;n &uacute;tiles en las aplicaciones m&oacute;viles 
  para realizar aplicaciones como por ejemplo agendas o alarmas. La planificaci&oacute;n 
  por retardo nos permitir&aacute; mostrar ventanas de transici&oacute;n en nuestras 
  aplicaciones durante un n&uacute;mero determinado de segundos.</p>
<p>Si queremos que un temporizador no vuelva a ejecutar la tarea planificada, 
  utilizaremos su m&eacute;todo cancel para cancelarlo.</p>
<pre class="codigo">t.<strong>cancel</strong>();</pre>
<p>Una vez cancelado el temporizador, no podr&aacute; volverse a poner en marcha 
  de nuevo. Si queremos volver a planificar la tarea deberemos crear un temporizador 
  nuevo.</p>
<h3>8.3.6. Flujos de entrada/salida</h3>
<p>En las aplicaciones CLDC, normalmente utilizaremos flujos para enviar o recibir 
  datos a trav&eacute;s de la red, o para leer o escribir datos en alg&uacute;n <em>buffer</em> de memoria.</p>
<p class="subsection">En CLDC no encontramos flujos para acceder directamente a ficheros, ya que 
  no podemos contar con poder acceder al sistema de ficheros de los dispositivos 
  m&oacute;viles, esta caracter&iacute;stica ser&aacute; opcional. Tampoco tenemos 
  disponible ning&uacute;n <em>tokenizer</em>, por lo que la lectura y escritura 
  deber&aacute; hacerse a bajo nivel como acabamos de ver, e implementar nuestro 
  propio analizador l&eacute;xico en caso necesario. </p>
<p><strong>Serializaci&oacute;n de objetos</strong></p>
<p>Otra caracter&iacute;stica que no est&aacute; disponible en CLDC es la serializaci&oacute;n 
  autom&aacute;tica de objetos, por lo que no podremos enviar directamente objetos 
  a trav&eacute;s de los flujos de datos. No existe ninguna forma de serializar 
  cualquier objeto arbitrario autom&aacute;ticamente en CLDC, ya que no soporta 
  <em>reflection</em>.</p>
<p>Sin embargo, podemos hacerlo de una forma m&aacute;s sencilla, y es haciendo 
  que cada objeto particular proporcione m&eacute;todos para serializarse y deserializarse. 
  Estos m&eacute;todos los deberemos escribir nosotros, adapt&aacute;ndolos a 
  las caracter&iacute;sticas de los objetos. </p>
<p>Por ejemplo, supongamos que tenemos una clase <code>Punto2D</code> como la 
  siguiente:</p>
<pre class="codigo">public class Punto2D {<br>    int x;
    int y;
    String etiqueta;

    ...
}</pre>
<p class="subsection">Los datos que contiene cada objeto de esta clase son las 
  coordenadas <em>(x,y) </em>del punto y una etiqueta para identificar este punto. 
  Si queremos serializar un objeto de esta clase esta ser&aacute; la informaci&oacute;n 
  que deberemos codificar en forma de serie de <em>bytes</em>. </p>
<p class="subsection">Podemos crear dos m&eacute;todos manualmente para codificar 
  y descodificar esta informaci&oacute;n en forma de <em>array</em> de <em>bytes</em>, 
  como se muestra a continuaci&oacute;n:</p>
<pre class="codigo">public class Punto2D {
    int x;
    int y; 
    String etiqueta; 
    ... 
    public void <strong>serialize</strong>(OutputStream out) throws IOException {
        DataOutputStream dos = new DataOutputStream( out );
<br>        dos.writeInt(x);
        dos.writeInt(y);
        dos.writeUTF(etiqueta);<br>        dos.flush();
    }

    public static Punto2D <strong>deserialize</strong>(InputStream in) 
      throws IOException {
        DataInputStream dis = new DataInputStream( in );
<br>        Punto2D p = new Punto2D();
        p.x = dis.readInt();
        p.y = dis.readInt();
        p.etiqueta = dis.readUTF();<br><br>        return p;<br>    }
}</pre>
<p class="subsection">Hemos visto como los flujos de procesamiento <code>DataOutputStream</code> 
  y <code>DataInputStream</code> nos facilitan la codificaci&oacute;n de distintos 
  tipos de datos para ser enviados a trav&eacute;s de un flujo de datos.</p>
<p class="subsection"><strong>Acceso a los recursos</strong></p>
<p>Hemos visto que no podemos acceder al sistema de ficheros directamente como 
  hac&iacute;amos en J2SE. Sin embargo, con las aplicaciones MIDP podemos incluir 
  una serie de recursos a los que deberemos poder acceder. Estos recursos son 
  ficheros incluidos en el fichero JAR de la aplicaci&oacute;n, como por ejemplo 
  sonidos, im&aacute;genes o ficheros de datos. </p>
<p>Para acceder a estos recursos deberemos abrir un flujo de entrada que se encargue 
  de leer su contenido. Para ello utilizaremos el m&eacute;todo <code>getResourceAsStream</code> 
  de la clase <code>Class</code>:</p>
<pre class="codigo">InputStream in = getClass().<strong>getResourceAsStream</strong>(&quot;datos.txt&quot;);</pre>
<p>De esta forma podremos utilizar el flujo de entrada obtenido para leer el contenido 
  del fichero que hayamos indicado. Este fichero deber&aacute; estar contenido 
  en el JAR de la aplicaci&oacute;n.</p>
<p class="subsection"><strong>Salida y salida de error estándar</strong></p>
<p>En J2SE la entrada estándar normalmente se refiere 
  a lo que el usuario escribe en la consola, aunque el sistema operativo puede 
  hacer que se tome de otra fuente. De la misma forma la salida y la salida de 
  error estándar lo que hacen normalmente es mostrar los mensajes y los errores 
  del programa respectivamente en la consola, aunque el sistema operativo también 
  podrá redirigirlas a otro destino.</p>
<p>En los MIDs no tenemos consola, por lo que los mensajes que imprimamos por 
  la salida est&aacute;ndar normalmente ser&aacute;n ignorados. Esta salida estar&aacute; 
  dirigida a un dispositivo <em>null</em> en los tel&eacute;fonos m&oacute;viles. 
  Sin embargo, imprimir por la salida est&aacute;ndar puede resultarnos &uacute;til 
  mientras estemos probando la aplicaciones en emuladores, ya que al ejecutarse 
  en el ordenador estos emuladores, estos mensajes si que se mostrar&aacute;n 
  por la consola, por lo que podremos imprimir en ellos informaci&oacute;n que 
  nos sirva para depurar las aplicaciones.</p>
<h3 class="subsection">8.3.7. Caracter&iacute;sticas ausentes</h3>
<p>Adem&aacute;s de las diferencias que hemos visto en los puntos anteriores, 
  tenemos APIs que han desaparecido en su totalidad, o pr&aacute;cticamente en 
  su totalidad.</p>
<p><strong>Reflection</strong></p>
<p>En CLDC no est&aacute; presente la API de <em>reflection</em>. S&oacute;lo 
  est&aacute; presente la clase <code>Class</code> con la que podremos cargar 
  clases din&aacute;micamente y comprobar la clase a la que pertenece un objeto 
  en tiempo de ejecuci&oacute;n. Tenemos adem&aacute;s en esta clase el m&eacute;todo 
  <code>getResourceAsStream</code> que hemos visto anteriormente, que nos servir&aacute; 
  para acceder a los recursos dentro del JAR de la aplicaci&oacute;n.</p>
<p><strong>Red</strong></p>
<p>La API para el acceso a la red de J2SE es demasiado compleja para los MIDs. 
  Por esta raz&oacute;n se ha sustituido por una nueva API totalmente distinta, 
  adaptada a las necesidades de conectividad de estos dispositivos. Desaparece 
  la API <code>java.net</code>, para acceder a la red ahora deberemos utilizar 
  la API <code>javax.microedition.io </code>incluida en CLDC que veremos en detalle 
  en el pr&oacute;ximo tema.</p>
<p><strong>AWT/Swing</strong></p>
<p>Las librer&iacute;as para la creaci&oacute;n de interfaces gr&aacute;ficas, 
  AWT y Swing, desaparecen totalmente ya que estas interfaces no son adecuadas 
  para las pantallas de los MIDs. Para crear la interfaz gr&aacute;fica de las 
  aplicaciones para m&oacute;viles tendremos la API <code>javax.microedition.lcdui</code> 
  perteneciente a MIDP.</p>
<h2> 8.4. MIDlets</h2>
<p>Hasta ahora hemos visto la parte b&aacute;sica del lenguaje Java que podemos 
  utilizar en los dispositivos m&oacute;viles. Esta parte de la API est&aacute; 
  basada en la API b&aacute;sica de J2SE, reducida y optimizada para su utilizaci&oacute;n 
  en dispositivos de baja capacidad. Esta es la base que necesitaremos para programar 
  cualquier tipo de dispositivo, sin embargo con ella por si sola no podemos acceder 
  a las caracter&iacute;sticas propias de los m&oacute;viles, como su pantalla, 
  su teclado, reproducir tonos, etc.</p>
<p>Vamos a ver ahora las APIs propias para el desarrollo de aplicaciones m&oacute;viles. 
  Estas APIs ya no est&aacute;n basadas en APIs existentes en J2SE, sino que se 
  han desarrollado espec&iacute;ficamente para la programaci&oacute;n en estos 
  dispositivos. Todas ellas pertenecen al paquete <code>javax.microedition</code>.</p>
<p>Los MIDlets son las aplicaciones para MIDs, realizadas con la API de MIDP. 
  La clase principal de cualquier aplicaci&oacute;n MIDP deber&aacute; ser un 
  MIDlet. Ese MIDlet podr&aacute; utilizar cualquier otra clase Java y la API 
  de MIDP para realizar sus funciones.</p>
<p>Para crear un MIDlet deberemos heredar de la clase <code>MIDlet</code>. Esta 
  clase define una serie de m&eacute;todos abstractos que deberemos definir en 
  nuestros MIDlets, introduciendo en ellos el c&oacute;digo propio de nuestra 
  aplicaci&oacute;n:</p>
<pre class="codigo">protected abstract void <strong>startApp</strong>();<br>protected abstract void <strong>pauseApp</strong>();
protected abstract void <strong>destroyApp</strong>(boolean incondicional);</pre>
<p>A continuaci&oacute;n veremos con m&aacute;s detalle qu&eacute; deberemos introducir 
  en cada uno de estos m&eacute;todos.</p>
<h3>8.4.1. Componentes y contenedores</h3>
<p>Numerosas veces encontramos dentro de las tecnolog&iacute;as Java el concepto 
  de componentes y contenedores. Los componentes son elementos que tienen una 
  determinada interfaz, y los contenedores son la infraestructura que da soporte 
  a estos componentes. </p>
<p>Por ejemplo, podemos ver los <em>applets</em> como un tipo de componente, que 
  para poderse ejecutar necesita un navegador web que haga de contenedor y que 
  lo soporte. De la misma forma, los <em>servlets</em> son componentes que encapsulan 
  el mecanismo petici&oacute;n/respuesta de la web, y el servidor web tendr&aacute; 
  un contenedor que de soporte a estos componentes, para ejecutarlos cuando se 
  produzca una petici&oacute;n desde un cliente. De esta forma nosotros podemos 
  deberemos definir s&oacute;lo el componente, con su correspondiente interfaz, 
  y ser&aacute; el contenedor quien se encargue de controlar su ciclo de vida 
  (instanciarlo, ejecutarlo, destruirlo).</p>
<p>Cuando desarrollamos componentes, no deberemos crear el m&eacute;todo <code>main</code>, 
  ya que estos componentes no se ejecutan como una aplicaci&oacute;n independiente 
  (<em>stand-alone</em>), sino que son ejecutados dentro de una aplicaci&oacute;n 
  ya existente, que ser&aacute; el contenedor. </p>
<p>El contenedor que da soporte a los MIDlets recibe el nombre de <em>Application 
  Management Software</em> (AMS). El AMS adem&aacute;s de controlar el ciclo de 
  vida de la ejecuci&oacute;n MIDlets (inicio, pausa, destrucci&oacute;n), controlar&aacute; 
  el ciclo de vida de las aplicaciones que se instalen en el m&oacute;vil (instalaci&oacute;n, 
  actualizaci&oacute;n, ejecuci&oacute;n, desinstalaci&oacute;n).</p>
<h3>8.4.2. Ciclo de vida</h3>
<p>Durante su ciclo de vida un MIDlet puede estar en los siguientes estados:</p>
<ul>
  <li><strong>Activo</strong>: El MIDlet se est&aacute; ejecutando actualmente.<br>
  </li>
  <li><strong>Pausado</strong>: El MIDlet se encuentra a mitad de una ejecuci&oacute;n 
    pero est&aacute; pausado. La ejecuci&oacute;n podr&aacute; reanudarse, pasando 
    de nuevo a estado activo. <br>
  </li>
  <li><strong>Destruido</strong>: El MIDlet ha terminado su ejecuci&oacute;n y 
    ha liberado todos los recursos, por lo que ya no se puede volver a estado 
    activo. La aplicaci&oacute;n est&aacute; cerrada, por lo que para volver a 
    ponerla en marcha tendr&iacute;amos que volver a ejecutarla.</li>
</ul>
<p>Ser&aacute; el AMS qui&eacute;n se encargue de controlar este ciclo de vida, 
  es decir, qui&eacute;n realice las transiciones de un estado a otro. Nosotros 
  podremos saber cuando hemos entrado en cada uno de estos estados porque el AMS 
  invocar&aacute; al m&eacute;todo correspondiente dentro de la clase del MIDlet. 
  Estos m&eacute;todos son los que se muestran en el siguiente esqueleto de un 
  MIDlet:</p>
<pre class="codigo">import javax.microedition.midlet.*;
<br>public class MiMIDlet extends <strong>MIDlet</strong> {<br><br>    protected void <strong>startApp</strong>() <br>            throws MIDletStateChangeException {
		// Estado activo -&gt; comenzar
    }<br><br>    protected void <strong>pauseApp</strong>() {
        // Estado pausa -&gt; detener hilos<br>    }<br><br>    protected void <strong>destroyApp</strong>(boolean incondicional) <br>            throws MIDletStateChangeException {
        // Estado destruido -&gt; liberar recursos<br>    }<br>}</pre>
<p>Deberemos definir los siguientes m&eacute;todos para controlar el ciclo de 
  vida del MIDlet:</p>
<ul>
  <li><strong><code>startApp()</code></strong>: Este m&eacute;todo se invocar&aacute; 
    cuando el MIDlet pase a estado activo. Es aqu&iacute; donde insertaremos el 
    c&oacute;digo correspondiente a la tarea que debe realizar dicho MIDlet. </li>
</ul>
<blockquote> 
  <p>Si ocurre un error que impida que el MIDlet empiece a ejecutarse deberemos 
    notificarlo. Podemos distinguir entre errores pasajeros o errores permanentes. 
    Los errores pasajeros impiden que el MIDlet se empiece a ejecutar ahora, pero 
    podr&iacute;a hacerlo m&aacute;s tarde. Los permanentes se dan cuando el MIDlet 
    no podr&aacute; ejecutarse nunca. </p>
  <p><strong>Pasajero</strong>: En el caso de que el error sea pasajero, lo notificaremos 
    lanzando una excepci&oacute;n de tipo <code>MIDletStateChangeException</code>, 
    de modo que el MIDlet pasar&aacute; a estado pausado, y se volver&aacute; 
    intentar activar m&aacute;s tarde.</p>
  <p><strong>Permanente</strong>: Si por el contrario el error es permanente, 
    entonces deberemos destruir el MIDlet llamando a <code>notifyDestroyed</code> 
    porque sabemos que nunca podr&aacute; ejecutarse correctamente. Si se lanza 
    una excepci&oacute;n de tipo <code>RuntimeException</code> dentro del m&eacute;todo 
    <code>startApp</code> tendremos el mismo efecto, se destruir&aacute; el MIDlet. 
  </p>
</blockquote>
<ul>
  <li><strong><code>pauseApp()</code></strong>: Se invocar&aacute; cuando se pause 
    el MIDlet. En &eacute;l deberemos detener las actividades que est&eacute; 
    realizando nuestra aplicaci&oacute;n.</li>
</ul>
<blockquote> 
  <p>Igual que en el caso anterior, si se produce una excepci&oacute;n de tipo 
    <code>RuntimeException</code> durante la ejecuci&oacute;n de este m&eacute;todo, 
    el MIDlet se destruir&aacute;.</p>
</blockquote>
<ul>
  <li><strong><code>destroyApp(boolean incondicional)</code></strong>: Se invocar&aacute; 
    cuando se vaya a destruir la aplicaci&oacute;n. En &eacute;l deberemos incluir 
    el c&oacute;digo para liberar todos los recursos que estuviese usando el MIDlet. 
    Con el <em>flag</em> que nos proporciona como par&aacute;metro indica si la 
    destrucci&oacute;n es incondicional o no. Es decir, si <code>incondicional</code> 
    es <code>true</code>, entonces se destruir&aacute; siempre. En caso de que 
    sea <code>false</code>, podemos hacer que no se destruya lanzando la excepci&oacute;n 
    <code>MIDletStateChangeException</code> desde dentro de este m&eacute;todo.</li>
</ul>
<div align="center"><img src="imagenes/midlet/ciclo.gif" width="400" height="174"> 
</div>
<p class="caption">Figura 1. Ciclo de vida de un MIDlet</p>
<p>Hemos visto que el AMS es quien realiza las transiciones entre distintos estados. 
  Sin embargo, nosotros podremos forzar a que se produzcan transiciones a los 
  estados pausado o destruido:</p>
<ul>
  <li><strong><code>notifyDestroyed()</code></strong>: Destruye el MIDlet. Utilizaremos 
    este m&eacute;todo cuando queramos finalizar la aplicaci&oacute;n. Por ejemplo, 
    podemos ejecutar este m&eacute;todo como respuesta a la pulsaci&oacute;n del 
    bot&oacute;n <em>&quot;Salir&quot;</em> por parte del usuario.</li>
</ul>
<blockquote> 
  <p>NOTA: La llamada a este m&eacute;todo notifica que el MIDlet ha sido destruido, 
    pero no invoca el m&eacute;todo <code>destroyApp</code> para liberar los recursos, 
    por lo que tendremos que invocarlo nosotros manualmente antes de llamar a 
    <code>notifyDestroyed</code>.</p>
</blockquote>
<ul>
  <li><strong><code>notifyPause()</code></strong>: Notifica al AMS de que el MIDlet 
    ha entrado en modo pausa. Despu&eacute;s de esto, el AMS podr&aacute; realizar 
    una llamada a <code>startApp</code> para volverlo a poner en estado activo.<br>
  </li>
  <li><strong><code>resumeRequest()</code></strong>: Solicita al AMS que el MIDlet 
    vuelva a ponerse activo. De esta forma, si el AMS tiene varios MIDlets candidatos 
    para activar, elegir&aacute; alguno de aquellos que lo hayan solicitado. Este 
    m&eacute;todo no fuerza a que se produzca la transici&oacute;n como en los 
    anteriores, simplemente lo solicita al AMS y ser&aacute; &eacute;ste qui&eacute;n 
    decida.</li>
</ul>
<h3>8.4.3. Cerrar la aplicaci&oacute;n</h3>
<p>La aplicaci&oacute;n puede ser cerrada por el AMS, por ejemplo si desde el 
  sistema operativo del m&oacute;vil hemos forzado a que se cierre. En ese caso, 
  el AMS invocar&aacute; el m&eacute;todo <code>destroyApp</code> que nosotros 
  habremos definido para liberar los recursos, y pasar&aacute; a estado <strong>destruido</strong>.</p>
<p>Si queremos hacer que la aplicaci&oacute;n termine de ejecutarse desde dentro 
  del c&oacute;digo, nunca utilizaremos el m&eacute;todo <code>System.exit</code> 
  (o <code>Runtime.exit</code>), ya que estos m&eacute;todos se utilizan para 
  salir de la m&aacute;quina virtual. En este caso, como se trata de un componente, 
  si ejecut&aacute;semos este m&eacute;todo cerrar&iacute;amos toda la aplicaci&oacute;n, 
  es decir, el AMS. Por esta raz&oacute;n esto no se permite, si intent&aacute;semos 
  hacerlo obtendr&iacute;amos una excepci&oacute;n de seguridad. </p>
<p>La &uacute;nica forma de salir de una aplicaci&oacute;n MIDP es haciendo pasar 
  el componente a estado destruido, como hemos visto en el punto anterior, para 
  que el contenedor pueda eliminarlo. Esto lo haremos invocando <code>notifyDestroyed</code> 
  para cambiar el estado a destruido. Sin embargo, si hacemos esto no se invocar&aacute; 
  autom&aacute;ticamente el m&eacute;todo <code>destroyApp</code> para liberar 
  los recursos, por lo que deberemos ejecutarlo nosotros manualmente antes de 
  marcar la aplicaci&oacute;n como destruida:</p>
<pre class="codigo">public void salir() {
    try {<br>        destroyApp(true);
    } catch(MIDletStateChangeException e) {
    }

    notifyDestroyed();
}</pre>
<p>Si queremos implementar una salida condicional, para que el m&eacute;todo <code>destroyApp</code> 
  pueda decidir si permitir que se cierre o no la aplicaci&oacute;n, podemos hacerlo 
  de la siguiente forma:</p>
<pre class="codigo">public void salir_cond() {
    try {

        destroyApp(false);

        notifyDestroyed();
    } catch(MIDletStateChangeException e) {
    }

}</pre>
<h3>8.4.4. Parametrizaci&oacute;n de los MIDlets</h3>
<p>Podemos a&ntilde;adir una serie de propiedades en el fichero descriptor de 
  la aplicaci&oacute;n (JAD), que podr&aacute;n ser le&iacute;das desde el MIDlet. 
  De esta forma, podremos cambiar el valor de estas propiedades sin tener que 
  rehacer el fichero JAR. </p>
<p>Cada propiedad consistir&aacute; en una clave (<em>key</em>) y en un valor. 
  La clave ser&aacute; el nombre de la propiedad. De esta forma tendremos un conjunto 
  de par&aacute;metros de configuraci&oacute;n (claves) con un valor asignado 
  a cada una. Podremos cambiar f&aacute;cilmente estos valores editando el fichero 
  JAD con cualquier editor de texto.</p>
<p>Para leer estas propiedades desde el MIDlet utilizaremos el m&eacute;todo:</p>
<pre class="codigo">String valor = <strong>getAppProperty</strong>(String key)</pre>
<p>Que nos devolver&aacute; el valor asignado a la clave con nombre <em>key</em>.</p>
<h3>8.4.5. Peticiones al dispositivo</h3>
<p>A partir de MIDP 2.0 se incorpora una nueva funci&oacute;n que nos permite 
  realizar peticiones que se encargar&aacute; de gestionar el dispositivo, de 
  forma externa a nuestra aplicaci&oacute;n. Por ejemplo, con esta funci&oacute;n 
  podremos realizar una llamada a un n&uacute;mero telef&oacute;nico o abrir el 
  navegador web instalado para mostrar un determinado documento. </p>
<p>Para realizar este tipo de peticiones utilizaremos el siguiente m&eacute;todo:</p>
<pre class="codigo">boolean debeSalir = <strong>platformRequest</strong>(url);</pre>
<p>Esto proporcionar&aacute; una URL al AMS, que determinar&aacute;, seg&uacute;n 
  el tipo de la URL, qu&eacute; servicio debe invocar. Adem&aacute;s nos devolver&aacute; 
  un valor <em>booleano</em> que indicar&aacute; si para que este servicio sea 
  ejecutado debemos cerrar el MIDlet antes. Algunos servicios de determinados 
  dispositivos no pueden ejecutarse concurrentemente con nuestra aplicaci&oacute;n, 
  por lo que en estos casos hasta que no la cerremos no se ejecutar&aacute; el 
  servicio.</p>
<p>Los tipos servicios que se pueden solicitar dependen de las caracter&iacute;sticas 
  del m&oacute;vil en el que se ejecute. Cada fabricante puede ofrecer un serie 
  de servicios accesibles mediante determinados tipos de URLs. Sin intentamos 
  acceder a un servicio que no est&aacute; disponible en el m&oacute;vil, se producir&aacute; 
  una excepci&oacute;n de tipo <code>ConnectionNotFoundException</code>.</p>
<p>En el est&aacute;ndar de MIDP 2.0 s&oacute;lo se definen URLs para dos tipos 
  de servicios:</p>
<ul>
  <li>Iniciar una llamada de voz. Para ello se utilizar&aacute; una URL como la 
    siguiente: 
    <pre class="codigo"><strong>tel</strong>:&lt;numero&gt;</pre>
  </li>
</ul>
<blockquote> 
  <p>Por ejemplo, podr&iacute;amos poner:</p>
  <pre class="codigo"><strong>tel</strong>:+34-965-123-456.</pre>
</blockquote>
<ul>
  <li>Instalar una <em>suite</em> de MIDlets. Se proporciona la URL donde est&aacute; 
    el fichero JAD de la suite que queramos instalar. Por ejemplo: 
    <pre class="codigo">http://www.jtech.ua.es/prueba/aplic.jad</pre>
  </li>
</ul>
<p>Si como URL proporcionamos una cadena vac&iacute;a (no <code>null</code>), 
  se cancelar&aacute;n todas las peticiones de servicios anteriores.</p>
<p>&nbsp;</p>
</body>
</html>
