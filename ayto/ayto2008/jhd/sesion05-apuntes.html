<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Colecciones de datos</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Java y Herramientas de Desarrollo" src="images/baner_j2ee_der.gif" title="Java y Herramientas de Desarrollo"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto SIGEM</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Java y Herramientas de Desarrollo</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Materiales</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Java y Herramientas de Desarrollo">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 5</div>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html">Sesion 10</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="sesion09-ejercicios.html">Sesion 9</a>
</div>
<div class="menuitem">
<a href="sesion10-ejercicios.html">Sesion 10</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion05-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Colecciones de datos</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Colecciones">Colecciones</a>
<ul class="minitoc">
<li>
<a href="#Listas+de+elementos">Listas de elementos</a>
</li>
<li>
<a href="#Conjuntos">Conjuntos</a>
</li>
<li>
<a href="#Mapas">Mapas</a>
</li>
<li>
<a href="#Wrappers">Wrappers</a>
</li>
<li>
<a href="#Gen%C3%A9ricos">Gen&eacute;ricos</a>
</li>
<li>
<a href="#Recorrer+las+colecciones">Recorrer las colecciones</a>
</li>
</ul>
</li>
<li>
<a href="#Polimorfismo+e+interfaces">Polimorfismo e interfaces</a>
<ul class="minitoc">
<li>
<a href="#Ejemplo%3A+Algoritmos">Ejemplo: Algoritmos</a>
</li>
<li>
<a href="#Patr%C3%B3n+factor%C3%ADa">Patr&oacute;n factor&iacute;a</a>
</li>
</ul>
</li>
<li>
<a href="#Tipos+de+datos">Tipos de datos</a>
<ul class="minitoc">
<li>
<a href="#Wrappers+de+tipos+b%C3%A1sicos">Wrappers de tipos b&aacute;sicos</a>
</li>
<li>
<a href="#Autoboxing">Autoboxing</a>
</li>
<li>
<a href="#Estructuras+de+datos">Estructuras de datos</a>
</li>
</ul>
</li>
</ul>
</div>        
          

<p>La plataforma Java nos proporciona un amplio conjunto de clases dentro del 
  que podemos encontrar tipos de datos que nos resultar&aacute;n muy &uacute;tiles 
  para realizar la programaci&oacute;n de aplicaciones en Java. Estos tipos de 
  datos nos ayudar&aacute;n a generar c&oacute;digo m&aacute;s limpio de una forma 
  sencilla. </p>

<p>Se proporcionan una serie de operadores para acceder a los elementos de estos 
  tipos de datos. Decimos que dichos operadores son <em>polim&oacute;rficos</em>, 
  ya que un mismo operador se puede emplear para acceder a distintos tipos de 
  datos. Por ejemplo, un operador <em>add</em> utilizado para a&ntilde;adir un 
  elemento, podr&aacute; ser empleado tanto si estamos trabajando con una lista 
  enlazada, con un array, o con un conjunto por ejemplo. </p>

<p>Este <em>polimorfismo</em> se debe a la definici&oacute;n de interfaces que 
  deben implementar los distintos tipos de datos. Siempre que el tipo de datos 
  contenga una colecci&oacute;n de elementos, implementar&aacute; la interfaz 
  <strong>Collection</strong>. Esta interfaz proporciona m&eacute;todos para acceder a la 
  colecci&oacute;n de elementos, que podremos utilizar para cualquier tipo de 
  datos que sea una colecci&oacute;n de elementos, independientemente de su implementaci&oacute;n 
  concreta.</p>

<p>Podemos encontrar los siguientes elementos dentro del marco de colecciones 
  de Java:</p>

<ul>
  
<li>Interfaces para distintos tipos de datos: Definir&aacute;n las operaciones 
    que se pueden realizar con dichos tipos de datos. Podemos encontrar aqu&iacute; 
    la interfaz para cualquier colecci&oacute;n de datos, y de manera m&aacute;s 
    concreta para listas (secuencias) de datos, conjuntos, etc.</li>
  
<li>Implementaciones de tipos de datos reutilizables: Son clases que implementan 
    tipos de datos concretos que podremos utilizar para nuestras aplicaciones, 
    implementando algunas de las interfaces anteriores para acceder a los elementos 
    de dicho tipo de datos. Por ejemplo, dentro de las listas de elementos, podremos 
    encontrar distintas implementaciones de la lista como puede ser listas enlazadas, 
    o bien arrays de capacidad variable, pero al implementar la misma interfaz 
    podremos acceder a sus elementos mediante las mismas operaciones (polimorfismo).</li>
  
<li>Algoritmos para trabajar con dichos tipos de datos, que nos permitan realizar 
    una ordenaci&oacute;n de los elementos de una lista, o diversos tipos de b&uacute;squeda 
    de un determinado elemento por ejemplo.</li>

</ul>


<a name="N10030"></a><a name="Colecciones"></a>
<h2 class="underlined_10">Colecciones</h2>
<div class="section">
<p>Las colecciones representan grupos de objetos, denominados elementos. Podemos 
  encontrar diversos tipos de colecciones, seg&uacute;n si sus elementos est&aacute;n 
  ordenados, o si permitimos repetici&oacute;n de elementos o no.</p>
<p>Es el tipo m&aacute;s gen&eacute;rico en cuanto a que se refiere a cualquier 
  tipo que contenga un grupo de elementos. Viene definido por la interfaz <strong>Collection</strong>, 
  de la cual heredar&aacute; cada subtipo espec&iacute;fico. En esta interfaz 
  encontramos una serie de m&eacute;todos que nos servir&aacute;n para acceder 
  a los elementos de cualquier colecci&oacute;n de datos, sea del tipo que sea. 
  Estos m&eacute;todos generales son:</p>
<pre class="code">boolean <strong>add(Object o)</strong>
</pre>
<p>A&ntilde;ade un elemento (objeto) a la colecci&oacute;n. Nos devuelve<em> true</em> 
  si tras a&ntilde;adir el elemento la colecci&oacute;n ha cambiado, es decir, 
  el elemento se ha a&ntilde;adido correctamente, o <em>false</em> en caso contrario.</p>
<pre class="code">void <strong>clear()</strong>
</pre>
<p>Elimina todos los elementos de la colecci&oacute;n.</p>
<pre class="code">boolean <strong>contains(Object o)</strong>
</pre>
<p>Indica si la colecci&oacute;n contiene el elemento (objeto) indicado.</p>
<pre class="code">boolean <strong>isEmpty()</strong>
</pre>
<p>Indica si la colecci&oacute;n est&aacute; vac&iacute;a (no tiene ning&uacute;n 
  elemento). </p>
<pre class="code">Iterator <strong>iterator()</strong>
</pre>
<p>Proporciona un iterador para acceder a los elementos de la colecci&oacute;n.</p>
<pre class="code">boolean <strong>remove(Object o)</strong>
</pre>
<p>Elimina un determinado elemento (objeto) de la colecci&oacute;n, devolviendo 
  <em>true</em> si dicho elemento estaba contenido en la colecci&oacute;n, y <em>false</em> 
  en caso contrario.</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Nos devuelve el n&uacute;mero de elementos que contiene la colecci&oacute;n.</p>
<pre class="code">Object [] <strong>toArray()</strong>
</pre>
<p>Nos devuelve la colecci&oacute;n de elementos como un array de objetos. Si 
  sabemos de antemano que los objetos de la colecci&oacute;n son todos de un determinado 
  tipo (como por ejemplo de tipo <strong>String</strong>) podremos obtenerlos en un array 
  del tipo adecuado, en lugar de usar un array de objetos gen&eacute;ricos. En 
  este caso NO podremos hacer una conversi&oacute;n cast descendente de array 
  de objetos a array de un tipo m&aacute;s concreto, ya que el array se habr&aacute; 
  instanciado simplemente como array de objetos:</p>
<pre class="code">// <strong>Esto no se puede hacer!!!</strong>
String [] cadenas = (String []) coleccion.toArray();</pre>
<p>Lo que si podemos hacer es instanciar nosotros un array del tipo adecuado y 
  hacer una conversi&oacute;n cast ascendente (de tipo concreto a array de objetos), 
  y utilizar el siguiente m&eacute;todo:</p>
<pre class="code">String [] cadenas = new String[coleccion.size()];
coleccion.<strong>toArray</strong>(cadenas);		// Esto si que funcionar&aacute;</pre>
<p>Esta interfaz es muy gen&eacute;rica, y por lo tanto no hay ning&uacute;n tipo 
  de datos que la implemente directamente, sino que implementar&aacute;n subtipos 
  de ellas. A continuaci&oacute;n veremos los subtipos m&aacute;s comunes.</p>
<a name="N100AA"></a><a name="Listas+de+elementos"></a>
<h3 class="underlined_5">Listas de elementos</h3>
<p>Este tipo de colecci&oacute;n se refiere a listas en las que los elementos 
  de la colecci&oacute;n tienen un orden, existe una secuencia de elementos. En 
  ellas cada elemento estar&aacute; en una determinada posici&oacute;n (&iacute;ndice) 
  de la lista.</p>
<p>Las listas vienen definidas en la interfaz <strong>List</strong>, que adem&aacute;s 
  de los m&eacute;todos generales de las colecciones, nos ofrece los siguientes 
  para trabajar con los &iacute;ndices:</p>
<pre class="code">void <strong>add(int indice, Object obj)</strong>
</pre>
<p>Inserta un elemento (objeto) en la posici&oacute;n de la lista dada por el 
  &iacute;ndice indicado. </p>
<pre class="code">Object <strong>get(int indice)</strong>
</pre>
<p>Obtiene el elemento (objeto) de la posici&oacute;n de la lista dada por el 
  &iacute;ndice indicado. </p>
<pre class="code">int <strong>indexOf(Object obj)</strong>
</pre>
<p>Nos dice cual es el &iacute;ndice de dicho elemento (objeto) dentro de la lista. 
  Nos devuelve -1 si el objeto no se encuentra en la lista.</p>
<pre class="code">Object <strong>remove(int indice)</strong>
</pre>
<p>Elimina el elemento que se encuentre en la posici&oacute;n de la lista indicada 
  mediante dicho &iacute;ndice, devolvi&eacute;ndonos el objeto eliminado.</p>
<pre class="code">Object <strong>set(int indice, Object obj)</strong>
</pre>
<p>Establece el elemento de la lista en la posici&oacute;n dada por el &iacute;ndice 
  al objeto indicado, sobrescribiendo el objeto que hubiera anteriormente en dicha 
  posici&oacute;n. Nos devolver&aacute; el elemento que hab&iacute;a previamente 
  en dicha posici&oacute;n.</p>
<p>Podemos encontrar diferentes implementaciones de listas de elementos en Java:</p>
<p>
<strong>ArrayList</strong>
</p>
<p>Implementa una lista de elementos mediante un array de tama&ntilde;o variable. 
  Conforme se a&ntilde;aden elementos el tama&ntilde;o del array ir&aacute; creciendo 
  si es necesario. El array tendr&aacute; una capacidad inicial, y en el momento 
  en el que se rebase dicha capacidad, se aumentar&aacute; el tama&ntilde;o del 
  array.</p>
<p>Las operaciones de a&ntilde;adir un elemento al final del array (<em>add</em>), 
  y de establecer u obtener el elemento en una determinada posici&oacute;n (<em>get</em>/<em>set</em>) 
  tienen un coste temporal constante. Las inserciones y borrados tienen un coste 
  lineal <em>O(n)</em>, donde <em>n</em> es el n&uacute;mero de elementos del 
  array.</p>
<p>Hemos de destacar que la implementaci&oacute;n de <strong>ArrayList</strong> 
  no est&aacute; sincronizada, es decir, si m&uacute;ltiples hilos acceden a un 
  mismo <strong>ArrayList</strong> concurrentemente podriamos tener problemas 
  en la consistencia de los datos. Por lo tanto, deberemos tener en cuenta cuando 
  usemos este tipo de datos que debemos controlar la concurrencia de acceso. Tambi&eacute;n 
  podemos hacer que sea sincronizado como veremos m&aacute;s adelante.</p>
<p>
<strong>Vector</strong>
</p>
<p>El <strong>Vector</strong> es una implementaci&oacute;n similar al <strong>ArrayList</strong>, 
  con la diferencia de que el <strong>Vector</strong> si que <strong>est&aacute; 
  sincronizado</strong>. Este es un caso especial, ya que la implementaci&oacute;n 
  b&aacute;sica del resto de tipos de datos no est&aacute; sincronizada.</p>
<p>Esta clase existe desde las primeras versiones de Java, en las que no exist&iacute;a 
  el marco de las colecciones descrito anteriormente. En las &uacute;ltimas versiones 
  el <strong>Vector</strong> se ha acomodado a este marco implementando la interfaz 
  <strong>List</strong>.</p>
<p>Sin embargo, si trabajamos con versiones previas de JDK, hemos de tener en 
  cuenta que dicha interfaz no exist&iacute;a, y por lo tanto esta versi&oacute;n 
  previa del vector no contar&aacute; con los m&eacute;todos definidos en ella. 
  Los m&eacute;todos propios del vector para acceder a su contenido, que han existido 
  desde las primeras versiones, son los siguientes:</p>
<pre class="code">void <strong>addElement(Object obj)</strong>
</pre>
<p>A&ntilde;ade un elemento al final del vector.</p>
<pre class="code">Object <strong>elementAt(int indice)</strong>
</pre>
<p>Devuelve el elemento de la posici&oacute;n del vector indicada por el &iacute;ndice.</p>
<pre class="code">void <strong>insertElementAt(Object obj, int indice)</strong>
</pre>
<p>Inserta un elemento en la posici&oacute;n indicada.</p>
<pre class="code">boolean <strong>removeElement(Object obj)</strong>
</pre>
<p>Elimina el elemento indicado del vector, devolviendo <em>true</em> si dicho 
  elemento estaba contenido en el vector, y <em>false</em> en caso contrario.</p>
<pre class="code">void <strong>removeElementAt(int indice)</strong>
</pre>
<p>Elimina el elemento de la posici&oacute;n indicada en el &iacute;ndice.</p>
<pre class="code">void <strong>setElementAt(Object obj, int indice)</strong>
</pre>
<p>Sobrescribe el elemento de la posici&oacute;n indicada con el objeto especificado.</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Devuelve el n&uacute;mero de elementos del vector.</p>
<p>Por lo tanto, si programamos para versiones antiguas de la m&aacute;quina virtual 
  Java, ser&aacute; recomendable utilizar estos m&eacute;todos para asegurarnos 
  de que nuestro programa funcione. Esto ser&aacute; importante en la programaci&oacute;n 
  de Applets, ya que la m&aacute;quina virtual incluida en muchos navegadores 
  corresponde a versiones antiguas.</p>
<p>Sobre el vector se construye el tipo pila (<strong>Stack</strong>), que apoy&aacute;ndose 
  en el tipo vector ofrece m&eacute;todos para trabajar con dicho vector como 
  si se tratase de una pila, apilando y desapilando elementos (operaciones <em>push 
  </em>y<em> pop</em> respectivamente). La clase <strong>Stack</strong> hereda 
  de <strong>Vector</strong>, por lo que en realidad ser&aacute; un vector que 
  ofrece m&eacute;todos adicionales para trabajar con &eacute;l como si fuese 
  una pila.</p>
<p>
<strong>LinkedList</strong>
</p>
<p>En este caso se implementa la lista mediante una lista doblemente enlazada. 
  Por lo tanto, el coste temporal de las operaciones ser&aacute; el de este tipo 
  de listas. Cuando realicemos inserciones, borrados o lecturas en los extremos 
  inicial o final de la lista el tiempo ser&aacute; constante, mientras que para 
  cualquier operaci&oacute;n en la que necesitemos localizar un determinado &iacute;ndice 
  dentro de la lista deberemos recorrer la lista de inicio a fin, por lo que el 
  coste ser&aacute; lineal con el tama&ntilde;o de la lista <em>O(n)</em>, siendo 
  <em>n </em>el tama&ntilde;o de la lista.</p>
<p>Para aprovechar las ventajas que tenemos en el coste temporal al trabajar con 
  los extremos de la lista, se proporcionan m&eacute;todos propios para acceder 
  a ellos en tiempo constante:</p>
<pre class="code">void <strong>addFirst(Object obj)</strong> / void <strong>addLast(Object obj)</strong>
</pre>
<p>A&ntilde;ade el objeto indicado al principio / final de la lista respectivamente.</p>
<pre class="code">Object <strong>getFirst()</strong> / Object <strong>getLast()</strong>
</pre>
<p>Obtiene el primer / &uacute;ltimo objeto de la lista respectivamente.</p>
<pre class="code">Object <strong>removeFirst()</strong> / Object <strong>removeLast()</strong>
</pre>
<p>Extrae el primer / &uacute;ltimo elemento de la lista respectivamente, devolvi&eacute;ndonos 
  dicho objeto y elimin&aacute;ndolo de la lista.</p>
<p>Hemos de destacar que estos m&eacute;todos nos permitir&aacute;n trabajar con 
  la lista como si se tratase de una pila o de una cola. En el caso de la pila 
  realizaremos la inserci&oacute;n y la extracci&oacute;n de elementos por el 
  mismo extremo, mientras que para la cola insertaremos por un extremo y extraeremos 
  por el otro.</p>
<a name="N101BC"></a><a name="Conjuntos"></a>
<h3 class="underlined_5">Conjuntos</h3>
<p>Los conjuntos son grupos de elementos en los que no encontramos ning&uacute;n 
  elemento repetido. Consideramos que un elemento est&aacute; repetido si tenemos 
  dos objetos <em>o1</em> y <em>o2</em> iguales, comparandolos mediante el operador 
  <em>o1.equals(o2)</em>. De esta forma, si el objeto a insertar en el conjunto 
  estuviese repetido, no nos dejar&aacute; insertarlo. Recordemos que el m&eacute;todo 
  add devolv&iacute;a un valor <em>booleano</em>, que servir&aacute; para este 
  caso, devolviendonos <em>true</em> si el elemento a a&ntilde;adir no estaba 
  en el conjunto y ha sido a&ntilde;adido, o <em>false</em> si el elemento ya 
  se encontraba dentro del conjunto. Un conjunto podr&aacute; contener a lo sumo 
  un elemento <em>null</em>.</p>
<p>Los conjuntos se definen en la interfaz <strong>Set</strong>, a partir de la 
  cu&aacute;l se construyen diferentes implementaciones:</p>
<p>
<strong>HashSet</strong> 
</p>
<p>Los objetos se almacenan en una tabla de dispersi&oacute;n (<em>hash</em>). 
  El coste de las operaciones b&aacute;sicas (inserci&oacute;n, borrado, b&uacute;squeda) 
  se realizan en tiempo constante siempre que los elementos se hayan dispersado 
  de forma adecuada. La iteraci&oacute;n a trav&eacute;s de sus elementos es m&aacute;s 
  costosa, ya que necesitar&aacute; recorrer todas las entradas de la tabla de 
  dispersi&oacute;n, lo que har&aacute; que el coste est&eacute; en funci&oacute;n 
  tanto del n&uacute;mero de elementos insertados en el conjunto como del n&uacute;mero 
  de entradas de la tabla. El orden de iteraci&oacute;n puede diferir del orden 
  en el que se insertaron los elementos.</p>
<p>
<strong>LinkedHashSet</strong> 
</p>
<p>Es similar a la anterior pero la tabla de dispersi&oacute;n es doblemente enlazada. 
  Los elementos que se inserten tendr&aacute;n enlaces entre ellos. Por lo tanto, 
  las operaciones b&aacute;sicas seguir&aacute;n teniendo coste constante, con 
  la carga adicional que supone tener que gestionar los enlaces. Sin embargo habr&aacute; 
  una mejora en la iteraci&oacute;n, ya que al establecerse enlaces entre los 
  elementos no tendremos que recorrer todas las entradas de la tabla, el coste 
  s&oacute;lo estar&aacute; en funci&oacute;n del n&uacute;mero de elementos insertados. 
  En este caso, al haber enlaces entre los elementos, estos enlaces definir&aacute;n 
  el orden en el que se insertaron en el conjunto, por lo que el orden de iteraci&oacute;n 
  ser&aacute; el mismo orden en el que se insertaron.</p>
<p>
<strong>TreeSet</strong> 
</p>
<p>Utiliza un &aacute;rbol para el almacenamiento de los elementos. Por lo tanto, 
  el coste para realizar las operaciones b&aacute;sicas ser&aacute; logar&iacute;tmico 
  con el n&uacute;mero de elementos que tenga el conjunto <em>O(log n)</em>.</p>
<a name="N101FF"></a><a name="Mapas"></a>
<h3 class="underlined_5">Mapas</h3>
<p>Aunque muchas veces se hable de los mapas como una colecci&oacute;n, en realidad 
  no lo son, ya que no heredan de la interfaz <strong>Collection</strong>.</p>
<p>Los mapas se definen en la interfaz <strong>Map</strong>. Un mapa es un objeto 
  que relaciona una clave (<em>key</em>) con un valor. Contendr&aacute; un conjunto 
  de claves, y a cada clave se le asociar&aacute; un determinado valor. En versiones 
  anteriores este mapeado entre claves y valores lo hac&iacute;a la clase <strong>Dictionary</strong>, 
  que ha quedado obsoleta. Tanto la clave como el valor puede ser cualquier objeto.</p>
<p>Los m&eacute;todos b&aacute;sicos para trabajar con estos elementos son los 
  siguientes:</p>
<pre class="code">Object <strong>get(Object clave)</strong>
</pre>
<p>Nos devuelve el valor asociado a la clave indicada</p>
<pre class="code">Object <strong>put(Object clave, Object valor)</strong>
</pre>
<p>Inserta una nueva clave con el valor especificado. Nos devuelve el valor que 
  ten&iacute;a antes dicha clave, o <em>null</em> si la clave no estaba en la 
  tabla todav&iacute;a.</p>
<pre class="code">Object <strong>remove(Object clave)</strong>
</pre>
<p>Elimina una clave, devolviendonos el valor que ten&iacute;a dicha clave.</p>
<pre class="code">Set <strong>keySet()</strong>
</pre>
<p>Nos devuelve el conjunto de claves registradas</p>
<pre class="code">int <strong>size()</strong>
</pre>
<p>Nos devuelve el n&uacute;mero de parejas (clave,valor) registradas.</p>
<p>Encontramos distintas implementaciones de los mapas:</p>
<p>
<strong>HashMap</strong>
</p>
<p>Utiliza una tabla de dispersi&oacute;n para almacenar la informaci&oacute;n 
  del mapa. Las operaciones b&aacute;sicas (<em>get</em> y <em>put</em>) se har&aacute;n 
  en tiempo constante siempre que se dispersen adecuadamente los elementos. Es 
  coste de la iteraci&oacute;n depender&aacute; del n&uacute;mero de entradas 
  de la tabla y del n&uacute;mero de elementos del mapa. No se garantiza que se 
  respete el orden de las claves.</p>
<p>
<strong>TreeMap</strong>
</p>
<p>Utiliza un &aacute;rbol rojo-negro para implementar el mapa. El coste de las 
  operaciones b&aacute;sicas ser&aacute; logar&iacute;tmico con el n&uacute;mero 
  de elementos del mapa <em>O(log n)</em>. En este caso los elementos se encontrar&aacute;n 
  ordenados por orden ascendente de clave.</p>
<p>
<strong>Hashtable</strong>
</p>
<p>Es una implementaci&oacute;n similar a <strong>HashMap</strong>, pero con alguna 
  diferencia. Mientras las anteriores implementaciones no est&aacute;n sincronizadas, 
  esta si que lo est&aacute;. Adem&aacute;s en esta implementaci&oacute;n, al 
  contrario que las anteriores, no se permitir&aacute;n claves nulas (<em>null</em>). 
  Este objeto extiende la obsoleta clase <strong>Dictionary</strong>, ya que viene 
  de versiones m&aacute;s antiguas de JDK. Ofrece otros m&eacute;todos adem&aacute;s 
  de los anteriores, como por ejemplo el siguiente:</p>
<pre class="code">Enumeration <strong>keys()</strong>
</pre>
<p>Este m&eacute;todo nos devolver&aacute; una enumeraci&oacute;n de todas las 
  claves registradas en la tabla.</p>
<a name="N1027E"></a><a name="Wrappers"></a>
<h3 class="underlined_5">Wrappers</h3>
<p>La clase <strong>Collections</strong> 
  aporta una serie m&eacute;todos para cambiar ciertas propiedades de las listas. 
  Estos m&eacute;todos nos proporcionan los denominados <em>wrappers</em> de los 
  distintos tipos de colecciones. Estos <em>wrappers</em> son objetos que 'envuelven' 
  al objeto de nuestra colecci&oacute;n, pudiendo de esta forma hacer que la colecci&oacute;n 
  est&eacute; sincronizada, o que la colecci&oacute;n pase a ser de solo lectura.</p>
<p>Como dijimos anteriormente, todos los tipos de colecciones no est&aacute;n 
  sincronizados, excepto el <strong>Vector</strong> que es un caso especial. Al no estar 
  sincronizados, si m&uacute;ltiples hilos utilizan la colecci&oacute;n concurrentemente, 
  podr&aacute;n estar ejecut&aacute;ndose simult&aacute;neamente varios m&eacute;todos 
  de una misma colecci&oacute;n que realicen diferentes operaciones sobre ella. 
  Esto puede provocar inconsistencias en los datos. A continuaci&oacute;n veremos 
  un posible ejemplo de inconsistencia que se podr&iacute;a producir:</p>
<ol>
  
<li>Tenemos un <strong>ArrayList</strong> de nombre <em>letras</em> formada 
    por los siguiente elementos: [ "A", "B", "C", 
    "D" ]</li>
  
<li>Imaginemos que un hilo de baja prioridad desea eliminar el objeto "C". 
    Para ello har&aacute; una llamada al m&eacute;todo <em>letras.remove("C")</em>.</li>
  
<li>Dentro de este m&eacute;todo primero deber&aacute; determinar cu&aacute;l 
    es el &iacute;ndice de dicho objeto dentro del array, para despu&eacute;s 
    pasar a eliminarlo. </li>
  
<li>Se encuentra el objeto "C" en el &iacute;ndice 2 del array (recordemos 
    que se empieza a numerar desde 0).</li>
  
<li>El problema viene en este momento. Imaginemos que justo en este momento 
    se le asigna el procesador a un hilo de mayor prioridad, que se encarga de 
    eliminar el elemento "A" del array, qued&aacute;ndose el array de 
    la siguiente forma: [ "B", "C", "D" ]</li>
  
<li>Ahora el hilo de mayor prioridad es sacado del procesador y nuestro hilo 
    sigue ejecut&aacute;ndose desde el punto en el que se qued&oacute;.</li>
  
<li>Ahora nuestro hilo lo &uacute;nico que tiene que hacer es eliminar el elemento 
    del &iacute;ndice que hab&iacute;a determinado, que resulta ser &iexcl;el 
    &iacute;ndice 2!. Ahora el &iacute;ndice 2 est&aacute; ocupado por el objeto 
    "D", y por lo tanto ser&aacute; dicho objeto el que se elimine.</li>

</ol>
<p>Podemos ver que haciendo una llamada a <em>letras.remove("C")</em>, 
  al final se ha eliminado el objeto "D", lo cual produce una inconsistencia 
  de los datos con las operaciones realizadas, debido al acceso concurrente.</p>
<p>Este problema lo evitaremos sincronizando la colecci&oacute;n. Cuando una colecci&oacute;n 
  est&aacute; sincronizada, hasta que no termine de realizarse una operaci&oacute;n 
  (inserciones, borrados, etc), no se podr&aacute; ejecutar otra, lo cual evitar&aacute; 
  estos problemas.</p>
<p>Podemos conseguir que las operaciones se ejecuten de forma sincronizada envolviendo 
  nuestro objeto de la colecci&oacute;n con un <em>wrapper</em>, que ser&aacute; 
  un objeto que utilice internamente nuestra colecci&oacute;n encarg&aacute;ndose 
  de realizar la sincronizaci&oacute;n cuando llamemos a sus m&eacute;todos. Para 
  obtener estos <em>wrappers</em> utilizaremos los siguientes m&eacute;todos est&aacute;ticos 
  de <strong>Collections</strong>:</p>
<pre class="code">Collection <strong>synchronizedCollection(Collection c)</strong>
List <strong>synchronizedList(List l)</strong>
Set <strong>synchronizedSet(Set s)</strong>
Map <strong>synchronizedMap(Map m)</strong>
SortedSet <strong>synchronizedSortedSet(SortedSet ss)</strong>
SortedMap <strong>synchronizedSortedMap(SortedMap sm)</strong>
</pre>
<p>Como vemos tenemos un m&eacute;todo para envolver cada tipo de datos. Nos devolver&aacute; 
  un objeto con la misma interfaz, por lo que podremos trabajar con &eacute;l 
  de la misma forma, sin embargo la implementaci&oacute;n interna estar&aacute; 
  sincronizada.</p>
<p>Podemos encontrar tambi&eacute;n una serie de <em>wrappers</em> para obtener 
  versiones de s&oacute;lo lectura de nuestras colecciones. Se obtienen con los 
  siguientes m&eacute;todos:</p>
<pre class="code">Collection <strong>unmodifiableCollection(Collection c)</strong>
List <strong>unmodifiableList(List l)</strong>
Set <strong>unmodifiableSet(Set s)</strong>
Map <strong>unmodifiableMap(Map m)</strong>
SortedSet <strong>unmodifiableSortedSet(SortedSet ss)</strong>
SortedMap <strong>unmodifiableSortedMap(SortedMap sm)</strong>
</pre>
<a name="N10300"></a><a name="Gen%C3%A9ricos"></a>
<h3 class="underlined_5">Gen&eacute;ricos</h3>
<p>Podemos tener colecciones de tipos concretos de datos, lo
        que permite asegurar que los datos que se van a almacenar van a ser
        compatibles con un determinado tipo o tipos. Por ejemplo, podemos crear
        un <span class="codefrag">ArrayList</span> que s&oacute;lo almacene <span class="codefrag">Strings</span>, o una <span class="codefrag">HashMap</span>
        que tome como claves <span class="codefrag">Integers</span> y como valores <span class="codefrag">ArrayLists</span>. Adem&aacute;s,
        con esto nos ahorramos las conversiones <em>cast</em> al tipo que
        deseemos, puesto que la colecci&oacute;n ya se asume que ser&aacute; de dicho tipo.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="code">
<strong>// Vector de cadenas</strong>
ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
a.add("Hola");
String s = a.get(0);
a.add(new Integer(20));			// Dar&iacute;a error!!

<strong>// HashMap con claves enteras y valores de vectores</strong>
HashMap&lt;Integer, ArrayList&gt; hm = new HashMap&lt;Integer, ArrayList&gt;();
hm.put(1, a);
ArrayList a2 = hm.get(1);</pre>
<p>A partir de JDK 1.5 deberemos utilizar gen&eacute;ricos siempre que sea posible. Si
creamos una colecci&oacute;n sin especificar el tipo de datos que contendr&aacute; normalmente
obtendremos un <em>warning</em>.</p>
<p>Los gen&eacute;ricos no son una caracter&iacute;stica exclusiva de las colecciones, 
sino que se pueden utilizar en muchas otras clases, incluso podemos parametrizar
de esta forma nuestras propias clases.</p>
<a name="N10332"></a><a name="Recorrer+las+colecciones"></a>
<h3 class="underlined_5">Recorrer las colecciones</h3>
<p>Vamos a ver ahora como podemos iterar por los elementos de una colecci&oacute;n 
de forma eficiente y segura, evitando salirnos del rango de datos. Dos elementos utilizados comunmente 
  para ello son las enumeraciones y los iteradores. </p>
<p>Las enumeraciones, definidas mediante la interfaz <strong>Enumeration</strong>, 
  nos permiten consultar los elementos que contiene una colecci&oacute;n de datos. 
  Muchos m&eacute;todos de clases Java que deben devolver m&uacute;ltiples valores, 
  lo que hacen es devolvernos una enumeraci&oacute;n que podremos consultar mediante 
  los m&eacute;todos que ofrece dicha interfaz.</p>
<p>La enumeraci&oacute;n ir&aacute; recorriendo secuencialmente los elementos 
  de la colecci&oacute;n. Para leer cada elemento de la enumeraci&oacute;n deberemos 
  llamar al m&eacute;todo:</p>
<pre class="code">Object item = enum.<strong>nextElement()</strong>;</pre>
<p>Que nos proporcionar&aacute; en cada momento el siguiente elemento de la enumeraci&oacute;n 
  a leer. Adem&aacute;s necesitaremos saber si quedan elementos por leer, para 
  ello tenemos el m&eacute;todo:</p>
<pre class="code">enum.<strong>hasMoreElements()</strong>
</pre>
<p>Normalmente, el bucle para la lectura de una enumeraci&oacute;n ser&aacute; 
  el siguiente:</p>
<pre class="code">while (enum.<strong>hasMoreElements()</strong>) {
  Object item = enum.<strong>nextElement()</strong>;
  // Hacer algo con el item leido
}</pre>
<p>Vemos como en este bucle se van leyendo y procesando elementos de la enumeraci&oacute;n 
  uno a uno mientras queden elementos por leer en ella.</p>
<p>Otro elemento para acceder a los datos de una colecci&oacute;n son los iteradores. 
  La diferencia est&aacute; en que los iteradores adem&aacute;s de leer los datos 
  nos permitir&aacute;n eliminarlos de la colecci&oacute;n. Los iteradores se 
  definen mediante la interfaz<strong> Iterator</strong>, que proporciona de forma 
  an&aacute;loga a la enumeraci&oacute;n el m&eacute;todo:</p>
<pre class="code">Object item = iter.<strong>next()</strong>;</pre>
<p>Que nos devuelve el siguiente elemento a leer por el iterador, y para saber 
  si quedan m&aacute;s elementos que leer tenemos el m&eacute;todo:</p>
<pre class="code">iter.<strong>hasNext()</strong>
</pre>
<p>Adem&aacute;s, podemos borrar el &uacute;ltimo elemento que hayamos leido. 
  Para ello tendremos el m&eacute;todo:</p>
<pre class="code">iter.<strong>remove()</strong>;</pre>
<p>Por ejemplo, podemos recorrer todos los elementos de una colecci&oacute;n utilizando 
  un iterador y eliminar aquellos que cumplan ciertas condiciones:</p>
<pre class="code">while (iter.<strong>hasNext()</strong>)
{ 
	Object item = iter.<strong>next()</strong>;
	if(condicion_borrado(item)) 
		iter.<strong>remove()</strong>;
}</pre>
<p>Las enumeraciones y los iteradores no son tipos de datos, sino elementos que 
  nos servir&aacute;n para acceder a los elementos dentro de los diferentes tipos de colecciones.</p>
<p>A partir de JDK 1.5 podemos recorrer colecciones y arrays sin
        necesidad de acceder a sus iteradores,
        previniendo &iacute;ndices fuera de rango.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="code">
<strong>// Recorre e imprime todos los elementos de un array</strong>
int[] arrayInt = {1, 20, 30, 2, 3, 5};
for(int elemento: arrayInt)
	System.out.println (elemento);

<strong>// Recorre e imprime todos los elementos de un </strong><strong>ArrayList</strong>
ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
for(String cadena: a)
	System.out.println (cadena);</pre>
</div>


<a name="N103AB"></a><a name="Polimorfismo+e+interfaces"></a>
<h2 class="underlined_10">Polimorfismo e interfaces</h2>
<div class="section">
<p>En Java podemos conseguir tener objetos polim&oacute;rficos mediante la implementaci&oacute;n
de interfaces. Un claro ejemplo est&aacute; en las colecciones vistas anteriormente. 
Por ejemplo, todos los tipos de listas implementan la interfaz <span class="codefrag">List</span>.
De esta forma, en un m&eacute;todo que acepte como entrada un objeto de tipo <span class="codefrag">List</span>
podremos utilizar cualquier tipo que implemente esta interfaz, independientemente
del tipo concreto del que se trate.</p>
<p>Es por lo tanto recomendable hacer referencia siempre a estos objetos mediante
la interfaz que implementa, y no por su tipo concreto. De esta forma posteriormente
podr&iacute;amos cambiar la implementaci&oacute;n del tipo de datos sin que afecte al resto del programa. 
Lo &uacute;nico que tendremos que cambiar es el momento en el que se instancia.</p>
<p>Por ejemplo, si tenemos una clase <span class="codefrag">Cliente</span> que contiene una serie 
de cuentas, tendremos algo como:</p>
<pre class="code">public class Cliente {
    String nombre;
    List&lt;Cuenta&gt; cuentas;
    
    public Cliente(String nombre) {
        this.nombre = nombre;
        this.cuentas = new ArrayList&lt;Cuenta&gt;();
    }

    public List&lt;Cuenta&gt; getCuentas() {
        return cuentas;
    }

    public void setCuentas(List&lt;Cuenta&gt; cuentas) {
        this.cuentas = cuentas;
    }

    public void addCuenta(Cuenta cuenta) {
        this.cuentas.add(cuenta);
    }
}</pre>
<p>Si posteriormente queremos cambiar la implementaci&oacute;n de la lista a
<span class="codefrag">LinkedList</span> por ejemplo, s&oacute;lo tendremos que cambiar la l&iacute;nea
del constructor en la que se hace la instanciaci&oacute;n.</p>
<p>Como ejemplo de la utilidad que tiene el polimorfismo podemos ver los algoritmos
predefinidos con los que contamos en el marco de colecciones.</p>
<a name="N103D0"></a><a name="Ejemplo%3A+Algoritmos"></a>
<h3 class="underlined_5">Ejemplo: Algoritmos</h3>
<p>Como hemos comentado anteriormente, adem&aacute;s de las interfaces y las implementaciones 
  de los tipos de datos descritos en los apartados previos, el marco de colecciones 
  nos ofrece una serie de algoritmos utiles cuando trabajamos con estos tipos 
  de datos, especialmente para las listas.</p>
<p>Estos algoritmos los podemos encontrar implementados como m&eacute;todos est&aacute;ticos 
  en la clase <strong>Collections</strong>. En ella encontramos m&eacute;todos 
  para la ordenaci&oacute;n de listas (<em>sort</em>), para la b&uacute;squeda 
  binaria de elementos dentro de una lista (<em>binarySearch</em>) y otras operaciones 
  que nos ser&aacute;n de gran utilidad cuando trabajemos con colecciones de elementos.</p>
<p>Estos m&eacute;todos tienen como par&aacute;metro de entrada un objeto de tipo <span class="codefrag">List</span>. De esta forma, 
podremos utilizar estos algoritmos para cualquier tipo de lista.</p>
<a name="N103EC"></a><a name="Patr%C3%B3n+factor%C3%ADa"></a>
<h3 class="underlined_5">Patr&oacute;n factor&iacute;a</h3>
<p>Hemos comentado que el &uacute;nico lugar en el que tendremos que hacer referencia al tipo
concreto de datos utilizado es en el momento de su instanciaci&oacute;n. Sin embargo, 
podemos conseguir aislar nuestro programa de esta instanciaci&oacute;n concreta utilizando el
patr&oacute;n factor&iacute;a.</p>
<p>Esto se conseguir&aacute; creando una clase factor&iacute;a que ser&aacute; la que se encargue de
crear instancias de nuestro objeto. Es evidente que en ese caso la instancia 
concreta tendr&aacute; que crearse dentro de la factor&iacute;a, pero al menos hemos independizado el
resto del c&oacute;digo de nuestra aplicaci&oacute;n de esta tarea. En cualquier lugar en el que se
necesite instanciar nuestro tipo de objeto se recurrir&aacute; a la factor&iacute;a. De esta forma, si queremos
cambiar la forma de instanciar este objeto simplemente tendremos que modificar
el c&oacute;digo de la factor&iacute;a.</p>
<p>Por ejemplo, en el caso del ejemplo del cliente y las cuentas podr&iacute;amos crearnos
una factor&iacute;a como la siguiente:</p>
<pre class="code">public class FactoriaCuentas {
	private static FactoriaCuentas me = new FactoriaCuentas();

	private FactoriaCuentas() {
	}

	public static FactoriaCuentas getInstance() {
		return me;
	}

	public List&lt;Cuenta&gt; crearListaCuentas() {
		return new ArrayList&lt;Cuenta&gt;();
	}
}</pre>
<p>De esta forma podremos crear la lista de cuentas desde diferentes
lugares del c&oacute;digo, incluso desde clases distintas, con independencia de la 
instancia concreta que vaya a usarse. Por ejemplo, podremos tener
varios constructores de nuestra clase <span class="codefrag">Cliente</span> que
recurran a la factor&iacute;a para crear la instancia de la lista:</p>
<pre class="code">public Cliente() {
  this.nombre = "John Doe";
  this.cuentas = FactoriaCuentas.getInstance().crearListaCuentas();
}
    
public Cliente(String nombre) {
  this.nombre = nombre;
  this.cuentas = FactoriaCuentas.getInstance().crearListaCuentas();
}

public Cliente(String nombre, List&lt;Cuenta&gt; cuentas) {
  this.nombre = nombre;
  this.cuentas = FactoriaCuentas.getInstance().crearListaCuentas();
  this.cuentas.addAll(cuentas);
}
</pre>
</div>


<a name="N1040B"></a><a name="Tipos+de+datos"></a>
<h2 class="underlined_10">Tipos de datos</h2>
<div class="section">
<a name="N10411"></a><a name="Wrappers+de+tipos+b%C3%A1sicos"></a>
<h3 class="underlined_5">Wrappers de tipos b&aacute;sicos</h3>
<p>Hemos visto que en Java cualquier tipo de datos es un objeto, excepto los tipos 
  de datos b&aacute;sicos: <em>boolean, int, long, float, double, byte, short, 
  char</em>. </p>
<p>Cuando trabajamos con colecciones de datos los elementos que contienen &eacute;stas 
  son siempre objetos, por lo que en un principio no podr&iacute;amos insertar 
  elementos de estos tipos b&aacute;sicos. Para hacer esto posible tenemos una 
  serie de objetos que se encargar&aacute;n de envolver a estos tipos b&aacute;sicos, 
  permiti&eacute;ndonos tratarlos como objetos y por lo tanto insertarlos como 
  elementos de colecciones. Estos objetos son los llamados wrappers, y las clases 
  en las que se definen tienen nombre similares al del tipo b&aacute;sico que 
  encapsulan, con la diferencia de que comienzan con may&uacute;scula: <strong>Boolean, 
  Integer, Long, Float, Double, Byte, Short, Character</strong>.</p>
<p>Estas clases, adem&aacute;s de servirnos para encapsular estos datos b&aacute;sicos 
  en forma de objetos, nos proporcionan una serie de m&eacute;todos e informaci&oacute;n 
  &uacute;tiles para trabajar con estos datos. Nos proporcionar&aacute;n m&eacute;todos 
  por ejemplo para convertir cadenas a datos num&eacute;ricos de distintos tipos 
  y viceversa, as&iacute; como informaci&oacute;n acerca del valor m&iacute;nimo 
  y m&aacute;ximo que se puede representar con cada tipo num&eacute;rico.</p>
<a name="N10427"></a><a name="Autoboxing"></a>
<h3 class="underlined_5">Autoboxing</h3>
<p>Esta caracter&iacute;stica aparecida en JDK 1.5 evita al programador tener que establecer
        correspondencias manuales entre los tipos simples (<span class="codefrag">int</span>, <span class="codefrag">double</span>,
        etc) y sus correspondientes <em>wrappers</em> o tipos complejos (<span class="codefrag">Integer,
        Double, </span>etc). Podremos utilizar un <span class="codefrag">int</span> donde se espere un
        objeto complejo (<span class="codefrag">Integer</span>), y viceversa.</p>
<p>
<strong>Ejemplo</strong>
</p>
<pre class="code">ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
a.add(30);
Integer n = v.get(0);
n = n+1;
int num = n;</pre>
<a name="N1044B"></a><a name="Estructuras+de+datos"></a>
<h3 class="underlined_5">Estructuras de datos</h3>
<p>En nuestras aplicaciones normalmente trabajamos con diversos conjuntos
de atributos que son siempre utilizados de forma conjunta (por ejemplo, los
datos de un punto en un mapa: coordenada x, coordenada y, descripcion). Estos datos 
se deber&aacute;n ir pasando entre las diferentes capas de la aplicaci&oacute;n.</p>
<p>Podemos utilizar el patr&oacute;n <em>Transfer Object</em> para encapsular estos
datos en un objeto, y tratarlos as&iacute; de forma eficiente. Este objeto tendr&aacute; 
como campos los datos que encapsula. En el caso de que estos campos sean privados,
nos deber&aacute; proporcionar m&eacute;todos para acceder a ellos. Estos m&eacute;todos son 
conocidos como <em>getters</em> y <em>setters</em>, y nos permitir&aacute;n consultar o modificar
su valor respectivamente. Una vez escritos los campos privados, Eclipse puede generar los 
<em>getters</em> y <em>setters</em> de forma autom&aacute;tica pinchando sobre el c&oacute;digo fuente con el 
bot&oacute;n derecho del rat&oacute;n y seleccionando la opci&oacute;n <em>Source &gt; Generate Getters and Setters...</em>. 
Por ejemplo, si creamos una clase como la siguiente:</p>
<pre class="code">public class Punto2D {
	private int x;
	private int y;
	private String descripcion;
}</pre>
<p>Al generar los <em>getters</em> y <em>setters</em> con Eclipse aparecer&aacute;n los siguientes m&eacute;todos:</p>
<pre class="code">	public String getDescripcion() {
		return descripcion;
	}
	public void setDescripcion(String descripcion) {
		this.descripcion = descripcion;
	}
	public int getX() {
		return x;
	}
	public void setX(int x) {
		this.x = x;
	}
	public int getY() {
		return y;
	}
	public void setY(int y) {
		this.y = y;
	}</pre>
<p>Con Eclipse tambi&eacute;n podremos generar diferentes tipos de constructores
para estos objetos. Por ejemplo, con la opci&oacute;n <em>Source &gt; Generate Constructor Using Fields...</em>
generar&aacute; un constructor que tomar&aacute; como entrada los campos del objeto que le indiquemos.</p>
</div>







<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2008-2009 Depto. CCIA</div>
</div>
</body>
</html>
