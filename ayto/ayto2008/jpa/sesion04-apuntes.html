<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Mapeo entidad-relaci&oacute;n: relaciones</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="JPA con Hibernate" src="images/baner_j2ee_der.gif" title="JPA con Hibernate"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto SIGEM</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Persistencia</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">JPA</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="JPA">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 4</div>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="roadmap.html">Roadmap JPA</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion04-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Mapeo entidad-relaci&oacute;n: relaciones</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Conceptos+previos">Conceptos previos</a>
<ul class="minitoc">
<li>
<a href="#Direccionalidad">Direccionalidad</a>
</li>
<li>
<a href="#Cardinalidad">Cardinalidad</a>
</li>
<li>
<a href="#Entidad+propietaria+de+la+relaci%C3%B3n">Entidad propietaria de la relaci&oacute;n</a>
</li>
<li>
<a href="#Sincronizaci%C3%B3n+con+la+base+de+datos">Sincronizaci&oacute;n con la base de datos</a>
</li>
</ul>
</li>
<li>
<a href="#Definici%C3%B3n+de+relaciones">Definici&oacute;n de relaciones</a>
<ul class="minitoc">
<li>
<a href="#Relaci%C3%B3n+uno-a-uno+unidireccional">Relaci&oacute;n uno-a-uno unidireccional</a>
</li>
<li>
<a href="#Relaci%C3%B3n+uno-a-uno+bidireccional">Relaci&oacute;n uno-a-uno bidireccional</a>
</li>
<li>
<a href="#Relaci%C3%B3n+uno-a-muchos%2Fmuchos-a-uno+bidireccional">Relaci&oacute;n uno-a-muchos/muchos-a-uno bidireccional</a>
</li>
<li>
<a href="#Relaci%C3%B3n+muchos-a-uno+unidireccional">Relaci&oacute;n muchos-a-uno unidireccional</a>
</li>
<li>
<a href="#Relaci%C3%B3n+muchos-a-muchos+bidireccional">Relaci&oacute;n muchos-a-muchos bidireccional</a>
</li>
<li>
<a href="#Relaci%C3%B3n+muchos-a-muchos+unidireccional">Relaci&oacute;n muchos-a-muchos unidireccional</a>
</li>
</ul>
</li>
<li>
<a href="#Carga+perezosa">Carga perezosa</a>
</li>
</ul>
</div>	

<a name="N1000C"></a><a name="Conceptos+previos"></a>
<h2 class="underlined_10">Conceptos previos</h2>
<div class="section">
<p>Antes de comenzar a detallar los aspectos del mapeo de las relaciones entre entidades vamos a repasar algunos conceptos b&aacute;sicos y alguna terminolog&iacute;a. Es muy importante tener claro estos conceptos antes de intentar entender los entresijos a los que nos vamos a enfrentar m&aacute;s adelante.</p>
<p>Vamos a ilustrar estos conceptos con la relaci&oacute;n que vimos en la sesi&oacute;n 1. All&iacute; defin&iacute;amos dos entidades, <span class="codefrag">Autor</span> y <span class="codefrag">Mensaje</span> y una relaci&oacute;n muchos-a-uno bidireccional de <span class="codefrag">Mensaje</span> a <span class="codefrag">Autor</span>. Un autor puede escribir muchos mensajes.</p>
<p>La relaci&oacute;n la representamos con la figura siguiente, en donde se muestran las dos entidades unidas con una flecha con dos puntas que indica que la relaci&oacute;n es bidireccional y con la anotaci&oacute;n de la cardinalidad de cada entidad bajo la flecha.</p>
<p>
<img alt="" content-width="8cm" src="imagenes/mensaje-autor-entidad.png" width="414"></p>
<p>El modelo f&iacute;sico que se genera con el mapeado es el que se muestra en la siguiente figura. La tabla <span class="codefrag">MENSAJE</span> contiene una clave ajena hacia la tabla <span class="codefrag">AUTOR</span>, en su columna <span class="codefrag">AUTOR</span>. Los valores de esta columna guardan claves primarias de autores. De esta forma relacionamos cada mensaje con el autor que lo ha escrito. Cuando queramos obtener todos los mensajes de un determinado autor se deber&aacute; hacer un <span class="codefrag">SELECT</span> en la tabla <span class="codefrag">MENSAJE</span> buscando todas las filas que tengan como clave ajena el autor que buscamos.</p>
<p>
<img alt="" content-width="8cm" src="imagenes/mensaje-autor-tabla.png" width="411"></p>
<p>Vamos a ver las distintas caracter&iacute;sticas que hay que definir para especificar completamente una relaci&oacute;n en el modelo de entidades, utilizando como ejemplo esta relaci&oacute;n entre <span class="codefrag">Mensaje</span> y <span class="codefrag">Autor</span>.</p>
<a name="N10050"></a><a name="Direccionalidad"></a>
<h3 class="underlined_5">Direccionalidad</h3>
<p>En primer lugar debemos considerar la <em>direccionalidad</em> de la relaci&oacute;n. Nos indica si desde una entidad podemos obtener la otra. Una relaci&oacute;n puede ser <em>unidireccional</em> cuando desde la <em>entidad origen</em> se puede obtener la <em>entidad destino</em> o <em>bidireccional</em>, como es el caso del ejemplo, cuando desde ambas partes de la relaci&oacute;n se puede obtener la otra parte.</p>
<p>En un diagrama UML, la direccionalidad viene indicada por la direcci&oacute;n de la flecha. En el caso del ejemplo anterior tenemos una relaci&oacute;n bidireccional. Podemos pedirle a una instancia de <span class="codefrag">Mensaje</span> que nos diga con que <span class="codefrag">Autor</span> est&aacute; relacionado. En la entidad de <span class="codefrag">Mensaje</span> habr&aacute; un m&eacute;todo que devuelve el autor. Y al ser la relaci&oacute;n bidireccional podemos hacer lo mismo al rev&eacute;s, podemos pedirle a un <span class="codefrag">Autor</span> que nos diga con qu&eacute; <span class="codefrag">Mensaje</span>s est&aacute; relacionado. En la entidad <span class="codefrag">Autor</span> hay un m&eacute;todo que devuelve una colecci&oacute;n de mensajes. Por tanto, los m&eacute;todos definidos por la relaci&oacute;n son:</p>
<ul>
		
<li>En la entidad <span class="codefrag">Mensaje</span>: <span class="codefrag">public Autor getAutor()</span>
</li>
		
<li>En la entidad <span class="codefrag">Autor</span>: <span class="codefrag">public Collection&lt;Mensaje&gt; getMensajes()</span>&gt;</li>
	
</ul>
<p>Podr&iacute;amos haber escrito estos atributos en la figura anterior, en las entidades, como se muestra en la siguiente figura:</p>
<p>
<img alt="" content-width="9cm" src="imagenes/mensaje-autor-entidad2.png" width="461"></p>
<p>Ambos diagramas son equivalentes. El segundo proporciona m&aacute;s informaci&oacute;n porque indica el nombre que le damos a los atributos de la relaci&oacute;n.</p>
<a name="N1009F"></a><a name="Cardinalidad"></a>
<h3 class="underlined_5">Cardinalidad</h3>
<p>La cardinalidad de una relaci&oacute;n define el n&uacute;mero de instancias de una entidad que pueden estar relacionada con otras. Atendiendo a la cardinalidad, una relaci&oacute;n puede ser <em>uno-a-uno</em>, <em>uno-a-muchos</em>, <em>muchos-a-uno</em> o <em>muchos-a-muchos</em>.</p>
<p>En el caso del ejemplo tenemos una relaci&oacute;n muchos-a-uno entre <span class="codefrag">Mensaje</span> y <span class="codefrag">Autor</span>. Al ser una relaci&oacute;n bidireccional, tambi&eacute;n podr&iacute;amos considerar esta relaci&oacute;n como una relaci&oacute;n uno-a-muchos entre <span class="codefrag">Autor</span> y <span class="codefrag">Mensaje</span>.</p>
<a name="N100C4"></a><a name="Entidad+propietaria+de+la+relaci%C3%B3n"></a>
<h3 class="underlined_5">Entidad propietaria de la relaci&oacute;n</h3>
<p>&iquest;C&oacute;mo se realiza el mapeo de una relaci&oacute;n? La forma m&aacute;s habitual es definir una columna adicional en la tabla asociada a una de las entidades con la clave primaria de la otra tabla con la que est&aacute; relacionada. Esta columna hace de <em>clave ajena</em> hacia la otra tabla. Decimos que esta entidad cuya tabla contiene la clave ajena hacia la otra es la <em>propietaria</em> de la relaci&oacute;n.</p>
<p>En el ejemplo visto, la relaci&oacute;n se mapea haciendo que la tabla <span class="codefrag">MENSAJE</span> contenga una clave ajena hacia la tabla <span class="codefrag">AUTOR</span>, como hemos visto en la figura. Decimos entonces que la entidad <span class="codefrag">Mensaje</span> es la propietaria de la relaci&oacute;n.</p>
<p>Para especificar las columnas que son claves ajenas en una relaci&oacute;n se utilizan las anotaciones <span class="codefrag">@JoinColumn</span> y <span class="codefrag">mappedBy</span>. La primera es opcional y se puede identificar con los valores por defecto. La segunda es obligatoria y es un atributo de la anotaci&oacute;n que define la relaci&oacute;n: <span class="codefrag">OneToOne</span>, <span class="codefrag">OneToMany</span> o <span class="codefrag">ManyToMany</span>. Como veremos m&aacute;s adelante, este elemento debe indicar el nombre del atributo que representa la clave ajena en la otra entidad.</p>
<p>Tambi&eacute;n es posible mapear una relaci&oacute;n utilizando una <em>tabla join</em>, una tabla auxiliar con dos claves ajenas hacia las tablas de la relaci&oacute;n. No nos da tiempo en este tema de explicar c&oacute;mo hacerlo. Si est&aacute;s interesado puedes consultar en la especificaci&oacute;n de JPA.</p>
<a name="N100F8"></a><a name="Sincronizaci%C3%B3n+con+la+base+de+datos"></a>
<h3 class="underlined_5">Sincronizaci&oacute;n con la base de datos</h3>
<p>Ya hemos comentado previamente que una de las caracter&iacute;sticas fundamentales del funcionamiento de JPA es que las instancias de las entidades viven en el contexto de persistencia asociado al entity manager hasta que se realiza una operaci&oacute;n de <em>flush</em> sobre la base de datos. Normalmente esto sucede cuando se cierra la transacci&oacute;n. En ese momento es cuando el proveedor de persistencia consulta las instancias del contexto y genera las sentencias SQL que actualizan la base de datos. Es interesante tener activo el debug de Hibernate que muestra las sentencias generadas para comprobar en qu&eacute; momento se realizan y cu&aacute;les son.</p>
<p>En el caso de las relaciones, la especificaci&oacute;n de JPA avisa literalmente de lo siguiente (el &eacute;nfasis es del documento original):</p>
<p>
<em>Es particularmente importante asegurarse de que los cambios en el lado inverso de una relaci&oacute;n se actualizan de forma apropiada en el lado propietario, para asegurarse de que los cambios no se pierden cuando se sincronizan en la base de datos.</em>
</p>
<p>Esto es, para que una relaci&oacute;n se sincronice correctamente en la base de datos, se debe actualizar la instancia a la que se refiere en la parte propietaria de la relaci&oacute;n. En el caso del ejemplo, para a&ntilde;adir una relaci&oacute;n entre un <span class="codefrag">Mensaje</span> y un <span class="codefrag">Autor</span>, debemos a&ntilde;adir el autor asociado al mensaje en la instancia <span class="codefrag">Mensaje</span> (la propietaria de la relaci&oacute;n). No te preocupes si no te queda demasiado claro. Lo explicamos mejor m&aacute;s adelante con algunos ejemplos, cuando veamos tipos de relaciones concretos.</p>
</div>

	
<a name="N10119"></a><a name="Definici%C3%B3n+de+relaciones"></a>
<h2 class="underlined_10">Definici&oacute;n de relaciones</h2>
<div class="section">
<p>Detallamos a continuaci&oacute;n c&oacute;mo se especifican las relaciones utilizando anotaciones. </p>
<a name="N10122"></a><a name="Relaci%C3%B3n+uno-a-uno+unidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n uno-a-uno unidireccional</h3>
<p>En una relaci&oacute;n uno-a-uno unidireccional entre la entidad A y la entidad B, una instancia de la entidad A referencia una instancia de la entidad B. En la relaci&oacute;n A pondremos la anotaci&oacute;n <span class="codefrag">@OneToOne</span> en el atributo referente. En la entidad B no hay que a&ntilde;adir ninguna anotaci&oacute;n.</p>
<p>Un ejemplo podr&iacute;a ser la relaci&oacute;n entre un <span class="codefrag">Empleado</span> y un <span class="codefrag">Despacho</span> (asumiendo que <span class="codefrag">Despacho</span> es una entidad, y no un objeto embebido). El c&oacute;digo ser&iacute;a el siguiente:</p>
<pre class="code">@Entity
public class Empleado {
   // ...
   @OneToOne
   private despacho Despacho;
   // ...
   
   public void setDespacho(Despacho despacho) {
      this.despacho = despacho;
   }
}

@Entity
public class Despacho {
   @Id
   String idDespacho;

   // ...
}</pre>
<p>La entidad <span class="codefrag">Empleado</span> es la propietaria de la relaci&oacute;n y en su tabla hay una clave ajena (en la columna <span class="codefrag">despacho</span>) que apunta a la otra tabla. Se puede especificar esta clave ajena con la anotaci&oacute;n <span class="codefrag">@JoinColumn</span>:</p>
<pre class="code">public class Empleado {
	// ...
   @OneToOne	
   @JoinColumn(name="despacho",
   referencedColumnName="idDespacho, updatable=false)
   private Despacho despacho;
   //...
</pre>
<p>En esta anotaci&oacute;n <span class="codefrag">@JoinColumn</span> se especifica el nombre de la columna, el nombre de la columna con la clave primaria en la tabla a la que se apunta y se indica que la columna no puede ser modificada mediante un update.</p>
<p>En el caso de no utilizar la anotaci&oacute;n, JPA realizar&aacute; el mapeo utilizando como nombre de columna el nombre del atributo que guarda la otra entidad y el nombre de la columna con la clave primaria en la otra entidad, uni&eacute;ndolas con un subrayado ("_"). En este caso, se llamar&iacute;a <span class="codefrag">empleado_idDespacho</span>.</p>
<p>Para actualizar la relaci&oacute;n, basta con llamar al m&eacute;todo <span class="codefrag">setDespacho()</span>:</p>
<pre class="code">
em.getTrasaction().begin();
Empleado emp = new Empleado("John Doe");
Despacho desp = new Despacho("C1");
desp.setEmpleado(emp);
em.persist(desp);
em.persist(emp);
em.getTransaction().commit();</pre>
<a name="N10165"></a><a name="Relaci%C3%B3n+uno-a-uno+bidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n uno-a-uno bidireccional</h3>
<p>Supongamos que necesitamos modificar la relaci&oacute;n anterior para que podamos obtener el empleado a partir de su despacho. Basta con hacer que la relaci&oacute;n anterior sea bidireccional. Para ello, debemos a&ntilde;adir el atributo <span class="codefrag">empleado</span> en la entidad <span class="codefrag">Despacho</span> y anotarlo con <span class="codefrag">@OneToOne(mappedBy="despacho")</span>. De esta forma estamos indicando que la entidad <span class="codefrag">Empleado</span> es la propietaria de la relaci&oacute;n y que contiene la clave ajena en el atributo <span class="codefrag">despacho</span>.</p>
<pre class="code">@Empleado
public class Empleado {
   // ...
   @OneToOne
   private despacho Despacho;
   // ...

   public void setDespacho(Despacho despacho) {
      this.despacho = despacho;
   }
}

@Entity
public class Despacho {
   // ...
   @OneToOne(mappedBy="despacho")
   private empleado Empleado;
   // ...
   
   public Empleado getEmpleado() {
      return this.empleado;
   }
}</pre>
<p>Hay que destacar la utilizaci&oacute;n del elemento <span class="codefrag">mappedBy</span> en el atributo <span class="codefrag">despacho</span>. Con ese elemento estamos indicando al proveedor de persistencia cu&aacute;l es la clave ajena en la entidad <span class="codefrag">Empleado</span>.</p>
<p>Para actualizar la relaci&oacute;n hay que hacer lo mismo que antes, utilizar el m&eacute;todo <span class="codefrag">setDespacho()</span> del objeto <span class="codefrag">Empleado</span> pas&aacute;ndole el <span class="codefrag">Despacho</span> con el que est&aacute; relacionado. Hay que hacer notar que es muy importante actualizar el lado de la relaci&oacute;n que es el propietario de la misma y que contiene la clave ajena. Si lo hici&eacute;ramos al rev&eacute;s y actualiz&aacute;ramos el atributo <span class="codefrag">empleado</span> del <span class="codefrag">Despacho</span> tendr&iacute;amos la desagradable sorpresa de que la relaci&oacute;n <strong>no se actualiza</strong> en la base de datos. Por ello <strong>ser&iacute;a incorrecto hacer lo siguiente</strong>:</p>
<pre class="code">em.getTransaction().begin();
Empleado emp = new Empleado("John Doe");
Despacho desp = new Despacho("C1");
desp.setEmpleado(emp);
em.getTransaction().commit();</pre>
<p>Ser&iacute;a incorrecto porque estamos actualizando el lado inverso de la relaci&oacute;n, no el lado propietario. Aunque la relaci&oacute;n es bidireccional, la actualizaci&oacute;n s&oacute;lo se puede hacer en el lado del propietario de la relaci&oacute;n. Para evitar posibles errores, lo mejor es implementar &uacute;nicamente el m&eacute;todo <span class="codefrag">set</span> en el lado del propietario de la relaci&oacute;n y en el otro lado (en la entidad <span class="codefrag">Empleado</span>) poner como <span class="codefrag">private</span> el atributo de la relaci&oacute;n y no definir ning&uacute;n m&eacute;todo <span class="codefrag">set</span>.</p>
<a name="N101B9"></a><a name="Relaci%C3%B3n+uno-a-muchos%2Fmuchos-a-uno+bidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n uno-a-muchos/muchos-a-uno bidireccional</h3>
<p>En una relaci&oacute;n uno-a-muchos bidireccional entre la entidad A y la B (que es equivalente a una relaci&oacute;n muchos-a-uno bidireccional entre B y A), una instancia de la entidad A referencia a una colecci&oacute;n de instancias de B y una instancia de B referencia a una instancia de A. La entidad B debe ser la propietaria de la relaci&oacute;n, la que contiene la clave ajena a la entidad A.</p>
<p>En la entidad B se define un atributo del tipo de la entidad A, con la anotaci&oacute;n <span class="codefrag">@ManyToOne</span>. En la entidad A se define un atributo del tipo <span class="codefrag">Collection&lt;B&gt;</span> con la anotaci&oacute;n <span class="codefrag">@OneToMany(mappedBy="a")</span> que indica el nombre de la clave ajena.</p>
<p>El ejemplo que presentamos al comienzo del cap&iacute;tulo es de este tipo. Otro ejemplo podr&iacute;a ser el de la relaci&oacute;n entre un departamento y los empleados. Un <span class="codefrag">Departamento</span> est&aacute; relacionado con muchos <span class="codefrag">Empleado</span>s. Y un <span class="codefrag">Empleado</span> pertenece a un &uacute;nico <span class="codefrag">Departamento</span>. De esta forma el <span class="codefrag">Empleado</span> hace el papel de propietario de la relaci&oacute;n y es quien llevar&aacute; la clave ajena hacia <span class="codefrag">Departamento</span>. Lo vemos en el siguiente c&oacute;digo:</p>
<pre class="code">@Entity
public class Empleado {
   // ...
   @ManyToOne
   @JoinColumn(name="departamento", referencedColumnName="idDepartamento")
   private departamento Departamento;
   // ...
   public void setDepartamento(Departamento departamento) {
      this.departamento = departamento;
   }
}

@Entity
public class Departamento {
   // ...
   @OneToMany(mappedBy="departamento")
   private Collection&lt;Empleado&gt; empleados = new HashSet();
   // ...

   public Collection&lt;Empleado&gt; getEmpleados() {
      return this.empleados;
   }
}</pre>
<p>En la declaraci&oacute;n se podr&iacute;a eliminar la anotaci&oacute;n <span class="codefrag">@JoinColumn</span> y el nombre de la columna con la clave ajena se obtendr&iacute;a de la misma forma que hemos visto en la relaci&oacute;n uno-a-uno.</p>
<p>Como tambi&eacute;n hemos dicho anteriormente, la relaci&oacute;n se actualiza insertando el nuevo <span class="codefrag">Departamento</span> en la instancia <span class="codefrag">Empleado</span> (la propietaria de la relaci&oacute;n) con el m&eacute;todo <span class="codefrag">setDepartamento()</span>, de esta forma nos aseguraremos que la relaci&oacute;n se guarda en la base de datos. Sin embargo, tambi&eacute;n es importante actualizar la colecci&oacute;n en el otro lado de la relaci&oacute;n. La llamada a <span class="codefrag">getEmpleados()</span> es sobreescrita por JPA y es implementada por una consulta a la base de datos, pero si queremos utilizar inmediatamente la colecci&oacute;n de empleados, debemos actualizar su contenido:</p>
<pre class="code">Collection empleados = depto.getEmpleados();
emp.setDepartemnto(depto);
empleados.add(emp);</pre>
<a name="N10201"></a><a name="Relaci%C3%B3n+muchos-a-uno+unidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n muchos-a-uno unidireccional</h3>
<p>En una relaci&oacute;n muchos-a-uno unidireccional entre las entidades A y B, una instancia de A est&aacute; relacionada con una instancia de B (que puede ser la misma para distintas instancias de A). Para definir la relaci&oacute;n hay que definir en la entidad propietaria A un atributo que define la clave ajena hacia la entidad B. Al ser una relaci&oacute;n unidireccional no podremos obtener desde la entidad B su entidad relacionada A, por lo que no hay que definir ning&uacute;n atributo adicional.</p>
<p>Por ejemplo, podr&iacute;amos definir una relaci&oacute;n entre <span class="codefrag">Empleado</span> y <span class="codefrag">Categoria</span> en la que muchos empleados pueden pertenecer a la misma categoria y no nos interesa listar los empleados de una determinada cualificacion:</p>
<pre class="code">@Empleado
public class Empleado {
   // ...
   @ManyToOne
   @JoinColumn(name="categoria", referencedColumnName="idCategoria")
   private categoria Categoria;
   // ...
   public void setCategoria(Categoria categoria) {
      this.categoria = categoria;
   }
}

@Entity
public class Categoria {
   // ...
}}</pre>
<p></p>
<a name="N1021A"></a><a name="Relaci%C3%B3n+muchos-a-muchos+bidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n muchos-a-muchos bidireccional</h3>
<p>En una relaci&oacute;n muchos-a-muchos bidireccional entre la entidad A y la entidad B, una instancia de A est&aacute; relacionada con una o muchas instancias de B (que pueden ser las mismas para distintas instancias de A). Desde la instancia A se puede obtener la colecci&oacute;n de instancias de B con las que est&aacute; relacionada y viceversa.</p>
<p>Por ejemplo, un <span class="codefrag">Empleado</span> puede participar en m&aacute;s de un <span class="codefrag">Proyecto</span>. Dado un empleado se puede obtener la lista de proyectos en los que participa y dado un proyecto podemos obtener la lista de empleados asignados a &eacute;l.</p>
<p>Se implementa con las siguientes anotaciones:</p>
<pre class="code">@Entity
public class Empleado {
   @Id String nombre;
   @ManyToMany
   private Collection&lt;Projecto&gt; proyectos = new HashSet();

   public Collection&lt;Proyecto&gt; getProyectos() {
      return this.proyectos;
   }

   public void setProyectos(Collection&lt;Proyecto&gt; proyectos) {
      this.proyectos = proyectos;
   }

   // ...
}

@Entity
public class Proyecto {
   @Id String codigo;
   @ManyToMany(mappedBy="proyectos");
   private Collection&lt;Empleado&gt; empleados = new HashSet();

   public Collection&lt;Empleado&gt; getEmpleados() {
      return empleados;
   }
   // ...
}</pre>
<p>La anotaci&oacute;n <span class="codefrag">mappedBy</span> apunta a la entidad propietaria de la relaci&oacute;n. En este caso es la entidad <span class="codefrag">Empleado</span>.</p>
<p>La relaci&oacute;n se mapea, a diferencia de los casos anteriores, utilizando una <em>tabla join</em>. Es una tabla con dos columnas que contienen claves ajenas a las tablas de las entidades. La primera columna apunta a la tabla propietaria de la relaci&oacute;n y la segunda a la otra tabla. La siguiente imagen representa el mapeo de la relaci&oacute;n anterior.</p>
<p>
<img alt="" content-width="12cm" src="imagenes/relacion-muchos-a-muchos.png" width="588"></p>
<p>Al igual que en las otras relaciones, para actualizar la relaci&oacute;n hay que modificar el lado propietario de la relaci&oacute;n, que es el que se sincronizar&aacute; con la base de datos. En este caso, en el lado propietario (<span class="codefrag">Empleado</span>) tenemos una colecci&oacute;n de proyectos. Para a&ntilde;adir un nuevo empleado a un proyecto hay que obtener la referencia a la colecci&oacute;n de proyectos en los que participa el empleado (con el m&eacute;todo <span class="codefrag">getProyectos()</span>) y a&ntilde;adir el nuevo proyecto con el m&eacute;todo <span class="codefrag">add()</span> de la colecci&oacute;n:</p>
<pre class="code">Proyecto proyecto = em.find(Proyecto.class, "P04");
Collection&lt;Proyectos&gt; proyectos = empleado.getProyectos();
proyectos.add(proyecto);</pre>
<p>Otro ejemplo que podr&iacute;a ser &uacute;til es el siguiente, en el que se muestra c&oacute;mo cambiar a un empleado del proyecto "P01" al proyecto "P04":</p>
<pre class="code">Empleado empleado = em.find(Empleado.class, "Miguel Garcia");
Proyecto proyectoBaja = em.find(Proyecto.class, "P04");
Proyecto proyectoAlta = em.find(Proyecto.class, "P01");
empleado.getProyectos().remove(proyectoBaja);
empleado.getProyectos().add(proyectoAlta);</pre>
<p>Es muy interesante analizar un poco m&aacute;s el c&oacute;digo. &iquest;Por qu&eacute; funciona correctamente el m&eacute;todo <span class="codefrag">remove()</span>? Hay que recordar que que para que funcione correctamente el m&eacute;todo, el objeto que se pasa como par&aacute;metro debe ser igual (con el m&eacute;todo <span class="codefrag">equals()</span>) que el objeto que hay en la colecci&oacute;n. Hibernate se encarga de sobrecargar el m&eacute;todo <span class="codefrag">equals()</span> para que devuelva <span class="codefrag">true</span> cuando se refieren a la misma instancia de entidad. De esta forma la instancia que se devuelve con el m&eacute;todo <span class="codefrag">find()</span> es la misma que hay en la colecci&oacute;n obtenida con <span class="codefrag">getProyectos()</span>.</p>
<a name="N10276"></a><a name="Relaci%C3%B3n+muchos-a-muchos+unidireccional"></a>
<h3 class="underlined_5">Relaci&oacute;n muchos-a-muchos unidireccional</h3>
<p>En una relaci&oacute;n muchos-a-muchos unidireccional entre una entidad A y otra entidad B, cada instancia de la entidad A est&aacute; relacionada con una o muchas instancias de B (que pueden ser las mismas para distintas instancias de A). Al ser una relaci&oacute;n unidireccional, dada una instancia de B no nos interesa saber la instancia de A con la que est&aacute; relacionada.</p>
<p>Por ejemplo, un <span class="codefrag">Empleado</span> tiene una colecci&oacute;n de <span class="codefrag">Patente</span>s que ha desarrollado. Distintos empleados pueden participar en la misma patente. Pero no nos interesa guardar la informaci&oacute;n de qu&eacute; empleados han desarrollado una patente determinada. La forma de especificarlo es:</p>
<pre class="code">@Entity
public class Empleado {
   @Id String nombre;
   @ManyToMany
   private Collection&lt;Patentes&gt; patentes = new HashSet();

   public Collection&lt;Patentes&gt; getPatentes() {
      return this.patentes;
   }

   public void setPatentes(Collection&lt;Patentes&gt; patentes) {
      this.patentes = patentes;
   }

   // ...
}

@Entity
public class Patente {
   // ...
}</pre>
<p>En el mapeo de la relaci&oacute;n se crea una tabla join llamada <span class="codefrag">EMPLEADO_PATENTE</span> con las dos claves ajenas hacia <span class="codefrag">EMPLEADO</span> y <span class="codefrag">PATENTE</span>.</p>
<p>La forma de actualizar la relaci&oacute;n es la misma que en la relaci&oacute;n bidireccional.</p>
</div>
	
	
<a name="N1029D"></a><a name="Carga+perezosa"></a>
<h2 class="underlined_10">Carga perezosa</h2>
<div class="section">
<p>Hemos comentado que una de las caracter&iacute;sticas de JPA es la <em>carga perezosa</em> (<em>lazy fetching</em> en ingl&eacute;s). Este concepto es de especial importancia cuando estamos trabajando con relaciones.</p>
<p>Supongamos los ejemplos anteriores, con la relaci&oacute;n uno-a-muchos entre <span class="codefrag">Departamento</span> y <span class="codefrag">Empleado</span> y la relaci&oacute;n muchos-a-muchos entre <span class="codefrag">Empleado</span> y <span class="codefrag">Proyecto</span>. Cuando recuperamos un departamento de la base ese departamento est&aacute; relacionado con un conjunto de empleados, que a su vez est&aacute;n relacionados cada uno de ellos con un conjunto de proyectos. La carga perezosa consiste en que no se cargan todos los objetos en el contexto de persistencia, sino s&oacute;lo la referencia al departamento que se ha recuperado. Es cuando se realiza una llamada al m&eacute;todo <span class="codefrag">getEmpleados()</span> cuando se recuperan de la base de datos todas las instancias de <span class="codefrag">Empleado</span> con las que ese departamento est&aacute; relacionado. Pero s&oacute;lo los empleados. Los proyectos de cada empleado no se cargan hasta que no se llama al m&eacute;todo <span class="codefrag">getProyectos()</span> del empleado que nos interese.</p>
<p>Esta funcionalidad hace que la carga de instancias sea muy eficiente, pero hay que saber utilizarla correctamente. Un posible problema puede surgir cuando la instancia original (el <span class="codefrag">Departamento</span>) queda desconectada (<em>detached</em>) del <em>EntityManager</em> (lo veremos en el tema siguiente). Entonces ya no podremos acceder a ning&uacute;n atributo que no se haya cargado.</p>
<p>Es posible que quereamos desactivar la propiedad por defecto de la carga perezosa. Para ello debemos definir la opci&oacute;n <span class="codefrag">fetch=FetchType.EAGER</span> en la anotaci&oacute;n que define el tipo de relaci&oacute;n:</p>
<pre class="code">@Entity
public class Empleado {
   @Id String nombre;
   @ManyToMany(fetch=FetchType.EAGER)
   private Collection&lt;Patentes&gt; patentes = new HashSet();
   // ...
}</pre>
<p>Tambi&eacute;n es posible configurar el proveedor de persistencia para que la opci&oacute;n por defecto sea <span class="codefrag">EAGER</span>. En este caso podemos definir una relaci&oacute;n como perezosa con la anotaci&oacute;n <span class="codefrag">fetch=FetchType.LAZY</span>.</p>
</div>
	


<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2007-2008 Depto. CCIA</div>
</div>
</body>
</html>
