<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Mapeado entidad-relaci&oacute;n: tablas</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="JPA con Hibernate" src="images/baner_j2ee_der.gif" title="JPA con Hibernate"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto SIGEM</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Persistencia</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">JPA</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="JPA">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 3</div>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesion 8</a>
</div>
<div class="menuitem">
<a href="roadmap.html">Roadmap JPA</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="sesion05-ejercicios.html">Sesion 5</a>
</div>
<div class="menuitem">
<a href="sesion06-ejercicios.html">Sesion 6</a>
</div>
<div class="menuitem">
<a href="sesion07-ejercicios.html">Sesion 7</a>
</div>
<div class="menuitem">
<a href="sesion08-ejercicios.html">Sesion 8</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion03-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Mapeado entidad-relaci&oacute;n: tablas</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Acceso+al+estado+de+la+entidad">Acceso al estado de la entidad</a>
<ul class="minitoc">
<li>
<a href="#Acceso+por+campo">Acceso por campo</a>
</li>
<li>
<a href="#Acceso+por+propiedad">Acceso por propiedad</a>
</li>
</ul>
</li>
<li>
<a href="#Mapeado+de+entidades">Mapeado de entidades</a>
</li>
<li>
<a href="#Mapeado+de+tipos">Mapeado de tipos</a>
<ul class="minitoc">
<li>
<a href="#Mapeo+de+columnas">Mapeo de columnas</a>
</li>
<li>
<a href="#Recuperaci%C3%B3n+perezosa">Recuperaci&oacute;n perezosa</a>
</li>
<li>
<a href="#LOBs">LOBs</a>
</li>
<li>
<a href="#Tipos+enumerados">Tipos enumerados</a>
</li>
<li>
<a href="#Tipos+temporales">Tipos temporales</a>
</li>
<li>
<a href="#Estado+transitorio">Estado transitorio</a>
</li>
</ul>
</li>
<li>
<a href="#Mapeo+de+la+clave+primaria">Mapeo de la clave primaria</a>
<ul class="minitoc">
<li>
<a href="#Generaci%C3%B3n+del+identificador">Generaci&oacute;n del identificador</a>
<ul class="minitoc">
<li>
<a href="#Generaci%C3%B3n+de+id+autom%C3%A1tica">Generaci&oacute;n de id autom&aacute;tica</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Objetos+embebidos">Objetos embebidos</a>
</li>
<li>
<a href="#Mapeado+de+las+relaciones+de+herencia">Mapeado de las relaciones de herencia</a>
</li>
</ul>
</div>
	
	
<p>En este tema vamos a comenzar a tratar en profundidad el mapeado entidad-relaci&oacute;n  (ORM, <em>Object-Relational Mapping</em> en ingl&eacute;s), uno de los aspectos principales del API de persistencia. Veremos los aspectos referidos al mapeo de entidades en tablas: c&oacute;mo acceder al estado de una entidad, como se mapea la entidad en una tabla, como se mapean los distintos tipos simples de Java en tipos de la base de datos, c&oacute;mo se maneja el identificador de la identidad y se mapea en la clave primaria de la tabla. Terminaremos introduciendo un par de conceptos avanzados, los objetos embebidos y la herencia.</p>

	
<p>Como hemos comentado en temas anteriores, la especificaci&oacute;n del ORM se realiza mediante metadatos especificados por el desarrollador. JPA soporta dos formas de especificar estos metadatos, mediante anotaciones y mediante ficheros XML. A lo largo de todo el tema (y del m&oacute;dulo) utilizaremos las anotaciones por ser mucho m&aacute;s legibles y estar integradas en el propio c&oacute;digo de la aplicaci&oacute;n.</p>
	

<a name="N10015"></a><a name="Acceso+al+estado+de+la+entidad"></a>
<h2 class="underlined_10">Acceso al estado de la entidad</h2>
<div class="section">
<p>El proveedor de la base de datos debe poder acceder al estado mapeado en memoria en tiempo de ejecuci&oacute;n, de forma que en el momento de escribir los datos, &eacute;stos puedan obtenerse de la instancia de la entidad. De la misma forma, cuando se carga el estado de la base de datos, el proveedor debe poder crear una nueva instancia e insertar en ella los datos obtenidos de la base de datos.</p>
<p>Existen dos formas diferentes con las que podemos especificar el estado persistente: podemos anotar los campos de la entidad o anotar sus propiedades (m&eacute;todos JavaBean <em>getters</em> y <em>setters</em>). El mecanismo del proveedor para acceder al estado depender&aacute; entonces del tipo de anotaci&oacute;n utilizada. En el primer caso, el proveedor leer&aacute; y establecer&aacute; los campos de la entidad utilizando reflexi&oacute;n. Si las anotaciones se realizan en las propiedades, entonces el proveedor utilizar&aacute; estos m&eacute;todos para acceder al estado.</p>
<a name="N10027"></a><a name="Acceso+por+campo"></a>
<h3 class="underlined_5">Acceso por campo</h3>
<p>Si anotamos los campos de una entidad, el proveedor acceder&aacute; a estos campos mediante reflexi&oacute;n (aunque est&eacute;n declarados como privados). A esta forma de acceder a la entidad por parte del proveedor se denomina <em>acceso por campo</em>. Los m&eacute;todos <em>getters</em> y <em>setters</em> ser&aacute;n ignorados por el proveedor. Todos los campos deben declararse como <span class="codefrag">protected</span> o <span class="codefrag">private</span>. Se desaconseja siempre el uso de campos p&uacute;blicos, porque podr&iacute;an accederse directamente desde otras clases. Este acceso p&uacute;blico podr&iacute;a incluso estropear el funcionamiento del proveedor.</p>
<p>El ejemplo siguiente muestra el uso de las anotaciones en los campos. La anotaci&oacute;n <span class="codefrag">@Id</span> indica no s&oacute;lo que el campo <span class="codefrag">id</span> es el identificador o clave primaria de la entidad, sino tambi&eacute;n que se va a utilizar un acceso por campo. Los campos <span class="codefrag">nombre</span> y <span class="codefrag">sueldo</span> son hechos persistentes en columnas con el mismo nombre.</p>
<pre class="code">@Entity
public class Empleado {
@Id private int id;
private String nombre;
private Long sueldo;

public Empleado() {}

public int getId() { return id; }
public void setId(int id) { this.id = id; }
public String getNombre() { return nombre; }
public void setNombre(String nombre) { this.nombre = nombre; }
public Long getSueldo() { return sueldo; }
public void setSueldo(Long sueldo) { this.sueldo = sueldo; }}</pre>
<a name="N10053"></a><a name="Acceso+por+propiedad"></a>
<h3 class="underlined_5">Acceso por propiedad</h3>
<p>Cuando anotamos las propiedades, se aplican las mismas condiciones que cuando se define un JavaBean, y debe haber <em>getters</em> y <em>setters</em> para las propiedades que queremos hacer persistentes. En este caso se dice que el proveedor utiliza un acceso por propiedad a la entidad. El tipo de la propiedad viene determinado por el tipo devuelto por el m&eacute;todo <em>getter</em> y debe ser el mismo que el &uacute;nico par&aacute;metro pasado al m&eacute;todo <em>setter</em>. Ambos m&eacute;todos deben tener visibilidad <span class="codefrag">public</span> o <span class="codefrag">protected</span>. La anotaci&oacute;n de mapeado debe realizarse en el m&eacute;todo <em>getter</em>.</p>
<p>En el c&oacute;digo siguiente, la clase <span class="codefrag">Empleado</span> tiene una anotaci&oacute;n <span class="codefrag">@Id</span> en el m&eacute;todo <em>getter</em> <span class="codefrag">getId()</span>, por lo que el proveedor podr&aacute; utilizar el acceso a la propiedad <span class="codefrag">id</span> para obtener y establecer el estado de la entidad. Las propiedades <span class="codefrag">nombre</span> y <span class="codefrag">sueldo</span> se hacen persistentes tambi&eacute;n autom&aacute;ticamente y se mapear&aacute;n en columnas con el mismo nombre. N&oacute;tese que es posible utilizar nombres distintos para los campos. En el ejemplo, la propiedad <span class="codefrag">sueldo</span> est&aacute; respaldada por el campo <span class="codefrag">sueldo</span>. El proveedor ignora esta diferencia, ya que &uacute;nicamente utiliza los <em>getters</em> y <em>setters</em>.</p>
<pre class="code">@Entity
public class Empleado {
private int id;
private String nombre;
private Long sueldo;

public Empleado {}

@Id public int getId() { return id; }
public void setId(int id) { this.id = id; }
public String getNombre() { return nombre; }
public void setNombre(String nombre) { this.nombre = nombre; }
public Long getSueldo() { return sueldo; }
public void setSueldo(Long sueldo) { this.sueldo = sueldo; }}</pre>
</div>


<a name="N1009B"></a><a name="Mapeado+de+entidades"></a>
<h2 class="underlined_10">Mapeado de entidades</h2>
<div class="section">
<p>Ya hemos visto en el tema anterior que es muy sencillo mapear entidades en tablas. S&oacute;lo se necesitan las anotaciones <span class="codefrag">@Entity</span> y <span class="codefrag">@Id</span> para crear y mapear una entidad en una tabla de la base de datos.</p>
<p>En esos casos el nombre que se utiliza para la tabla es el propio nombre de la entidad. Podr&iacute;a darse el caso de que necesit&aacute;ramos especificar un nombre distinto para la tabla, por ejemplo si no estamos desarrollando la aplicaci&oacute;n desde cero y partimos de un modelo de datos ya creado. Podemos hacerlo con la anotaci&oacute;n <span class="codefrag">@Table</span> en la que incluimos el nombre de la tabla. El siguiente c&oacute;digo muestra un ejemplo.</p>
<pre class="code">@Entity
@Table(name="EMP")
public class Empleado { ... }</pre>
<p>Los nombres por defecto son los nombres de las clases, que en Java comienzan por may&uacute;scula y contin&uacute;an con min&uacute;scula. &iquest;C&oacute;mo se mapean las may&uacute;sculas y min&uacute;sculas en la base de datos? Depende de la base de datos. Muchas bases de datos no distinguen may&uacute;sculas y min&uacute;sculas, por lo que en estos casos el nombre se convierte en may&uacute;sculas. En el caso de <em>MySQL</em>, s&iacute; que se distinguen entre may&uacute;sculas y min&uacute;sculas, por lo que el nomre de las tablas ser&aacute; id&eacute;ntico al de las clases.</p>
<p>La anotaci&oacute;n <span class="codefrag">@Table</span> proporciona la posibilidad no s&oacute;lo de nombrar la tabla, sino de especificar un esquema o cat&aacute;logo de la base de datos. El nombre del esquema se utiliza normalmente para diferenciar un conjunto de tablas de otro y se indica en la anotaci&oacute;n con el elemento <span class="codefrag">schema</span>. Se muestra en el siguiente ejemplo.</p>
<pre class="code">@Entity
@Table(name="EMP", schema="IT")
public class Empleado { ... }</pre>
<p>Cuando se especifica de esta forma, el proveedor colocar&aacute; el nombre del esquema como prefijo del de la tabla cuando acceda a los datos. En este caso, los accesos se har&aacute;n a la tabla <span class="codefrag">IT.EMP</span>.</p>
</div>


<a name="N100CE"></a><a name="Mapeado+de+tipos"></a>
<h2 class="underlined_10">Mapeado de tipos</h2>
<div class="section">
<p>La especificaci&oacute;n de JPA define un gran n&uacute;mero de tipos Java que pueden ser hechos persistentes. Son los siguientes:</p>
<ul>
		
<li>
<strong>Tipos primitivos Java</strong>: <span class="codefrag">byte</span>, <span class="codefrag">int</span>, <span class="codefrag">short</span>, <span class="codefrag">long</span>, <span class="codefrag">boolean</span>, <span class="codefrag">char</span>, <span class="codefrag">float</span>, <span class="codefrag">double</span>
</li>
		
<li>
<strong>Clases <em>wrapper</em> de los tipos primitivos</strong>: <span class="codefrag">Byte</span>, <span class="codefrag">Integer</span>, <span class="codefrag">Short</span>, <span class="codefrag">Long</span>, <span class="codefrag">Boolean</span>, <span class="codefrag">Character</span>, <span class="codefrag">Float</span>, <span class="codefrag">Double</span>
</li>
		
<li>
<strong>Arrays de bytes y char</strong>: <span class="codefrag">byte[]</span>, <span class="codefrag">Byte[]</span>, <span class="codefrag">char[]</span>, <span class="codefrag">Character[]</span>
</li>
		
<li>
<strong>Tipos num&eacute;ricos largos</strong>: <span class="codefrag">java.math.BigInteger</span>, <span class="codefrag">java.math.BigDecimal</span>
</li>
		
<li>
<strong>Strings</strong>: <span class="codefrag">java.lang.String</span>
</li>
		
<li>
<strong>Tipos temporales de Java</strong>: <span class="codefrag">java.util.Date</span>, <span class="codefrag">java.util.Calendar</span>
</li>
		
<li>
<strong>Tipos temporales de JDBC</strong>: <span class="codefrag">java.sql.Date</span>, <span class="codefrag">java.sql.Time</span>, <span class="codefrag">java.sql.Timestamp</span>
</li>
		
<li>
<strong>Tipos enumerados</strong>: cualquier tipo enumerado del sistema o definido por el usuario</li>
		
<li>
<strong>Objetos serializables</strong>: cualquier tipo serializable del sistema o definido por el usuario</li>
	
</ul>
<p>En algunos casos el tipo de la columna que est&aacute; siendo mapeada no es exactamente el mismo que el tipo Java. En casi todos los casos, el runtime del proveedor puede convertir el tipo devuelto por la consulta JDBC en el tipo Java correcto del atributo. Si el tipo de la capa JDBC no puede convertirse en el tipo Java del campo o la propiedad se lanza una excepci&oacute;n.</p>
<p>Cuando se hace persistente un campo o una propiedad, el proveedor comprueba que su tipo es uno de los que est&aacute; en la lista anterior. Si lo est&aacute;, el proveedor lo transformar&aacute; en el tipo JDBC apropiado y lo pasar&aacute; al driver JDBC.</p>
<p>Se puede usar la anotaci&oacute;n opcional <span class="codefrag">@Basic</span> en el campo o la propiedad para marcarlos como persistentes. Esta anotaci&oacute;n se utiliza &uacute;nicamente para efectos de documentaci&oacute;n o para especificar alg&uacute;n detalle sobre la persistencia (lo veremos m&aacute;s adelante).</p>
<p>Ahora que hemos comprobados que los campos (definidos en las variables de instancia) y las propiedades (definidas en los <em>getters</em> y <em>setters</em>) son equivalentes en t&eacute;rminos de persistencia, los llamaremos de ahora en adelante <em>atributos</em>. Consideramos <em>atributo</em> un campo o una propiedad de una clase estilo JavaBean.</p>
<a name="N10172"></a><a name="Mapeo+de+columnas"></a>
<h3 class="underlined_5">Mapeo de columnas</h3>
<p>Es posible anotar las caracter&iacute;sticas f&iacute;sicas de la columna de la base de datos en la que se mapea un atributo utilizando la anotaci&oacute;n <span class="codefrag">@Column</span>. Aunque es posible especificar bastantes elementos, vamos a comentar s&oacute;lo alguno de ellos (consultar la especificaci&oacute;n de JPA para obtener m&aacute;s informaci&oacute;n).</p>
<p>La primera caracter&iacute;stica que hay que mencionar es el nombre de la columna. Al igual que con las tablas, es posible especificar los nombres de las columnas con las que se va a mapear cada atributo. El siguiente c&oacute;digo muestra un ejemplo.</p>
<pre class="code">@Entity
public class Empleado {
   @Id
   @Column(name="EMP_ID")
   private int id;
   private String nombre;
   @Column(name=SAL)
   private Long sueldo;
   @Column(name=COM)
   private String comentario;
   // ...
}</pre>
<p>La tabla resultante del mapeo se llamar&iacute;a <span class="codefrag">EMPLEADO</span> y tendr&iacute;a como columnas <span class="codefrag">EMP_ID</span>, <span class="codefrag">NOMBRE</span>, <span class="codefrag">SAL</span> y <span class="codefrag">COM</span>. La primera columna ser&iacute;a la clave primaria de la tabla. La siguiente figura muestra la tabla resultante en la base de datos.</p>
<p>
<img alt="" content-width="2.5cm" src="imagenes/tabla.png" width="112"></p>
<p>Es posible tambi&eacute;n obligar a que un atributo no pueda dejarse a <span class="codefrag">null</span> utilizando el elemento <span class="codefrag">nullable=false</span>. En la columna de la tabla se incluir&iacute;a la restricci&oacute;n SQL <span class="codefrag">NOT NULL</span>. Por ejemplo en el siguiente c&oacute;digo obligar&iacute;amos a que el nombre del empleado nunca pudiera ser <span class="codefrag">null</span>.</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   @Column(nullable=false)
   private String nombre;
   // ...
}</pre>
<p>Cuando no se especifica la longitud de una columna que almacena cadenas (<span class="codefrag">String</span>, <span class="codefrag">char[]</span> o <span class="codefrag">Character[]</span>), el valor por defecto es 255. Para definir otro tama&ntilde;o hay que utilizar el elemento <span class="codefrag">length</span>, como en el siguiente ejemplo:</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   @Column(length=40)
   private String nombre;
   // ...
}</pre>
<a name="N101C5"></a><a name="Recuperaci%C3%B3n+perezosa"></a>
<h3 class="underlined_5">Recuperaci&oacute;n perezosa</h3>
<p>El concepto de recuperaci&oacute;n perezosa (<em>lazy fetching</em> en ingl&eacute;s) es muy importante para gestionar de forma eficiente la base de datos. Ya veremos m&aacute;s adelante que tambi&eacute;n se aplica a las relaciones entre entidades.</p>
<p>En ocasiones, sabemos que hay algunos atributos de la entidad a los que se accede con muy poca frecuencia. En este caso podemos optimizar el rendimiento de los accesos a la base de datos obteniendo s&oacute;lo los datos que vamos a necesitar con frecuencia. Existen muchos nombres para esta idea, entre los que se incluyen (en ingl&eacute;s) <em>lazy loading</em>, <em>lazy fetching</em>, <em>on-demand fetching</em> o <em>indirection</em>. Todos significan lo mismo, que es que algunos datos no se cargan en el objeto cuando &eacute;ste es le&iacute;do inicialmente de la base de datos sino que ser&aacute;n recuperados s&oacute;lo cuando sean referenciados o accedidos.</p>
<p>El comportamiento de un atributo de la entidad se puede especificar con el elemento <span class="codefrag">fetch</span> de la anotaci&oacute;n <span class="codefrag">@Basic</span>. El tipo enumerado <span class="codefrag">FetchType</span> especifica los posibles valores de este elemento, que pueden ser <span class="codefrag">EAGER</span> (&aacute;vido, recupera el dato cuando se obtiene la entidad de la base de datos) o <span class="codefrag">LAZY</span> (perezoso, recupera el dato cuando se accede al atributo). El comportamiento por defecto es el primero.</p>
<p>El siguiente c&oacute;digo muestra un ejemplo, en el que el atributo <span class="codefrag">comentario</span> se define con un mapeo de recuperaci&oacute;n perezosa:</p>
<pre class="code">@Entity
public class Empleado {
   // ...
   @Basic(fetch=FetchType.LAZY)
   @Column(name=COM)
   private String comentario;
   // ...
}</pre>
<p>Antes de usar esta caracter&iacute;stica se deber&iacute;a tener claro unos cuantos aspectos. Lo primero es que la declaraci&oacute;n de un atributo como de recuperaci&oacute;n perezosa no obliga a nada al proveedor de persistencia. S&oacute;lo es una indicaci&oacute;n para que pueda agilizar ciertas acciones sobre la base de datos. El proveedor no est&aacute; obligado a respetar la petici&oacute;n, ya que el comportamiento de la entidad no queda comprometido haga una cosa u otra el proveedor.</p>
<p>Segundo, aunque en principio pueda parecer interesante definir ciertos atributos como de carga perezosa, en la pr&aacute;ctica no es correcto hacerlo con tipos simples (no relaciones a otras entidades). La raz&oacute;n es que se gana poco haciendo que la base de datos devuelva parte de una fila. &Uacute;nicamente se gana algo y deber&iacute;a considerarse la recuperaci&oacute;n perezosa cuando tenemos muchas (decenas o cientos) columnas o cuando algunas columnas ocupan mucho (por ejemplo, cadenas muy largas o <em>lobs</em>).</p>
<p>La recuperaci&oacute;n perezosa s&iacute; que es muy importante cuando hablemos de mapeo de relaciones, como veremos m&aacute;s adelante.</p>
<a name="N10209"></a><a name="LOBs"></a>
<h3 class="underlined_5">LOBs</h3>
<p>El nombre que habitualmente se les da en base de datos a los objetos de tipo byte o caracter que son muy grandes es el de <em>large object</em> o <em>LOB</em> como abreviatura. Las columnas de la base de datos que almacenan estos tipos de objetos se deben acceder desde Java con llamadas JDBC especiales. Para indicarle al proveedor que deber&iacute;a usar m&eacute;todos de tipo LOB en el driver de JDBC para acceder a ciertas columnas se debe utilizar la anotaci&oacute;n <span class="codefrag">@Lob</span>.</p>
<p>En la base de datos se pueden encontrar dos tipos de LOBs: objetos grandes de tipo car&aacute;cter, llamados <em>CLOBs</em> y objetos grandes de tipo binario, llamados <em>BLOBs</em>. Como su nombre indica, una columna CLOB guarda una larga secuencia de caracteres, mientras que un BLOB guarda una larga secuencia de bytes no formateados. Los tipos Java que se mapean con columnas CLOB son <span class="codefrag">String</span>, <span class="codefrag">char[]</span> y <span class="codefrag">Character[]</span>, mientras que <span class="codefrag">byte[]</span>, <span class="codefrag">Byte[]</span> y <span class="codefrag">Serializable</span> se mapean con columnas de tipo BLOB.</p>
<p>El siguiente c&oacute;digo muestra el ejemplo de mapeo de una columna con un BLOB imagen. Suponemos que la columna PIC guarda una imagen del empleado, que se mapea en el atributo <span class="codefrag">foto</span> de tipo <span class="codefrag">byte[]</span>.</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   @Basic(fetch=FetchType.LAZY)
   @Lob @Column(name="PIC")
   private byte[] foto;
   // ...
}</pre>
<a name="N10244"></a><a name="Tipos+enumerados"></a>
<h3 class="underlined_5">Tipos enumerados</h3>
<p>Otro tipo Java que puede ser mapeado en la base de datos es cualquier tipo enumerado del sistema o definido por el usuario.</p>
<p>Al igual que en otros lenguajes de programaci&oacute;n, a los valores de los tipos enumerados en Java se les asigna un ordinal impl&iacute;cito que depende del orden de creaci&oacute;n. Este ordinal no puede ser modificado en tiempo de ejecuci&oacute;n y es el que se utiliza para representar y almacenar el valor del tipo enumerado. El proveedor, por tanto, mapear&aacute; un tipo enumerado en una columna de tipo entero y sus valores en n&uacute;meros enteros espec&iacute;ficos.</p>
<p>Por ejemplo, consideremos el siguiente tipo enumerado:</p>
<pre class="code">public enum TipoEmpleado {
   EMPLEADO_TIEMPO_PARCIAL,
   EMPLEADO_TIEMPO_COMPLETO,
   EMPLEADO_EXTERNO
}</pre>
<p>Los ordinales asignados en tiempo de compilaci&oacute;n a los valores de este tipo enumerado son 0 para <span class="codefrag">EMPLEADO_TIEMPO_PARCIAL</span>, 1 para <span class="codefrag">EMPLEADO_TIEMPO_COMPLETO</span> y 2 para <span class="codefrag">EMPLEADO_EXTERNO</span>. El siguiente c&oacute;digo utiliza este tipo para definir un atributo de la entidad:</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   private TipoEmpleado tipo;
   // ...
}</pre>
<p>Podemos ver que el mapeado es trivial, ya que no hay que hacer nada especial y el proveedor se encarga de realizar la transformaci&oacute;n del tipo enumerado al tipo entero de la base de datos.</p>
<p>Sin embargo, hay que tener cuidado con una cosa. Si en alg&uacute;n momento cambiamos el tipo enumerado podemos tener problemas, ya que puede cambiar el orden de los valores en el tipo enumerado y no corresponderse con los ya existentes en la base de datos. Por ejemplo, supongamos que necesitamos a&ntilde;adir un nuevo tipo de empleado a tiempo completo: <span class="codefrag">EMPLEADO_TIEMPO_COMPLETO_EXCEDENCIA</span> y supongamos que lo a&ntilde;adimos justo despu&eacute;s de <span class="codefrag">EMPLEADO_TIEMPO_COMPLETO</span>. Esto causar&iacute;a un cambio en el ordinal asociado a <span class="codefrag">EMPLEADO_EXTERNO</span>, que pasar&iacute;a de 2 a 3. Los empleados existentes en la base de datos, sin embargo, no cambiar&iacute;an y los datos grabados con el ordinal 2 pasar&iacute;an de ser <span class="codefrag">EMPLEADO_EXTERNO</span> a ser <span class="codefrag">EMPLEADO_TIEMPO_COMPLETO_EXCEDENCIA</span>.</p>
<p>Podr&iacute;amos modificar la base de datos y ajustar todos las entidades, pero si los ordinales se utilizan en alg&uacute;n otro lugar tendr&iacute;amos que arreglarlo tambi&eacute;n. No es una buena pol&iacute;tica de mantenimiento.</p>
<p>Una soluci&oacute;n mejor ser&iacute;a almacenar el nombre del valor como una cadena en lugar de almacenar el ordinal. Esto nos aislar&iacute;a de los cambios en la declaraci&oacute;n y nos permitir&iacute;a a&ntilde;adir nuevos tipos sin tener que preocuparnos sobre los datos existentes. Podemos hacer esto a&ntilde;adiendo una anotaci&oacute;n <span class="codefrag">@Enumerated</span> en el atributo y especificando un valor de <span class="codefrag">STRING</span>. El siguiente c&oacute;digo muestra c&oacute;mo hacerlo:</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   @Enumerated(EnumType.STRING)
   private TipoEmpleado tipo;
   // ...
}</pre>
<p>Hay que hacer notar de esta forma no arreglamos el problema completamente. Ahora en la base de datos se guardan las cadenas <span class="codefrag">EMPLEADO_TIEMPO_COMPLETO</span> y dem&aacute;s. Si en alg&uacute;n momento modificamos el nombre de los valores del tipo enumerado tambi&eacute;n deber&iacute;amos cambiar los datos de la base de datos. Pero esto es menos frecuente, ya que un cambio en los valores de un tipo enumerado nos obliga a cambiar todo el c&oacute;digo en el que aparezcan los valores, y esto es bastante m&aacute;s serio que cambiar los datos de una columna de la base de datos.</p>
<p>En general, definir el tipo enumerado como un ordinal es la forma m&aacute;s eficiente de trabajar, pero siempre que no sea probable tener que a&ntilde;adir nuevos valores en medio de los ya existentes.</p>
<a name="N10296"></a><a name="Tipos+temporales"></a>
<h3 class="underlined_5">Tipos temporales</h3>
<p>Los tipos temporales son el conjunto de tipos basados en tiempo que pueden usarse en el mapeo entidad-relaci&oacute;n. La lista de tipos temporales soportados incluye los tres tipos <span class="codefrag">java.sql</span> <span class="codefrag">java.sql.Date</span>, <span class="codefrag">java.sql.Time</span> y <span class="codefrag">java.sql.Timestamp</span>, e incluye tambi&eacute;n los tipos <span class="codefrag">java.util</span> <span class="codefrag">java.util.Date</span> y <span class="codefrag">java.util.Calendar</span>.</p>
<p>El mapeo de los tipos <span class="codefrag">java.sql</span> no plantea ning&uacute;n problema en absoluto y se almacenan en la base de datos sin cambios. Los dos tipos <span class="codefrag">java.util</span> necesitan metadatos adicionales, para indicar qu&eacute; tipo JDBC <span class="codefrag">java.sql</span> hay que usar cuando el proveedor haga persistente la entidad. Esto se consigue anot&aacute;ndolos con la anotaci&oacute;n <span class="codefrag">@Temporal</span> y especificando el valor del tipo JDBC utilizando el valor correspondiente del tipo enumerado <span class="codefrag">TemporalType</span>. Hay tres valores enumerados: <span class="codefrag">DATE</span>, <span class="codefrag">TIME</span> y <span class="codefrag">TIMESTAMP</span> que representan cada uno de los tipos <span class="codefrag">java.sql</span>.</p>
<p>EL c&oacute;digo siguiente muestra c&oacute;mo <span class="codefrag">java.util.Date</span> y <span class="codefrag">java.util.Calendar</span> pueden mapearse a columnas de la base de datos.</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   @Temporal(TemporalType.DATE)
   private java.util.Date fechaNacimiento;
   @Temporal(TemporalType.TIMESTAMP)
   private java.util.Date horaSalida;
   // ...
}</pre>
<a name="N102E0"></a><a name="Estado+transitorio"></a>
<h3 class="underlined_5">Estado transitorio</h3>
<p>Es posible definir en la entidad atributos que no se hacen persistentes utilizando la palabra clave de Java <span class="codefrag">transient</span> o el atributo <span class="codefrag">@Transient</span>. Si se especifica alguna de estas propiedades, el proveedor no aplicar&aacute; las reglas por defecto al atributo marcado.</p>
<p>Los campos transitorios son &uacute;tiles, por ejemplo, para cachear un estado en memoria que no queremos recalcular o reinicializar. En el ejemplo siguiente usamos el campo transitorio <span class="codefrag">traduccion</span> para guardar la traducci&oacute;n de la palabra "Empleado" en el locale actual, de forma que se imprima correctamente el nombre. El uso del modificador Java <span class="codefrag">transient</span> hace que el atributo sea temporal no s&oacute;lo para la persistencia sino tambi&eacute;n para la m&aacute;quina virtual. Si el <span class="codefrag">Empleado</span> se serializa y se env&iacute;a desde una MV a otra el valor del atributo <span class="codefrag">traduccion</span> no se enviar&iacute;a.</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   private String nombre;
   private Long sueldo;
   transient private String traduccion;
   // ...

   public String toString() {
      if (traduccion == null) {
         traduccion =
            ResourceBundle.getBundle("EmpResources").getString("Empleado");
      }
      return traduccion + ": " + id + " " + nombre;
   }
}</pre>
</div>


<a name="N10304"></a><a name="Mapeo+de+la+clave+primaria"></a>
<h2 class="underlined_10">Mapeo de la clave primaria</h2>
<div class="section">
<p>Cualquier entidad mapeada en una base de datos relacional debe definir un mapeo a una clave primaria de la tabla. Vamos a explorar con algo m&aacute;s de detalle las claves primarias y c&oacute;mo conseguir que el proveedor de persistencia las genere para nosotros.</p>
<p>Los identificadores en entidades que despu&eacute;s se mapean a claves primarias en la tabla se restringen a los siguientes tipos:</p>
<ul>
		
<li>
<strong>Tipos Java primitivos</strong>: <span class="codefrag">byte</span>, <span class="codefrag">int</span>, <span class="codefrag">short</span>, <span class="codefrag">long</span>, <span class="codefrag">char</span>
</li>
		
<li>
<strong>Clases wrapper de tipos primitivos</strong>: <span class="codefrag">Byte</span>, <span class="codefrag">Integer</span>, <span class="codefrag">Short</span>, <span class="codefrag">Long</span>, <span class="codefrag">Character</span> 
</li>
		
<li>
<strong>Arrays de tipos primitivos o de clases wrappers</strong>
</li>
		
<li>
<strong>Cadenas</strong>: <span class="codefrag">java.lang.String</span>
</li>
		
<li>
<strong>Tipos num&eacute;ricos grandes</strong>: <span class="codefrag">java.math.BigInteger</span>
</li>
		
<li>
<strong>Tipos temporales</strong>: <span class="codefrag">java.util.Date</span>, <span class="codefrag">java.sql.Date</span>
</li>
   
</ul>
<p>Igual que con los mapeos b&aacute;sicos, la anotaci&oacute;n <span class="codefrag">@Column</span> puede utilizarse para modificar el nombre con el que el atributo identificador se hace persistente. Si no se utiliza sucede igual que con los mapeos b&aacute;sicos y el campo se guarda en la columna con el mismo nombre.</p>
<a name="N1035C"></a><a name="Generaci%C3%B3n+del+identificador"></a>
<h3 class="underlined_5">Generaci&oacute;n del identificador</h3>
<p>En muchas ocasiones no queremos preocuparnos de definir un nombre &uacute;nico para las instancias de algunas entidades de nuestro modelo de dominio y nos interesa que los identificadores se generen de forma autom&aacute;tica. A esto se le llama generaci&oacute;n de id y se especifica con la anotaci&oacute;n <span class="codefrag">@GeneratedValue</span>.</p>
<p>Cuando se utiliza la generaci&oacute;n de id, el proveedor de persistencia generar&aacute; un identificador &uacute;nico para cada instancia de un tipo dado. Una vez que se obtiene este identificador, el proveedor lo insertar&aacute; en la entidad; sin embargo, dependiendo de c&oacute;mo ha sido generado, puede ser que no se est&eacute; realmente presente en el objeto hasta que la entidad haya sido insertada en la base de datos. En otras palabras, la aplicaci&oacute;n no puede acceder al identificador hasta que se haya hecho un flush o se haya completado la transacci&oacute;n.</p>
<p>Existen cuatro estrategias de generaci&oacute;n de id que se seleccionan mediante el elemento <span class="codefrag">strategy</span> de la anotaci&oacute;n. Son <span class="codefrag">AUTO</span>, <span class="codefrag">TABLE</span>, <span class="codefrag">SEQUENCE</span> o <span class="codefrag">IDENTITY</span>, en la que se utilizan valores enumerados del tipo <span class="codefrag">GenerationType</span>. Vamos a ver solamente la primera.</p>
<a name="N10380"></a><a name="Generaci%C3%B3n+de+id+autom%C3%A1tica"></a>
<h4>Generaci&oacute;n de id autom&aacute;tica</h4>
<p>Una forma r&aacute;pida de obtener generaci&oacute;n de id autom&aacute;tica es mediante la estrategia <span class="codefrag">AUTO</span>. Con esta estrategia, dejamos que sea el proveedor de persistencia el que se ocupe de c&oacute;mo generar los identificadores. El siguiente c&oacute;digo muestra un ejemplo:</p>
<pre class="code">@Entity
public class Empleado {
   @Id @GeneratedValue(strategy=GenerationType.AUTO)
   private int id;
   // ...
}</pre>
<p> Un problema con esta estrategia es que es poco portable, ya que depende del proveedor de persistencia. En muchas ocasiones hay que recurrir al administrador de la base de datos para que configure alguna opci&oacute;n en la base de datos para habilitar o configurar esta caracter&iacute;stica en la base de datos que queramos utilizar.</p>
</div>


<a name="N10396"></a><a name="Objetos+embebidos"></a>
<h2 class="underlined_10">Objetos embebidos</h2>
<div class="section">
<p>Un <em>objeto embebido</em> es uno que no tiene identidad propia, y que est&aacute; ligado a una entidad. Es meramente una parte de una entidad que ha sido separada y almacenada en un objeto Java independiente para adaptar mejor el modelo de datos al dominio. En la definici&oacute;n de la entidad aparece un atributo con un tipo no b&aacute;sico. A primera vista parecer&iacute;a que se est&aacute; definiendo una relaci&oacute;n con otra entidad. Sin embargo, el tipo embebido no tiene entidad suficiente como para definir una entidad persistente por &eacute;l mismo. Sus datos se almacenan con el resto de la entidad en la misma fila de la base de datos.</p>
<p>Un ejemplo muy com&uacute;n es el tipo <span class="codefrag">Direccion</span>. Puede ser que en nuestro dominio una direcci&oacute;n no tenga las caracter&iacute;sticas que le hagan definir una entidad persistente (no vamos a hacer b&uacute;squedas por direcciones, ni identificadores de direcciones). Sin embargo, queremos guardar los datos que forman la direcci&oacute;n como un atributo del empleado. Y adem&aacute;s obtener los beneficios del modelo de objetos consider&aacute;ndolos uno &uacute;nico dato.</p>
<p>Las ventajas de agrupar un conjunto de campos en un nuevo tipo de datos Java son m&uacute;ltiples. En primer lugar, abstraemos el modelo f&iacute;sico (representaci&oacute;n en la tabla de la base de datos) y obtenemos una representaci&oacute;n m&aacute;s cercana al dominio de la aplicaci&oacute;n. Podremos utilizar objetos <span class="codefrag">Direccion</span> en distintas partes de la l&oacute;gica de negocio. En segundo lugar, podemos reutilizar este tipo en m&aacute;s de una entidad, dando consistencia a nuestro modelo f&iacute;sico. Por &uacute;ltimo, es una forma muy portable de conseguir una caracter&iacute;sticas de SQL que nunca se ha llegado a estandarizar: el uso de tipos definidos por el usuario.</p>
<p>Vamos a ver el ejemplo con m&aacute;s detalle. La siguiente figura muestra una tabla <span class="codefrag">EMPLEADO</span> que contiene una mezcla de informaci&oacute;n propia del empleado y de columnas que definen su direcci&oacute;n:</p>
<p>
<img alt="" content-width="3cm" src="imagenes/tabla-extendida.png" width="142"></p>
<p>Las columnas <span class="codefrag">CALLE</span>, <span class="codefrag">CIUDAD</span>, <span class="codefrag">PROVINCIA</span> y <span class="codefrag">COD_POSTAL</span> se combinan l&oacute;gicamente para formar la direcci&oacute;n. En el modelo de objetos podr&iacute;amos perfectamente abstraer esta informaci&oacute;n en tipo embebido <span class="codefrag">Direccion</span>. La clase entidad tendr&iacute;a entonces una atributo <span class="codefrag">direccion</span> que referenciar&iacute;a un objeto embebido de tipo <span class="codefrag">Direccion</span>. La siguiente figura muestra la relaci&oacute;n entre <span class="codefrag">Empleado</span> y <span class="codefrag">Direccion</span>. Utilizamos la asociaci&oacute;n UML <em>composici&oacute;n</em> para denotar que el <span class="codefrag">Empleado</span> posee completamente la <span class="codefrag">Direccion</span> y que una instancia de <span class="codefrag">Direccion</span> no debe ser compartida con ning&uacute;n otro objeto salvo la instancia de <span class="codefrag">Empleado</span> que lo posee.</p>
<p>
<img alt="" content-width="8cm" src="imagenes/direccion.png" width="416"></p>
<p>Con esta representaci&oacute;n, no s&oacute;lo la informaci&oacute;n de la direcci&oacute;n se encapsula de forma limpia dentro de un objeto, sino que otras entidades como <span class="codefrag">Empresa</span> pueden tambi&eacute;n utilizar el tipo y tener sus propios atributos de con objetos embebidos de tipo <span class="codefrag">Direccion</span>.</p>
<p>Para definir el tipo embebido debemos utilizar la anotaci&oacute;n <span class="codefrag">@Embeddable</span> en la definici&oacute;n de la clase. Esta anotaci&oacute;n sirve para diferenciar la clase de otras clases normales Java. Una vez que la clase ha sido definida como embebible, sus atributos se har&aacute;n persistentes como parte de la entidad. Los atributos de mapeo de columnas <span class="codefrag">@Basic</span>, <span class="codefrag">@Temporal</span>, <span class="codefrag">@Enumerado</span>, <span class="codefrag">@Lob</span> y <span class="codefrag">@Column</span> pueden a&ntilde;adirse a los atributos de la clase embebida. El c&oacute;digo siguiente muestra un ejemplo.</p>
<pre class="code">@Embeddable
public class Direccion {
   private String calle;
   private String ciudad;
   private String provincia;
   @Column(name="COD_POSTAL")
   private String codigoPostal;
   // ...
}</pre>
<p>Para usar esta clase en una entidad hay que declararla con la anotaci&oacute;n <span class="codefrag">@Embedded</span>. Se muestra a continuaci&oacute;n.</p>
<pre class="code">@Entity
public class Empleado {
   @Id private int id;
   private String nombre;
   private Long sueldo;
   @Embedded private Direccion direccion;
   // ...
}</pre>
<p>Cuando el proveedor realice la persistencia de una instancia de <span class="codefrag">Empleado</span> acceder&aacute; a los atributos del objeto <span class="codefrag">Direccion</span> como si estuvieran presentes en la propia instancia. El mapeado de las columnas del tipo <span class="codefrag">Direccion</span> se realiza realmente en la tabla <span class="codefrag">EMPLEADO</span>.</p>
</div>


<a name="N1042B"></a><a name="Mapeado+de+las+relaciones+de+herencia"></a>
<h2 class="underlined_10">Mapeado de las relaciones de herencia</h2>
<div class="section">
<p>Una de las diferencias fundamentales entre un modelo orientado a objetos y un modelo relacional es la existencia en el primero de herencia entre clases o entidades. La definici&oacute;n de herencia es algo muy natural y &uacute;til en modelos orientados a objetos. Por ejemplo, siguiendo con nuestro ejemplo de <span class="codefrag">Empleado</span>, supongamos que queremos definir dos tipos de empleado: <span class="codefrag">EmpleadoContratado</span> y <span class="codefrag">EmpleadoBecario</span>, cada uno de ellos con sus propios atributos adicionales. Supongamos tambi&eacute;n que cualquier empleado deba ser de uno de los subtipos, de forma que no se permita crear instancias del tipo padre. Para ello, en programaci&oacute;n OO deber&iacute;amos definir la clase <span class="codefrag">Empleado</span> como <em>abstracta</em> y las dos clases deber&iacute;an ser subclases de ella.</p>
<p>
<img alt="" content-width="6cm" src="imagenes/jpa-herencia.png" width="500"></p>
<p>JPA permite mapear estas relaciones de herencia en tablas de la base de datos. Existen tres posibles estrategias para realizar este mapeo:</p>
<ul>
	
<li>Tabla &uacute;nica</li>
	
<li>Tablas join</li>
	
<li>Una tabla por clase</li>

</ul>
<p>Vamos a ver la estrategia m&aacute;s com&uacute;n, la de tabla &uacute;nica.</p>
<p>En la estrategia de tabla &uacute;nica, todas las clases en la jerarqu&iacute;a de herencia se mapean en una &uacute;nica tabla. Esta tabla contiene almacenadas todas las instancias de todos los posibles subtipos. Los distintos objetos en la jerarqu&iacute;a OO se identifican utilizando una columna especial denominada columna discriminante (<em>disriminator column</em>). Esta columna contiene un valor distinto seg&uacute;n la clase a la que pertenezca el objeto. Adem&aacute;s, las columnas que no se correspondan con atributos de un tipo dado se rellenan con NULL.</p>
<p>Supongamos que un <span class="codefrag">EmpleadoBecario</span> tiene un atributo <span class="codefrag">SeguroMedico</span> de tipo <span class="codefrag">Long</span> con la aportaci&oacute;n que debe realizar la empresa para el seguro del empleado. Y el <span class="codefrag">EmpleadoContratado</span> tienen un atributo <span class="codefrag">PlanPensiones</span> de tipo <span class="codefrag">Long</span> con la aportaci&oacute;n para el plan de pensiones.</p>
<p>En la figura siguiente aparece la tabla &uacute;nica que guardar&iacute;a entidades de ambos tipos. La columna discriminante es la columna <span class="codefrag">Tipo</span>. La tabla contiene todos los registros. Los registros que se corresponden con empleados contratados tienen el valor <span class="codefrag">Contrato</span> en la columna discriminante y los empleados becarios <span class="codefrag">Beca</span>. Las columnas que no se correspondan con el tipo de entidad est&aacute;n a NULL.</p>
<p>
<img alt="" content-width="8cm" src="imagenes/jpa-herencia-tabla.png" width="600"></p>
<p>Para implementar la herencia en JPA se utiliza la anotaci&oacute;n <span class="codefrag">@Inheritance</span> en la clase padre. En esta anotaci&oacute;n hay que indicar la estrategia de mapeado utilizada con el elemento <span class="codefrag">strategy</span>. Tambi&eacute;n hay que a&ntilde;adir a la clase padre la anotaci&oacute;n <span class="codefrag">@DiscriminatorValue</span> que indica la columna discriminante. El tipo de la columna discriminante se define con el elemento <span class="codefrag">discriminatorType</span> que puede tomar como valor las constantes <span class="codefrag">DiscriminatorType.STRING</span>, <span class="codefrag">DiscriminatorType.INTEGER</span> o <span class="codefrag">DiscriminatorType.CHAR</span>.</p>
<p>El siguiente c&oacute;digo muestra c&oacute;mo ser&iacute;a la definici&oacute;n de la clase <span class="codefrag">Empleado</span>. Hay que hacer notar la declaraci&oacute;n de la clase como <span class="codefrag">abstract</span> que impide crear instancias.</p>
<pre class="code">@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name="Tipo", discriminatorType=DiscriminatorType.STRING)
public abstract class Empleado {
   ...
}</pre>
<p>Las subclases de la jerarqu&iacute;a se definen igual que en Java est&aacute;ndar (recordemos que las entidades son clases Java normales) con la palabra clave <span class="codefrag">extends</span>. Lo &uacute;nico que hay que a&ntilde;adir es el valor en la columna discriminante que se le asigna a esta clase. Para ello se utiliza la anotaci&oacute;n <span class="codefrag">DiscriminatorValue</span> y su atributo <span class="codefrag">value</span>. Por ejemplo, si el <span class="codefrag">EmpleadoBecario</span> va a tener como valor la cadena <span class="codefrag">Beca</span>, hay que indicar:</p>
<pre class="code">@DiscriminatorValue(value="Beca")</pre>
<p>Las definiciones de las subclases las mostramos a continuaci&oacute;n. Primero la clase <span class="codefrag">EmpleadoContratado</span>, que se asocia al valor <span class="codefrag">Contrato</span> de la columna discriminante. En la nueva clase se define al atributo espec&iacute;fico <span class="codefrag">Long planPensiones</span>.</p>
<pre class="code">import javax.persistence.*;

@Entity
@DiscriminatorValue(value="Contrato")
public class EmpleadoContratado extends Empleado {
   private Long planPensiones;

   public Long getPlanPensiones() {
      return planPensiones;
   }

   public void setPlanPensiones(Long planPensiones) {
      this.planPensiones = planPensiones;
   }
}</pre>
<p>Por &uacute;ltimo, la clase <span class="codefrag">EmpleadoBecario</span> se distingue por el valor <span class="codefrag">Beca</span>. En la clase se define el nuevo atributo <span class="codefrag">Long seguroMedico</span>
</p>
<pre class="code">@Entity
@DiscriminatorValue(value="Beca")
public class EmpleadoBecario extends Empleado {
   private Long seguroMedico;

   public Long getSeguroMedico() {
      return seguroMedico;
   }

   public void setSeguroMedico(Long seguroMedico) {
      this.seguroMedico = seguroMedico;
   }
}</pre>
<p>Con esto es suficiente. Una vez definidas, las entidades se usan como clases Java normales:</p>
<pre class="code">Empleado emp = new EmpleadoContratado();
emp.setId(id);
emp.setNombre(nombre);
emp.setSueldo(sueldo);
emp.setPlanPensiones(sueldo/10);</pre>
</div>



<p class="pageBreakAfter"></p>

</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2007-2008 Depto. CCIA</div>
</div>
</body>
</html>
