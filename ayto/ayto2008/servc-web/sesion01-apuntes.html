<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a los Servicios Web</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web" src="images/baner_j2ee_der.gif" title="Servicios Web"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesion 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html" title="Roadmap">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a los Servicios Web</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+Servicio+Web%3F">&iquest;Qu&eacute; es un Servicio Web?</a>
</li>
<li>
<a href="#Caracter%C3%ADsticas+de+los+Servicios+Web">Caracter&iacute;sticas de los Servicios Web</a>
</li>
<li>
<a href="#Arquitecturas+Orientadas+a+Servicios">Arquitecturas Orientadas a Servicios</a>
</li>
<li>
<a href="#Arquitectura+de+los+Servicios+Web">Arquitectura de los Servicios Web</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+b%C3%A1sicas">Tecnolog&iacute;as b&aacute;sicas</a>
<ul class="minitoc">
<li>
<a href="#SOAP">SOAP</a>
</li>
<li>
<a href="#WSDL">WSDL</a>
</li>
<li>
<a href="#UDDI">UDDI</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n">Tecnolog&iacute;as de segunda generaci&oacute;n</a>
</li>
<li>
<a href="#WS-I+Basic+Profile">WS-I Basic Profile</a>
</li>
</ul>
</li>
<li>
<a href="#Tecnolog%C3%ADas+J2EE+para+Servicios+Web">Tecnolog&iacute;as J2EE para Servicios Web</a>
<ul class="minitoc">
<li>
<a href="#JAXP">JAXP</a>
</li>
<li>
<a href="#JAXM">JAXM</a>
</li>
<li>
<a href="#JAX-RPC+%2F+JAX-WS">JAX-RPC / JAX-WS</a>
</li>
<li>
<a href="#JAXR">JAXR</a>
</li>
<li>
<a href="#JAXB">JAXB</a>
</li>
<li>
<a href="#Otras+librer%C3%ADas">Otras librer&iacute;as</a>
<ul class="minitoc">
<li>
<a href="#WSDL4J">WSDL4J</a>
</li>
<li>
<a href="#WSIF">WSIF</a>
</li>
<li>
<a href="#UDDI4J">UDDI4J</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Probar+servicios+web+con+Eclipse">Probar servicios web con Eclipse</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+Servicios">Invocaci&oacute;n de Servicios</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+acceso">Tipos de acceso</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+mediante+stub+est%C3%A1tico">Invocaci&oacute;n mediante stub est&aacute;tico</a>
<ul class="minitoc">
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+JDK+1.6">Invocaci&oacute;n de servicios web con JDK 1.6</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+Eclipse+%28Axis%29">Invocaci&oacute;n de servicios web con Eclipse (Axis)</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+servicios+web+con+Netbeans">Invocaci&oacute;n de servicios web con Netbeans</a>
</li>
<li>
<a href="#Gestor+de+servicios+web+de+Netbeans">Gestor de servicios web de Netbeans</a>
</li>
<li>
<a href="#JAX-RPC+en+Netbeans">JAX-RPC en Netbeans</a>
</li>
</ul>
</li>
<li>
<a href="#Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</a>
<ul class="minitoc">
<li>
<a href="#A+partir+de+un+documento+WSDL">A partir de un documento WSDL</a>
</li>
<li>
<a href="#Sin+un+documento+WSDL">Sin un documento WSDL</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<p>El dise&ntilde;o del software tiende a ser cada vez m&aacute;s modular. Las 
  aplicaciones se componen de una serie de componentes (servicios) reutilizables, 
  que pueden encontrarse distribuidos a lo largo de una serie de m&aacute;quinas 
  conectadas en red.</p>

<p>Los Servicios Web nos permitir&aacute;n distribuir nuestra aplicaci&oacute;n 
  a trav&eacute;s de Internet, pudiendo una aplicaci&oacute;n utilizar los servicios 
  ofrecidos por cualquier servidor conectado a Internet.</p>


<a name="N10012"></a><a name="%C2%BFQu%C3%A9+es+un+Servicio+Web%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es un Servicio Web?</h2>
<div class="section">
<p>Un Servicio Web es un componente al que podemos acceder mediante protocolos 
  Web est&aacute;ndar, utilizando XML para el intercambio de informaci&oacute;n.</p>
<p>Normalmente nos referimos con Servicio Web a una colecci&oacute;n de procedimientos 
  (m&eacute;todos) a los que podemos llamar desde cualquier lugar de Internet 
  o de nuestra intranet, siendo este mecanismo de invocaci&oacute;n totalmente 
  independiente de la plataforma que utilicemos y del lenguaje de programaci&oacute;n 
  en el que se haya implementado internamente el servicio.</p>
<p>Cuando conectamos a un servidor web desde nuestro navegador, el servidor nos 
  devuelve la p&aacute;gina web solicitada, que es un documento que se mostrar&aacute; 
  en el navegador para que lo visualice el usuario, pero es dif&iacute;cilmente 
  entendible por una m&aacute;quina. Podemos ver esto como web para humanos. En 
  contraposici&oacute;n, los Servicios Web ofrecen informaci&oacute;n con un formato 
  est&aacute;ndar que puede ser entendido f&aacute;cilmente por una aplicaci&oacute;n. 
  En este caso estar&iacute;amos ante una web para m&aacute;quinas. </p>
</div>

<a name="N10022"></a><a name="Caracter%C3%ADsticas+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Caracter&iacute;sticas de los Servicios Web</h2>
<div class="section">
<p>Las caracter&iacute;sticas deseables de un Servicio Web son:</p>
<ul>
  
<li>Un servicio debe poder ser <strong>accesible a trav&eacute;s de la Web</strong>. 
    Para ello debe utilizar protocolos de transporte est&aacute;ndares como HTTP, 
    y codificar los mensajes en un lenguaje est&aacute;ndar que pueda conocer 
    cualquier cliente que quiera utilizar el servicio.</li>
  
<li>Un servicio debe contener una <strong>descripci&oacute;n de s&iacute; mismo</strong>. 
    De esta forma, una aplicaci&oacute;n podr&aacute; saber cu&aacute;l es la 
    funci&oacute;n de un determinado Servicio Web, y cu&aacute;l es su interfaz, 
    de manera que pueda ser utilizado de forma autom&aacute;tica por cualquier 
    aplicaci&oacute;n, sin la intervenci&oacute;n del usuario.</li>
  
<li>Debe poder <strong>ser localizado</strong>. Deberemos tener alg&uacute;n 
    mecanismo que nos permita encontrar un Servicio Web que realice una determinada 
    funci&oacute;n. De esta forma tendremos la posibilidad de que una aplicaci&oacute;n 
    localice el servicio que necesite de forma autom&aacute;tica, sin tener que 
    conocerlo previamente el usuario.</li>

</ul>
</div>

<a name="N10041"></a><a name="Arquitecturas+Orientadas+a+Servicios"></a>
<h2 class="underlined_10">Arquitecturas Orientadas a Servicios</h2>
<div class="section">
<p>Las arquitecturas orientadas a servicios (SOA) se basan en el desarrollo de servicios altamente reutilizables, y en la combinaci&oacute;n de estos servicios para dar lugar a nuestra aplicaci&oacute;n.</p>
<p>Estos servicios idealmente deber&iacute;an tener una interfaz est&aacute;ndar bien definida, de forma que se pueda integrar f&aacute;cilmente en cualquier aplicaci&oacute;n. Adem&aacute;s no debe tener estado, ni depender del estado de otros componentes. Debe recibir toda la informaci&oacute;n necesaria en la petici&oacute;n.
</p>
<p>Se conoce como <em>orquestaci&oacute;n</em> de servicios la secuenciaci&oacute;n de llamadas a diferentes servicios para realizar un determinado proceso de negocio. Al no tener estado, los servicios se podr&aacute;n secuenciar en cualquier orden, pudiendo formar as&iacute; diferentes flujos que implementen la l&oacute;gica de negocio.</p>
<p>Normalmente cuando hablamos de arquitecturas orientadas a servicios pensamos en su implementaci&oacute;n mediante servicios web. Sin embargo, estas arquitecturas puedes estar formadas por cualquier tipo de servicio, como pueden ser por ejemplo servicios accesibles mediante JMS. En el caso de una SOA implementada mediante Servicios Web, sus servicios ser&aacute;n accesibles a trav&eacute;s de la web.</p>
<p>En una arquitectura orientada a servicios podemos distinguir tres agentes con diferentes funciones:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Proveedor de servicio</strong> </td>
    <td colspan="2" rowspan="1">Implementa unas determinadas operaciones (servicio). Un cliente 
      podr&aacute; solicitar uno de estos servicios a este proveedor. </td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Cliente del servicio</strong></td>
    <td colspan="2" rowspan="1">Invoca a un proveedor de servicio para la realizaci&oacute;n de alguna 
      de los operaciones que proporciona.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Registro de servicios</strong></td>
    <td colspan="2" rowspan="1">Mantiene una lista de proveedores de servicios disponibles, junto a sus 
      descripciones.</td>
  
</tr>

</table>
<p>El mecanismo b&aacute;sico de invocaci&oacute;n de servicios consistir&aacute; 
  en que un cliente solicitar&aacute; un determinado servicio a un proveedor, 
  efectuando el proveedor dicho servicio. El servidor devolver&aacute; una respuesta 
  al cliente como resultado del servicio invocado.</p>
<p>Esto podremos hacerlo as&iacute; si el cliente conoce de antemano el proveedor 
  del cual va a obtener el servicio. Pero hemos de pensar que en Internet encontraremos 
  una gran cantidad de Servicios Web dispersos, lo cual har&aacute; dif&iacute;cil 
  localizar el que busquemos. Adem&aacute;s, si hemos localizado uno que realiza 
  la funci&oacute;n que necesitamos, si dicho servicio no est&aacute; mantenido 
  por nosotros puede ocurrir que en alg&uacute;n momento este servicio cambie 
  de lugar, de interfaz o simplemente desaparezca, por lo que no podremos confiar 
  en que vayamos a poder utilizar siempre este mismo servicio.</p>
<p>Los registros de servicios nos permiten automatizar la localizaci&oacute;n 
  de Servicios Web. Un proveedor puede <em>anunciarse </em>en un determinado registro, 
  de forma que figurar&aacute; en dicho registro la localizaci&oacute;n de este 
  servicio junto a una descripci&oacute;n de su funcionalidad y de su interfaz, 
  que podr&aacute; ser entendida por una aplicaci&oacute;n.</p>
<p>Cuando un cliente necesite un determinado servicio, puede acudir directamente 
  a un registro y solicitar el tipo de servicio que necesita. Para ello es importante 
  establecer un determinada sem&aacute;ntica sobre las posibles descripciones 
  de funcionalidades de servicios, evitando las posibles ambig&uuml;edades.</p>
<p>El registro devolver&aacute; entonces una lista de servicios que realicen la 
  funci&oacute;n deseada, de los cuales el cliente podr&aacute; elegir el m&aacute;s 
  apropiado, analizar su interfaz, e invocarlo.</p>
</div>

<a name="N100A5"></a><a name="Arquitectura+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web</h2>
<div class="section">
<p>Los protocolos utilizados en los Servicios Web se organizan en una serie de 
  capas:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Capa</strong></td>
    <td colspan="2" rowspan="1"><strong>Descripci&oacute;n</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Transporte de servicios</em></td>
    <td colspan="2" rowspan="1">Es la capa que se encarga de transportar los mensajes entre aplicaciones. 
      Normalmente se utiliza el protocolo <strong>HTTP</strong> para este transporte, 
      aunque los servicios web pueden viajar mediante otros protocolos de transferencia 
      de hipertexto como SMTP, FTP o BEEP.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Mensajer&iacute;a XML</em></td>
    <td colspan="2" rowspan="1">Es la capa responsable de codificar los mensajes en XML de forma que puedan 
      ser entendidos por cualquier aplicaci&oacute;n. Puede implementar los protocolos 
      XML-RPC o<strong> SOAP</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Descripci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga de definir la interfaz p&uacute;blica de un determinado servicio. 
      Est&aacute; definici&oacute;n se realiza mediante <strong>WSDL</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Localizaci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga del registro centralizado de servicios, permitiendo que estos 
      sean anunciados y localizados. Para ello se utiliza el protocolo <strong>UDDI</strong>.</td>
  
</tr>

</table>
<p>M&aacute;s adelante describiremos cada una de las tecnolog&iacute;as para Servicios 
  Web vistas en las distintas capas.</p>
</div>

<a name="N10113"></a><a name="Tecnolog%C3%ADas+b%C3%A1sicas"></a>
<h2 class="underlined_10">Tecnolog&iacute;as b&aacute;sicas</h2>
<div class="section">
<p>Tenemos una serie de tecnolog&iacute;as, todas ellas basadas en XML, que son 
  fundamentales para el desarrollo de Servicios Web. Estas tecnolog&iacute;as 
  son independientes tanto del SO como del lenguaje de programaci&oacute;n utilizado 
  para implementar dichos servicios. Por lo tanto, ser&aacute;n utilizadas para 
  cualquier Servicio Web, independientemente de la plataforma sobre la que construyamos 
  dichos servicios (como puede ser J2EE o .NET). </p>
<a name="N1011C"></a><a name="SOAP"></a>
<h3 class="underlined_5">SOAP</h3>
<p>Se trata de un protocolo derivado de XML que nos sirve para intercambiar informaci&oacute;n 
  entre aplicaciones.</p>
<p>Normalmente utilizaremos SOAP para conectarnos a un servicio e invocar m&eacute;todos 
  remotos, aunque puede ser utilizado de forma m&aacute;s gen&eacute;rica para 
  enviar cualquier tipo de contenido. Podemos distinguir dos tipos de mensajes 
  seg&uacute;n su contenido:</p>
<ul>
  
<li>
<strong>Mensajes orientados al documento</strong>: Contienen cualquier tipo 
    de contenido que queramos enviar entre aplicaciones.</li>
  
<li>
<strong>Mensajes orientados a RPC</strong>: Este tipo de mensajes servir&aacute; 
    para invocar procedimientos de forma remota (<em>Remote Procedure Calls</em>). 
    Podemos verlo como un tipo m&aacute;s concreto dentro del tipo anterior, ya 
    que en este caso como contenido del mensaje especificaremos el m&eacute;todo 
    que queremos invocar junto a los par&aacute;metros que le pasamos, y el servidor 
    nos deber&aacute; devolver como respuesta un mensaje SOAP con el resultado 
    de invocar el m&eacute;todo.</li>

</ul>
<p>Puede ser utilizado sobre varios protocolos de transporte, aunque est&aacute; 
  especialmente dise&ntilde;ado para trabajar sobre HTTP.</p>
<p>Dentro del mensaje SOAP podemos distinguir los siguientes elementos:</p>
<p>
<img alt="Elementos de un mensaje SOAP" content-width="4cm" height="225" src="imagenes/soap.gif" width="203"></p>
<ul>
  
<li>Un sobre (<span class="codefrag">Envelope</span>), que describe el mensaje, a quien va 
    dirigido, y c&oacute;mo debe ser procesado. El sobre incluye las definiciones 
    de tipos que se usar&aacute;n en el documento. Contiene una cabecera de forma 
    opcional, y el cuerpo del mensaje.</li>
  
<li>Una cabecera (<span class="codefrag">Header</span>) opcional, donde podemos incluir informaci&oacute;n 
    sobre el mensaje. Por ejemplo, podemos especificar si el mensaje es obligatorio 
    (debe ser entendido de forma obligatoria por el destinatario), e indicar los 
    actores (lugares por donde ha pasado el mensaje).</li>
  
<li>El cuerpo del mensaje (<span class="codefrag">Body</span>), que contiene el mensaje en 
    si. En el caso de los mensajes RPC se define una convenci&oacute;n sobre como 
    debe ser este contenido, en el que se especificar&aacute; el m&eacute;todo 
    al que se invoca y los valores que se pasan como par&aacute;metros. Puede 
    contener un error de forma opcional.</li>
  
<li>Un error (<span class="codefrag">Fault</span>) en el cuerpo del mensaje de forma opcional. 
    Nos servir&aacute; para indicar en una respuesta SOAP que ha habido un error 
    en el procesamiento del mensaje de petici&oacute;n que mandamos.</li>

</ul>
<p>Hemos visto como los mensajes SOAP nos sirven para intercambiar cualquier documento 
  XML entre aplicaciones. Pero puede ocurrir que necesitemos enviar en el mensaje 
  datos que no son XML, como puede ser una imagen. En ese caso tendremos que recurrir 
  a la especificaci&oacute;n de mensajes SOAP con anexos.</p>
<p>Los mensajes SOAP con anexos a&ntilde;aden un elemento m&aacute;s al mensaje:</p>
<p>
<img alt="Elementos de un mensaje SOAP con Anexos" content-width="4cm" height="269" src="imagenes/swa.gif" width="203"></p>
<ul>
  
<li>El anexo (<span class="codefrag">Attachment</span>), puede contener cualquier tipo de 
    contenido (incluido el XML). De esta forma podremos enviar cualquier tipo 
    de contenido junto a un mensaje SOAP.</li>

</ul>
<p>Nuestro mensaje podr&aacute; contener tantos anexos como queramos.</p>
<p>Un ejemplo de mensaje SOAP es el siguiente:</p>
<pre class="code">&lt;SOAP-ENV:Envelope 
 xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"    
 SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;    
    &lt;SOAP-ENV:Body&gt; 
        &lt;ns:getTemperatura xmlns:ns="http://j2ee.ua.es/ns"&gt;    
            &lt;area&gt;Alicante&lt;/area&gt; 
        &lt;/ns:getTemperatura&gt; 
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
<p>En &eacute;l estamos llamando a nuestro m&eacute;todo <span class="codefrag">getTemperatura</span> 
  para obtener informaci&oacute;n meteorol&oacute;gica, proporcionando como par&aacute;metro 
  el &aacute;rea de la que queremos obtener la temperatura.</p>
<p>Podemos encontrar la especificaci&oacute;n de SOAP y SOAP con anexos publicada 
  en la p&aacute;gina del W3C, en las direcciones <span class="codefrag">http://www.w3.org/TR/SOAP/</span> 
  y <span class="codefrag">http://www.w3.org/TR/SOAP-attachments</span> respectivamente.</p>
<p></p>
<a name="N10194"></a><a name="WSDL"></a>
<h3 class="underlined_5">WSDL</h3>
<p>Es otro lenguaje derivado de XML, que se utiliza para describir los Servicios 
  Web, de forma que una aplicaci&oacute;n pueda conocer de forma autom&aacute;tica 
  la funci&oacute;n de un Servicio Web, as&iacute; como la forma de uso de dicho 
  Servicio Web.</p>
<p>El fichero WSDL describir&aacute; la interfaz del Servicio Web, con los m&eacute;todos 
  a los que podemos invocar, los par&aacute;metros que debemos proporcionarles 
  y los tipos de datos de dichos par&aacute;metros.</p>
<p>Si desarrollamos un Servicio Web, y queremos que otras personas sean capaces 
  de utilizar nuestro servicio para sus aplicaciones, podremos proporcionar un 
  documento WSDL describiendo nuestro servicio. De esta forma, a partir de este 
  documento otros usuarios podr&aacute;n generar aplicaciones clientes en cualquier 
  plataforma (ya que WSDL se define como un est&aacute;ndar) que se ajusten a 
  nuestro servicio.</p>
<p>El elemento ra&iacute;z dentro de este fichero es <span class="codefrag">definitions</span>, 
  donde se especifican los espacios de nombres que utilizamos en nuestro servicio. 
  Dentro de este elemento ra&iacute;z encontramos los siguientes elementos:</p>
<ul>
  
<li>
<span class="codefrag">types</span>: Se utiliza para definir los tipos de datos que se 
    intercambiar&aacute;n en el mensaje.</li>
  
<li>
<span class="codefrag">message</span>: Define los distintos mensajes que se intercambiaran 
    durante el proceso de invocaci&oacute;n del servicio. Se deber&aacute;n definir 
    los mensajes de entrada y salida para cada operaci&oacute;n que ofrezca el 
    servicio. En el caso de mensajes RPC, en el mensaje de entrada se definir&aacute;n 
    los tipos de par&aacute;metros que se proporcionan, y en el de salida el tipo 
    del valor devuelto.</li>
  
<li>
<span class="codefrag">portType</span>: Define las operaciones que ofrece el servicio. 
    De cada operaci&oacute;n indica cuales son los mensajes de entrada y salida, 
    de entre los mensajes definidos en el apartado anterior.</li>
  
<li>
<span class="codefrag">binding</span>: Indica el protocolo y el formato de los datos 
    para cada mensaje de los definidos anteriormente. Este formato puede ser orientado 
    al documento u orientado a RPC. Si es orientado al documento tanto el mensaje 
    de entrada como el de salida contendr&aacute;n un documento XML. Si es orientado 
    a RPC el mensaje de entrada contendr&aacute; el m&eacute;todo invocado y sus 
    par&aacute;metros, y el de salida el resultado de invocar dicho m&eacute;todo, 
    siguiendo una estructura m&aacute;s restrictiva.</li>
  
<li>
<span class="codefrag">service</span>: Define el servicio como una colecci&oacute;n de 
    puertos a los que se puede acceder. Un puerto es la direcci&oacute;n (URL) 
    donde el servicio act&uacute;a. Esta ser&aacute; la direcci&oacute;n a la 
    que las aplicaciones deber&aacute;n conectarse para acceder al servicio. Adem&aacute;s 
    contiene la documentaci&oacute;n en lenguaje natural del servicio.</li>

</ul>
<p>Un documento WSDL de ejemplo es el siguiente:</p>
<pre class="code">&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
  &lt;<strong>definitions</strong> xmlns:s="http://www.w3.org/2001/XMLSchema"
     xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"    
     xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
     xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
     xmlns:tns="http://j2ee.ua.es/wsdl"
     xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" 
     targetNamespace="http://j2ee.ua.es/wsdl"
     xmlns="http://schemas.xmlsoap.org/wsdl/"&gt;
   &lt;<strong>message</strong> name="getTempRequest"&gt;
     &lt;part name="string_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:string" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>message</strong> name="getTempResponse"&gt;
     &lt;part name="double_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:double" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>portType</strong> name="TempPortType"&gt;
     &lt;operation name="getTemp"&gt;
       &lt;input message="tns:getTempRequest" /&gt; 
       &lt;output message="tns:getTempResponse" /&gt; 
     &lt;/operation&gt;
   &lt;/<strong>portType</strong>&gt;
   &lt;<strong>binding</strong> name="TempPortSoapBinding" type="tns:TempPortType"&gt;
     &lt;soap:binding style="rpc" 
         transport="http://schemas.xmlsoap.org/soap/http" /&gt; 
     &lt;operation name="getTemp"&gt;
       &lt;soap:operation soapAction=" style="rpc" /&gt; 
       &lt;input&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl" 
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/input&gt;
       &lt;output&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl"    
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/output&gt;
     &lt;/operation&gt;
   &lt;/<strong>binding</strong>&gt;
   &lt;<strong>service</strong> name="Temp"&gt;
     &lt;documentation&gt;Documentacion&lt;/documentation&gt;    
     &lt;port name="TempPort" binding="tns:TempPortSoapBinding"&gt;
       &lt;soap:address 
           location="http://localhost:7001/sw_temp/Temp" /&gt; 
     &lt;/port&gt;
   &lt;/<strong>service</strong>&gt;
&lt;/<strong>definitions</strong>&gt;</pre>
<p>En el que se define un servicio que proporciona el m&eacute;todo <span class="codefrag">getTemp</span>, 
  que toma como par&aacute;metro una cadena con el nombre del &aacute;rea que 
  queremos consultar, y nos devuelve un valor real. </p>
<p>En los elementos <span class="codefrag">message</span> vemos que tenemos dos mensajes: los 
  mensajes de entrada y salida de la operaci&oacute;n <span class="codefrag">getTemp</span> de nuestro 
  servicio. El mensaje de entrada contiene un dato de tipo <span class="codefrag">string</span> (el 
  par&aacute;metro del m&eacute;todo), y el de salida es de tipo <span class="codefrag">double</span> 
  (la temperatura que devuelve el servicio).</p>
<p>El elemento <span class="codefrag">portType</span> define la operaci&oacute;n <span class="codefrag">getTemp</span> 
  a partir de los mensajes de entrada y salida que la componen, y en <span class="codefrag">binding</span> 
  se establece esta operaci&oacute;n como de estilo <span class="codefrag">rpc</span>, con codificaci&oacute;n 
  <span class="codefrag">encoded</span>. Esto es lo que se conoce como tipo <span class="codefrag">rpc/encoded</span>. Actualmente
  dicho tipo de servicios est&aacute; desaprobado. Los servicios web deben ser en su lugar de
  tipo <span class="codefrag">document/literal</span>.</p>
<p>Por &uacute;ltimo en el apartado <span class="codefrag">service</span> se especifica el 
  puerto al que podemos conectar para usar el servicio, dando la URL a la que 
  nuestro cliente deber&aacute; acceder. </p>
<p>Podemos encontrar la especificaci&oacute;n de WSDL publicada en la p&aacute;gina 
  del W3C, en la direcci&oacute;n <span class="codefrag">http://www.w3.org/TR/wsdl</span>.</p>
<p></p>
<a name="N1022C"></a><a name="UDDI"></a>
<h3 class="underlined_5">UDDI</h3>
<p>UDDI nos permite localizar Servicios Web. Para ello define la especificaci&oacute;n 
  para construir un directorio distribuido de Servicios Web, donde los datos se 
  almacenan en XML. En este registro no s&oacute;lo se almacena informaci&oacute;n sobre 
  servicios, sino tambi&eacute;n sobre las organizaciones que los proporcionan, la 
  categor&iacute;a en la que se encuentran, y sus instrucciones de uso (normalmente 
  WSDL). Tenemos por lo tanto 3 tipos de informaci&oacute;n relacionados entre s&iacute;:</p>
<ul>
  
<li>
<em>P&aacute;ginas blancas</em>: Datos de las organizaciones (direcci&oacute;n, informaci&oacute;n de contacto, etc).</li>
  
<li>
<em>P&aacute;ginas amarillas</em>: Clasificaci&oacute;n de las organizaciones (seg&uacute;n tipo de industria, zona geogr&aacute;fica, etc).</li>
  
<li>
<em>P&aacute;ginas verdes</em>: Informaci&oacute;n t&eacute;cnica sobre los servicios que se ofrecen. Aqu&iacute; se dan las instrucciones
  para utilizar los servicios. Es recomendable que estas instrucciones se especifiquen de forma est&aacute;ndar mediante
  un documento WSDL.</li>
  
</ul>
<p>Adem&aacute;s, UDDI define una API para trabajar con dicho registro, que nos 
  permitir&aacute; buscar datos almacenados en &eacute;l, y publicar datos nuevos. 
</p>
<p>De esta forma, una aplicaci&oacute;n podr&aacute; anunciar sus servicios en 
  un registro UDDI, o bien localizar servicios que necesitemos mediante este registro.</p>
<p>Esta capacidad de localizar servicios en tiempo de ejecuci&oacute;n, y de que 
  una aplicaci&oacute;n pueda saber c&oacute;mo utilizarlo inmediatamente gracias 
  a la descripci&oacute;n del servicio, nos permitir&aacute; realizar una integraci&oacute;n 
  d&eacute;bilmente acoplada de nuestra aplicaci&oacute;n.</p>
<p>La interfaz de UDDI est&aacute; basada en SOAP. Para acceder al registro se 
  utilizar&aacute;n mensajes SOAP, que son transportados mediante protocolo HTTP.</p>
<p>Podemos encontrar la especificaci&oacute;n de UDDI, documentaci&oacute;n, y 
  m&aacute;s informaci&oacute;n en la direcci&oacute;n <span class="codefrag">http://www.uddi.org/</span>.</p>
<p>Estos registros se utilizan normalmente de forma interna en organizaciones para tener
un directorio organizado de servicios. Podemos encontrar varios registros proporcionados
por diferentes proveedores. Destacamos <strong>jUDDI</strong>, un registro <em>open-source</em> 
de Apache. Este registro consiste en una aplicaci&oacute;n web Java que puede instalarse en cualquier servidor
con soporte para este tipo de aplicaciones, como puede ser Tomcat, y una base de datos, que 
podr&aacute; ser instalada en diferentes SGBD (MySQL, Postgres, Oracle, etc).</p>
<a name="N10263"></a><a name="Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n"></a>
<h3 class="underlined_5">Tecnolog&iacute;as de segunda generaci&oacute;n</h3>
<p>Una vez asentadas las tecnolog&iacute;as b&aacute;sicas para servicios web que hemos visto en los puntos anteriores, se empiezan a desarrollar extensiones sobre ellas para cubrir las necesidades que van apareciendo, entre las que encontramos:</p>
<ul>

<li>
<em>WS-Policy</em> y <em>WS-PolicyAttachment</em> nos permitir&aacute;n describir funcionalidades que no pod&iacute;amos especificar con WSDL.</li>

<li>
<em>WS-Security</em> nos permitir&aacute; a&ntilde;adir caracter&iacute;sticas de seguridad adaptadas a las necesidades de seguridad de los Servicios Web. Con esta API podemos utilizar seguridad a nivel de mensaje (encriptando s&oacute;lo determinadas partes del mensaje SOAP), mientras que con SSL s&oacute;lo podr&iacute;amos hacer que fuese seguro a nivel de transporte.</li>

<li>
<em>WS-Addressing</em> y <em>WS-ReliableMessaging</em> nos permitir&aacute;n especificar la direcci&oacute;n de un servicio y realizar un control de flujo de los mensajes respectivamente. Gracias a esto se podr&aacute; por ejemplo implementar servicios con estado, o servicios que funcionen de forma as&iacute;ncrona. Podremos hacer una petici&oacute;n sin quedarnos bloqueados esperando una respuesta, y recibir la respuesta mediante un <em>callback</em>.</li>

<li>
<em>WS-Coordination</em> o <em>BPEL</em> nos permitir&aacute;n orquestar servicios web.</li>

</ul>
<a name="N10290"></a><a name="WS-I+Basic+Profile"></a>
<h3 class="underlined_5">WS-I Basic Profile</h3>
<p>La <em>Web Services Interoperability Organization</em> (WS-I) vela por
el cumplimiento de los est&aacute;ndares en los servicios web, de forma que se garantice
la interoperabilidad entre servicios web desarrollados en diferentes plataformas.</p>
<p>Hemos visto hasta el momento diferentes est&aacute;ndares que dan soporte a los
servicios web (SOAP, WSDL, UDDI). El problema es que dichos est&aacute;ndares contienen
algunas ambig&uuml;edades, que pueden ser interpretadas de forma diferente por los
desarrolladores de diferentes plataformas, y que tampoco se especifica como
usar las tres tecnolog&iacute;as de forma conjunta para el desarrollo de servicios web
(s&oacute;lo se dan las especificaciones por separado). Para solucionar este 
problema la WS-I crea la especificaci&oacute;n WS-I Basic Profile, para aclarar
la forma en la que estas tecnolog&iacute;as deben ser utilizadas cuando las utilizamos
para construir servicios web.</p>
<p>En el WS-I Basic Profile tambi&eacute;n se especifica como deben combinarse
las tecnolog&iacute;as SOAP, WSDL y UDDI para el desarrollo de servicios web. Utilizaremos
un registro UDDI para publicar los servicios. De estos servicios se publicar&aacute; un
documento WSDL como instrucciones de uso. En el WSDL figurar&aacute; la interfaz del
servicio, y la forma de acceder a &eacute;l, que ser&aacute; mediante protocolo SOAP.</p>
<p>Por lo tanto, cuando desarrollemos servicios web que cumplan con dicho 
perfil, podremos tener la certeza de que podr&aacute;n ser accedidos por clientes
que tambi&eacute;n lo cumplan.</p>
</div>

<a name="N102A7"></a><a name="Tecnolog%C3%ADas+J2EE+para+Servicios+Web"></a>
<h2 class="underlined_10">Tecnolog&iacute;as J2EE para Servicios Web</h2>
<div class="section">
<p>Hemos visto las tecnolog&iacute;as en las que se basan los Servicios Web, y 
  que los hacen independientes de la plataforma y del lenguaje de programaci&oacute;n 
  utilizado. Sin embargo, escribir manualmente los mensajes SOAP desde nuestras 
  aplicaciones puede ser una tarea tediosa. Por ello, las distintas plataformas 
  existentes incorporan librer&iacute;as y utilidades que se encargan de realizar 
  esta tarea por nosotros.</p>
<p>En este tema veremos las librer&iacute;as que incorpora Java EE para la generaci&oacute;n 
  y el procesamiento de c&oacute;digo XML, que nos servir&aacute;n para implementar 
  y utilizar Servicios Web.</p>
<p>Hemos de destacar que las tecnolog&iacute;as Java para servicios web cumplen con el
WS-I Basic Profile, por lo que tenemos garantizada la interoperabilidad con
gran parte de los servicios web desarrollados en otras plataformas.</p>
<a name="N102B6"></a><a name="JAXP"></a>
<h3 class="underlined_5">JAXP</h3>
<p>La API JAXP nos permite procesar cualquier documento XML desde lenguaje Java. 
  Tiene en cuenta los espacios de nombres, lo cual nos permite trabajar con DTDs 
  que podr&iacute;an tener conflictos de nombres si estos no estuviesen soportados. 
  Adem&aacute;s, soporta XSLT, lo cual nos permitir&aacute; convertir un documento 
  XML a otro formato, como por ejemplo HTML.</p>
<p>Esta es una librer&iacute;a gen&eacute;rica, para procesar cualquier documento 
  XML. A continuaci&oacute;n veremos una serie de librer&iacute;as, para tareas 
  m&aacute;s especificas, que se apoyan en JAXP para realizar el procesado de 
  diferentes lenguajes como SOAP, WSDL y UDDI, todos ellos derivados de XML. Por 
  lo tanto, todas estas librer&iacute;as depender&aacute;n de JAXP para su correcto 
  funcionamiento.</p>
<a name="N102C3"></a><a name="JAXM"></a>
<h3 class="underlined_5">JAXM</h3>
<p>La API JAXM implementa la mensajer&iacute;a XML en Java orientada al documento. 
  Nos permitir&aacute; de forma sencilla crear mensajes XML, insertando el contenido 
  que queramos en ellos, y enviarlos a cualquier destinatario, as&iacute; como 
  extraer el contenido de los mensajes que recibamos. Permite enviar y recibir 
  los mensajes de forma s&iacute;ncrona (modelo petici&oacute;n-respuesta) o as&iacute;ncrona 
  (env&iacute;o de mensaje sin esperar respuesta).</p>
<p>Los mensajes XML con los que trabaja JAXM siguen la especificaci&oacute;n SOAP 
  y SOAP con anexos. Dentro de JAXM encontramos dos APIs:</p>
<ul>
  
<li>SAAJ (<em>SOAP with Attachmets API for Java</em>) es la API que se utiliza 
    para construir mensajes SOAP y para extraer la informaci&oacute;n que contienen. 
    Esta API es independiente, y suficiente para enviar mensajes de tipo petici&oacute;n-respuesta 
    (s&iacute;ncronos).</li>
  
<li>JAXM proporciona un proveedor de mensajer&iacute;a XML, con el que podremos 
    enviar y recibir mensajes de forma as&iacute;ncrona, sin necesidad de esperar 
    una respuesta de la otra parte. Esta API depender&aacute; de SAAJ para funcionar, 
    ya que SAAJ es la que se encargar&aacute; de crear y manipular los mensajes.</li>

</ul>
<a name="N102DC"></a><a name="JAX-RPC+%2F+JAX-WS"></a>
<h3 class="underlined_5">JAX-RPC / JAX-WS</h3>
<p>La API JAX-RPC implementa la infraestructura para realizar llamadas a procedimiento 
  remoto (RPC) mediante XML. En este caso se enviar&aacute; un mensaje SOAP con 
  el m&eacute;todo que queremos invocar junto a los par&aacute;metros que le pasamos, 
  y nos devolver&aacute; de forma s&iacute;ncrona una respuesta SOAP con el valor 
  devuelto por el m&eacute;todo tras su ejecuci&oacute;n. </p>
<p>Por lo tanto, JAX-RPC depender&aacute; de SAAJ para construir los mensajes 
  SOAP, para enviarlos, y para extraer la informaci&oacute;n del mensaje SOAP 
  que nos devuelve como resultado.</p>
<p>Esta API nos permitir&aacute;, de forma sencilla, invocar Servicios Web, 
  as&iacute; como crear nuestros propios Servicios Web a partir 
  de clases Java que tengamos implementadas.</p>
<p>A partir de la versi&oacute;n 2.0, esta API pasa a recibir el nombre JAX-WS. Esta nueva versi&oacute;n se basa en JAXB para manipular los datos. Adem&aacute;s permite el uso de la API <em>Web Services Metadata for the Java Platform</em> que permite construir los servicios web utilizando anotaciones.</p>
<a name="N102F2"></a><a name="JAXR"></a>
<h3 class="underlined_5">JAXR</h3>
<p>La API JAXR nos permitir&aacute; acceder a registros XML a trav&eacute;s de 
  una API est&aacute;ndar Java. Esta API pretende proporcionar una interfaz &uacute;nica 
  para acceder a distintos tipos de registros, cada uno de los cuales tiene un 
  protocolo distinto.</p>
<p>Actualmente JAXR es capaz de trabajar con registros UDDI y ebXML. Podremos 
  realizar dos tipos de tareas distintas cuando accedamos a un registro mediante 
  JAXR:</p>
<ul>
  
<li>Consultar el registro, para localizar los servicios que necesitemos.</li>
  
<li>Publicar un servicio en el registro, para que otros clientes sean capaces 
    de localizarlo cuando lo necesiten, as&iacute; como modificar o eliminar los 
    servicios publicados que sean de nuestra propiedad.</li>

</ul>
<a name="N10308"></a><a name="JAXB"></a>
<h3 class="underlined_5">JAXB</h3>
<p>La API de JAXB (<em>Java API for Binding</em>) nos permite asociar esquemas 
  XML y c&oacute;digo Java. A partir de un esquema XML, podremos generar una clase 
  Java que represente dicho esquema. </p>
<p>De esta forma podremos convertir un documento XML a una serie de objetos Java 
  que contendr&aacute;n la informaci&oacute;n de dicho documento (<em>unmarshalling</em>). 
  Podremos entonces trabajar desde nuestra aplicaci&oacute;n con estos objetos, 
  accediendo y modificando sus valores. Finalmente, podremos volver a obtener 
  un documento XML a partir de los objetos Java (<em>marshalling</em>).</p>
<p>Esto nos va a simplificar la tarea de utilizar tipos de datos propios en llamadas 
  a Servicios Web, ya que utilizando JAXB podremos realizar de forma sencilla 
  la conversi&oacute;n entre nuestra clase Java y un documento XML con la informaci&oacute;n 
  de dicha clase.</p>
<a name="N10321"></a><a name="Otras+librer%C3%ADas"></a>
<h3 class="underlined_5">Otras librer&iacute;as</h3>
<p>Adem&aacute;s de las APIs Java est&aacute;ndar para servicios web, encontramos tambi&eacute;n algunas
librer&iacute;as adicionales desarrolladas por terceros que pueden sernos de utilidad. 
Por ejemplo, vamos a ver una serie de librer&iacute;as para trabajar con servicios web
que se encuentran enmarcadas dentro del proyecto Apache. M&aacute;s adelante estudiaremos 
el framework Axis, tambi&eacute;n de Apache, que es uno de los frameworks m&aacute;s utilizados
para el desarrollo de servicios web en Java.
</p>
<a name="N1032A"></a><a name="WSDL4J"></a>
<h4>WSDL4J</h4>
<p>La API de Java para WSDL (WSDL4J) nos permite de forma sencilla analizar documentos 
  WSDL, y de esa forma poder descubrir las caracter&iacute;sticas de un servicio 
  en tiempo de ejecuci&oacute;n. </p>
<p>Mediante esta API, podremos <em>"interrogar"</em> un servicio a partir 
  de su especificaci&oacute;n WSDL, y obtener informaci&oacute;n como las operaciones 
  que podemos invocar en este servicio, los par&aacute;metros que deberemos proporcionar 
  a cada una de ellas, y el tipo de datos resultante que nos devuelven. </p>
<p>De esta forma podremos realizar la integraci&oacute;n de la aplicaci&oacute;n 
  en tiempo de ejecuci&oacute;n, ya que no ser&aacute; necesario indicar al programa 
  c&oacute;mo debe acceder a un servicio, ni los m&eacute;todos a los que debe 
  llamar, sino que el programa ser&aacute; capaz de determinar esta informaci&oacute;n 
  analizando la especificaci&oacute;n WSDL del servicio. Si estamos interesados en 
  acceder a los servicios web de esta forma, lo m&aacute;s inmediato ser&aacute; utilizar directamente
  la siguiente API.</p>
<a name="N1033D"></a><a name="WSIF"></a>
<h4>WSIF</h4>
<p>La API <em>Web Services Invocation Framework</em> (WSIF) nos va a permitir acceder
a los servicios web directamente a partir del WSDL, sin tener que programar el 
acceso mediante SOAP, ni crear ning&uacute;n <em>stub</em> que haga esto. Gracias a esta
API podremos hacer de forma sencilla una integraci&oacute;n din&aacute;mica y muy d&eacute;bilmente acoplada 
de cualquier servicio web en nuestras aplicaciones. </p>
<a name="N1034D"></a><a name="UDDI4J"></a>
<h4>UDDI4J</h4>
<p>Otra de las librer&iacute;as para servicios web de Apache es UDDI4J. Esta librer&iacute;a
nos permite acceder a registros UDDI desde Java. A diferencia de JAXR, esta
librer&iacute;a se centra &uacute;nicamente en UDDI, sin pretender ser una librer&iacute;a gen&eacute;rica
para acceso a registros XML. Esto hace que resulte m&aacute;s sencillo trabajar con 
ella, ya que est&aacute; adaptada a la nomenclatura utilizada en UDDI.</p>
</div>


<a name="N10359"></a><a name="Probar+servicios+web+con+Eclipse"></a>
<h2 class="underlined_10">Probar servicios web con Eclipse</h2>
<div class="section">
<p>Existen numerosas aplicaciones que nos permiten probar servicios
web simplemente introduciendo la direcci&oacute;n donde se encuentra el documento
WSDL que los define. Una de ellas es <em>Web Services Explorer</em>, 
integrada en el entorno Eclipse. Podemos acceder a ella mediante
el men&uacute; <em>Run &gt; Web Services Explorer</em>:</p>
<p>
<img alt="Abrir Web Services Explorer" content-width="6cm" height="463" src="imagenes/sesion1/wse1.gif" width="304"></p>
<p>Una vez abierta esta herramienta, en la barra superior podremos seleccionar
diferentes modos: UDDI, WSIL y WSDL. El primero de ellos nos permitir&aacute;
conectarnos a registros UDDI y explorar su contenido. Con el segundo podremos
explorar documentos WSIL (<em>Web Services Inspection Languaje</em>). Estos
documentos se utilizan para especificar la lista de servicios ofrecidos por un determinado
sitio. El tercero de ellos es el que nos permitir&aacute; acceder a un servicio
proporcionando su correspondiente documento WSDL.</p>
<p>Vamos a entrar en el modo WSDL. Para poder acceder a un servicio, primero pulsaremos 
sobre <em>WSDL Main</em>, y a continuaci&oacute;n introduciremos el documento
WSDL que lo define. </p>
<p>
<img alt="Seleccionar un documento WSDL" content-width="13cm" height="403" src="imagenes/sesion1/wse2.gif" width="622"></p>
<p>Pulsamos sobre el bot&oacute;n <em>Go</em> y veremos que
en la secci&oacute;n <em>Navigator</em> nos aparece un &aacute;rbol con los elementos
del servicio al que estamos accediento. Podemos desplegarlo para ver las
operaciones que nos ofrece, y pulsar sobre una de ellas para invocarla.
Al hacer esto en la parte derecha nos aparecer&aacute; un formulario con los 
par&aacute;metros de entrada que toma la funci&oacute;n que vayamos a ejecutar. 
Introduciremos un valor para estos par&aacute;metros, y pulsaremos sobre el
bot&oacute;n <em>Go</em> para invocar la operaci&oacute;n.</p>
<p>
<img alt="Ejecutar una operaci&oacute;n" content-width="13cm" height="402" src="imagenes/sesion1/wse3.gif" width="622"></p>
<p>En la parte inferior veremos el resultado que nos ha devuelto el
servicio. De esta forma vemos como los servicios pueden ser integrados 
de forma din&aacute;mica en tiempo de ejecuci&oacute;n.</p>
<p>Esta herramienta nos permitir&aacute; probar de forma r&aacute;pida cualquier servicio,
propio o ajeno, sin tener que construir un cliente para &eacute;l.</p>
</div>




<a name="N1039F"></a><a name="Invocaci%C3%B3n+de+Servicios"></a>
<h2 class="underlined_10">Invocaci&oacute;n de Servicios</h2>
<div class="section">
<p>Vamos a ver ahora c&oacute;mo invocar Servicios Web desde 
  Java. Para ello contamos con la API JAX-WS (o JAX-RPC en versiones anteriores). 
  Con esta librer&iacute;a podremos ejecutar procedimientos de forma remota, simplemente haciendo 
  una llamada a dicho procedimiento, sin tener que introducir apenas c&oacute;digo 
  adicional. Ser&aacute; JAX-WS quien se encargue de gestionar internamente la 
  conexi&oacute;n con el servicio y el manejo de los mensajes SOAP de llamada 
  al procedimiento y de respuesta.</p>
<p>Podemos encontrar las clases de la API de JAX-WS dentro del paquete<span class="codefrag"> 
  javax.xml.ws</span> y en subpaquetes de &eacute;ste. </p>
<p>Nuestro cliente Java realizado con JAX-WS ser&aacute; interoperable con pr&aacute;cticamente 
  todos los servicios creados desde otras plataformas que cumplan el est&aacute;ndar WS-I.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Con JAX-WS no podremos invocar servicios que utilicen codificaci&oacute;n <span class="codefrag">rpc/encoded</span>, ya que el uso
  de esta codificaci&oacute;n est&aacute; desaconsejado por los est&aacute;ndares actuales. En estos casos deberemos utilizar
  la antigua librer&iacute;a JAX-RPC, que si que es compatible con este tipo de servicios.</div>
</div>
<a name="N103B7"></a><a name="Tipos+de+acceso"></a>
<h3 class="underlined_5">Tipos de acceso</h3>
<p>Tenemos dos formas diferentes de invocar un Servicio Web utilizando JAX-WS o JAX-RPC:</p>
<ul>
  
<li>
<strong>Creaci&oacute;n de un stub est&aacute;tico</strong>: Consiste en 
    generar una capa de <em>stub</em> por debajo del cliente de forma autom&aacute;tica. 
    Dicho <em>stub</em> implementar&aacute; la misma interfaz que el servicio, 
    lo cu&aacute;l nos permitir&aacute; desde nuestro cliente acceder al Servicio 
    Web a trav&eacute;s del <em>stub</em> tal y como si estuvi&eacute;ramos accediendo 
    directamente al servicio. 
    <p>Para utilizar este mecanismo es recomendable contar con alguna herramienta 
      dentro de nuestra plataforma que nos permita generar dicho <em>stub</em>, 
      para no tener que encargarnos nosotros de realizar esta tarea manualmente.</p>
  
</li>
  
<li>
<strong>Utilizaci&oacute;n de la Interfaz de Invocaci&oacute;n Din&aacute;mica 
    (DII)</strong>: Esta forma de acceso nos permitir&aacute; hacer llamadas a 
    procedimientos de nuestro Servicio Web de forma din&aacute;mica, sin crear 
    un <em>stub</em> para ello. Utilizaremos este tipo de invocaci&oacute;n cuando 
    no conozcamos la interfaz del servicio <em>a priori</em>, para invocarlo deberemos 
    proporcionar &uacute;nicamente los nombres de los m&eacute;todos a utilizar 
    mediante una cadena de texto. 
    <p>Podremos utilizar esta interfaz din&aacute;mica aunque no contemos con 
      un documento WSDL que nos indique la interfaz y datos de nuestro servicio. 
      En este caso, deberemos proporcionar manualmente esta informaci&oacute;n, 
      de forma que sea capaz de acceder al servicio correctamente.</p>
  
</li>

</ul>
<a name="N103E6"></a><a name="Invocaci%C3%B3n+mediante+stub+est%C3%A1tico"></a>
<h3 class="underlined_5">Invocaci&oacute;n mediante stub est&aacute;tico</h3>
<p>Est&aacute; ser&aacute; la forma m&aacute;s sencilla de acceder siempre que 
  contemos con una herramienta que genera el <em>stub</em> de forma autom&aacute;tica. 
</p>
<p>De esta forma, una vez generado el <em>stub</em>, s&oacute;lo tendremos que 
  utilizar este <em>stub</em> como si se tratase de nuestro servicio directamente. 
  En el <em>stub</em> podremos hacer las mismas llamadas a m&eacute;todos que 
  har&iacute;amos directamente en la clase que implemente nuestro servicio, ya 
  que ambos implementar&aacute;n la misma interfaz.</p>
<p>Las herramientas para generar este <em>stub</em> variar&aacute;n seg&uacute;n la plataforma con la 
  que trabajemos. A partir de JDK 1.6 se incluye en Java SE la librer&iacute;a JAX-WS y las herramientas
  necesarias para crear e invocar servicios. En el caso de contar con versiones anteriores de JDK, 
  podemos o bien incorporar a nuestro proyecto las librer&iacute;as necesarias (JAX-WS o JAX-RPC), o bien 
  utilizar herramientas y librer&iacute;as similares proporcionadas por los servidores de aplicaciones, como es el 
  caso de Weblogic 9.2, o desarrolladas por terceros, como es el caso de Apache Axis, que se incluye en
  Eclipse Web Tools.</p>
<p>Vamos a ver c&oacute;mo crear clientes para servicios web utilizando tanto las herramientas est&aacute;ndar proporcionadas
por Sun (en JDK 1.6), como las herramientas proporcionadas por Weblogic. Finalmente, veremos como crear estos
clientes utilizando el IDE Netbeans, que internamente utilizar&aacute; las herramientas y librer&iacute;as est&aacute;ndar de Sun.</p>
<a name="N10407"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+JDK+1.6"></a>
<h4>Invocaci&oacute;n de servicios web con JDK 1.6</h4>
<p>Para crear un cliente en JDK 1.6 (o con JAX-WS en versiones anteriores de JDK) utilizaremos la herramienta
<span class="codefrag">wsimport</span>, que tomar&aacute; como entrada el documento WSDL del servicio al que queremos acceder y producir&aacute;
un conjunto de clases Java que nos permitir&aacute;n acceder al servicio. Esta herramienta se puede invocar desde l&iacute;nea
de comando:</p>
<pre class="code">
<strong>wsimport -s</strong> <em>&lt;src.dir&gt;</em> <strong>-d</strong> <em>&lt;dest.dir&gt;</em> <strong>-p</strong> <em>&lt;pkg&gt;</em> <em>&lt;wsdl.uri&gt;</em>
</pre>
<p>El documento WSDL (<span class="codefrag">&lt;wsdl.url&gt;</span>) se especificar&aacute; mediante su ruta en el disco o mediante su URL. Podemos proporcionar otros 
par&aacute;metros para indicar la forma en la que se debe generar el <em>stub</em>, como el directorio donde
queremos que guarde los fuentes de las clases generadas (<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas (<span class="codefrag">&lt;dest.dir&gt;</span>),
y el paquete en el que se generar&aacute; este conjunto de clases (<span class="codefrag">&lt;pkg&gt;</span>). </p>
<p>Por ejemplo podr&iacute;amos utilizar el siguiente comando para crear el cliente de un servicio <span class="codefrag">HolaMundo</span>
que se encuentra definido en <span class="codefrag">http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</span>, 
separando los fuentes en el directorio <span class="codefrag">src</span> y las clases compiladas en <span class="codefrag">bin</span>, y generando 
todas estas clases dentro de un paquete <span class="codefrag">es.ua.jtech.servcweb.hola.stub</span>:</p>
<pre class="code">
<strong>wsimport -s</strong> src <strong>-d</strong> bin <strong>-p</strong> es.ua.jtech.servcweb.hola.stub 
         http://jtech.ua.es/HolaMundo/wsdl/HolaMundoSW.wsdl</pre>
<p>Tambi&eacute;n existe una tarea de ant equivalente. Para utilizarla deberemos declararla previamente (teniendo la librer&iacute;a 
<span class="codefrag">jaxws-tools.jar</span> dentro del <span class="codefrag">CLASSPATH</span> de ant):</p>
<pre class="code">&lt;taskdef name="<strong>wsimport</strong>" classname="<strong>com.sun.tools.ws.ant.WsImport</strong>"/&gt;</pre>
<p>Una vez declarada, podremos utilizarla de forma similar a la herramienta en l&iacute;nea de comando:</p>
<pre class="code">&lt;<strong>wsimport sourcedestdir</strong>="${src.home}" <strong>destdir</strong>="${bin.home}" 
          <strong>package</strong>="${pkg.name}" <strong>wsdl</strong>="${wsdl.uri}" /&gt;</pre>
<p>Con esto se generar&aacute;n una serie de clases que nos permitir&aacute;n acceder al servicio web e invocar sus operaciones
desde nuestro cliente. Dentro de estas clases tendremos una que recibir&aacute; el mismo nombre que el servicio, y que 
heredar&aacute; de la clase <span class="codefrag">Service</span>. Deberemos instanciar esta clase, y a partir de ella obtendremos el
<em>stub</em> para acceder a un puerto del servicio. Este <em>stub</em> tendr&aacute; la misma interfaz que el servicio web,
y a partir de &eacute;l podremos invocar sus operaciones. En el ejemplo del servicio <span class="codefrag">HolaMundo</span> acceder&iacute;amos
al servicio de la siguiente forma:</p>
<pre class="code">
<strong>HolaMundoSWService</strong> service = new <strong>HolaMundoSWService</strong>();
<strong>HolaMundoSW</strong> port = service.<strong>getHolaMundoSW</strong>();

System.out.println("Resultado: " + port.<strong>saluda</strong>("Miguel"));</pre>
<p>El servicio ofrece una operaci&oacute;n <span class="codefrag">saluda</span> que recibe un nombre, y genera un saludo incluyendo
dicho nombre. En este ejemplo vemos como podemos invocar la operaci&oacute;n <span class="codefrag">saluda</span> del servicio a partir del <em>stub</em> (<span class="codefrag">port</span>) como 
si se tratase de un m&eacute;todo de un objeto local.</p>
<a name="N104B1"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+Eclipse+%28Axis%29"></a>
<h4>Invocaci&oacute;n de servicios web con Eclipse (Axis)</h4>
<p>Una forma m&aacute;s c&oacute;moda de acceder a servicios web es utilizar los asistentes que nos proporcionan los diferentes IDEs
para generar los clientes de los servicios de forma autom&aacute;tica. En Eclipse estas facilidades se implementan mediante el 
framework Axis de Apache, en lugar de utilizar las librer&iacute;as de Sun. Este framework Java de servicios web se encuentra 
en un estado de madurez, y goza actualmente de una gran difusi&oacute;n. Adem&aacute;s resulta altamente portable, ya que los servicios
web Axis se implementan en una aplicaci&oacute;n Java EE est&aacute;ndar que incluye las librer&iacute;as de este framework, por lo que podr&aacute;
ser llevada a cualquier servidor con soporte para aplicaciones web Java, como puede ser Tomcat.</p>
<p>Al crear un cliente para servicios web mediante Eclipse veremos que introduce en el proyecto las librer&iacute;as de Axis,
ya que el <em>stub</em> se genera utilizando este framework. Vamos a ver paso a paso como crear este cliente.</p>
<ul>

<li>En primer lugar, si todav&iacute;a no tenemos ning&uacute;n proyecto creado, deberemos crear el proyecto en el que introducir el
cliente. Podremos utilizar cualquier tipo de proyecto (proyecto Java, proyecto web din&aacute;mico, etc), ya que todos ellos
van a poder acceder a servicios web. </li>

<li>Ahora deberemos importar en nuestro proyecto el documento WSDL que define el servicio al que queremos acceder. 
Podemos hacer esto simplemente arrastrando o copiando este fichero sobre nuestro proyecto. Tambi&eacute;n podremos hacer esto
utilizando la herramienta <em>Web Services Explorer</em>. Si optamos por esta &uacute;ltima forma, abriremos dicha herramienta y
accederemos desde ella la URL en la que se encuentra publicado el documento WSDL del servicio que queremos utilizar. Una vez
hayamos abierto dicho documento WSDL, pulsaremos sobre el bot&oacute;n para importarlo en nuestro <em>workspace</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 1." content-width="12cm" height="186" src="imagenes/sesion1/axis-1.gif" width="595"></p>


</li>

<li>Deberemos seleccionar el proyecto de nuestro <em>workspace</em> al que queramos importarlo, y pulsar sobre el bot&oacute;n
<em>Go</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 2." content-width="12cm" height="314" src="imagenes/sesion1/axis-2.gif" width="595"></p>


</li>

<li>Una vez hecho esto, tendremos el documento WSDL importado en nuestro proyecto.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 3." content-width="5cm" height="68" src="imagenes/sesion1/axis-3.gif" width="222"></p>


</li>

<li>Ahora es el momento de crear el <em>stub</em> para acceder al servicio. Para ello pulsamos con el bot&oacute;n derecho sobre
nuestro proyecto y seleccionamos <em>New &gt; Other ...</em>. En la lista que aparecer&aacute;, entramos en la secci&oacute;n 
<em>Web Services</em> y dentro de ella seleccionamos <em>Web Service Client</em>. Tras esto, pulsamos sobre <em>Next</em>
para pasar a la siguiente pantalla del asistente.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 4." content-width="7cm" height="383" src="imagenes/sesion1/axis-4.gif" width="373"></p>


</li>

<li>Ahora deberemos especificar el documento WSDL del servicio al que queremos acceder. Pulsamos el bot&oacute;n <em>Browse...</em>
y seleccionamos el documento que hemos importado en nuestro proyecto. Tambi&eacute;n podremos especificar hasta qu&eacute; punto queremos
que construya el cliente. Ser&aacute; suficiente con seleccionar el nivel m&iacute;nimo (<em>Develop client</em>), ya que con esto crear&aacute; 
las clases del <em>stub</em> que nosotros posteriormente podremos ejecutar. Tras esto podemos pulsar el bot&oacute;n <em>Next</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 5." content-width="9cm" height="507" src="imagenes/sesion1/axis-5.gif" width="470"></p>


</li>

<li>En la siguiente pantalla se especificar&aacute; el directorio de fuentes en el que queramos que genere el <em>stub</em>, y tambi&eacute;n
nos permite especificar de forma manual el paquete al que se mapear&aacute;n estas clases. Una vez hayamos introducido esta informaci&oacute;n, 
pulsaremos sobre <em>Finish</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 6." content-width="7cm" height="300" src="imagenes/sesion1/axis-6.gif" width="372"></p>


</li>

<li>Con esto nos habr&aacute; generado las clases del <em>stub</em>, y habr&aacute; introducido en el proyecto las librer&iacute;as de Axis necesarias. 

<p>
<img alt="Creaci&oacute;n de un cliente desde Eclipse. Paso 7." content-width="5cm" height="271" src="imagenes/sesion1/axis-7.gif" width="253"></p>


</li>

<li>Entre las clases del <em>stub</em>, veremos una clase con sufijo <span class="codefrag">BindingStub</span>, que es en la que realmente se 
encuentra el c&oacute;digo que hace la llamada al servicio. Sin embargo, no accederemos a ella directamente, sino que la referenciaremos mediante
la interfaz que nos da acceso al servicio. Tampoco la instanciaremos directamente, sino mediante el localizador, que es la clase 
con sufijo <span class="codefrag">Locator</span>. Por ejemplo, el c&oacute;digo para acceder al servicio podr&iacute;a ser el siguiente:

<pre class="code">HolaMundoMovilLocator locator = new HolaMundoMovilLocator();
HolaMundoIF service = locator.getHolaMundoIFPort();
		
System.out.println("Resultado: " + service.saluda("Miguel"));</pre>

De forma alternativa, podr&iacute;amos utilizar la clase con sufijo <span class="codefrag">Proxy</span> para instanciar el <em>stub</em> (que internamente estar&aacute;
utilizando el localizador):

<pre class="code">HolaMundoIF service = new HolaMundoIFProxy();
		
System.out.println("Resultado: " + service.saluda("Miguel"));</pre>
</li>


</ul>
<p>En algunos casos podr&iacute;a interesarnos proteger los servicios con seguridad declarativa, para que no pueda acceder a ellos cualquiera.
Dado que los servicios web realmente se invocan mediante un servlet de Axis que est&aacute; mapeado a una URL, podemos a&ntilde;adir seguridad
declarativa para impedir el acceso a dicha URL al igual que se hace para cualquier otro recurso. Para acceder a servicios protegidos
mediante seguridad del servidor, deberemos especificar en el cliente el login y el password con los cuales queremos acceder. Esto 
debe hacerse en el objeto <em>stub</em>:</p>
<pre class="code">HolaMundoMovilLocator locator = new HolaMundoMovilLocator();
HolaMundoIF service = locator.getHolaMundoIFPort();
		
((HolaMundoIFBindingStub)service).setUsername("usuario");
((HolaMundoIFBindingStub)service).setPassword("password");		
		
System.out.println("Resultado: " + service.saluda("Miguel"));</pre>
<a name="N10567"></a><a name="Invocaci%C3%B3n+de+servicios+web+con+Netbeans"></a>
<h4>Invocaci&oacute;n de servicios web con Netbeans</h4>
<p>Vamos a ver ahora c&oacute;mo crear un cliente de servicios web de forma visual mediante Netbeans. Este 
entorno utilizar&aacute; internamente las librer&iacute;as y herramientas est&aacute;ndar de Sun para crear <em>stub</em> del cliente.</p>
<ul>

<li>En primer lugar, deberemos crear un proyecto, o utilizar uno ya existente. Este proyecto podr&aacute; ser de cualquier tipo
(aplicaci&oacute;n Java, aplicaci&oacute;n Web, etc). Para nuestro ejemplo crearemos un proyecto Java, aunque podr&iacute;amos a&ntilde;adir
un cliente de servicios a cualquier otro tipo de proyecto de la misma forma. 

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 1." content-width="8cm" height="352" src="imagenes/sesion1/nbcl_0.gif" width="620"></p>


</li>

<li>El proyecto se llamar&aacute; <span class="codefrag">HolaMundoCliente</span> y tendr&aacute; una clase principal <span class="codefrag">Main</span> en el 
paquete <span class="codefrag">es.ua.jtech.servcweb.hola</span>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 2." content-width="8cm" height="326" src="imagenes/sesion1/nbcl_1.gif" width="557"></p>


</li>

<li>Una vez tengamos un proyecto creado, podremos a&ntilde;adir el <em>stub</em> para acceder
a un servicio web pulsando con el bot&oacute;n derecho sobre el proyecto y seleccionando la opci&oacute;n <em>Web Service Client ...</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 3." content-width="8cm" height="241" src="imagenes/sesion1/nbcl_2.gif" width="545"></p>

</li>

<li>Se abrir&aacute; un asistente para crear el <em>stub</em> del cliente. Aqu&iacute; deberemos especificar en primer lugar el documento
WSDL que define el servicio al que vamos a acceder, por ejemplo indicando la URL en la que se encuentra. En segundo lugar 
especificaremos el paquete en el que queremos que se generen las clases del <em>stub</em>. Podremos tambi&eacute;n especificar la 
librer&iacute;a que queremos utilizar: JAX-WS o JAX-RPC. Se a&ntilde;adir&aacute;n autom&aacute;ticamente las librer&iacute;as necesarias al proyecto.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 4." content-width="8cm" height="422" src="imagenes/sesion1/nbcl_3.gif" width="695"></p>


<div class="frame note">
<div class="label">Nota</div>
<div class="content">Una vez seleccionada la librer&iacute;a para acceder a los servicios web dentro de un proyecto, en los sucesivos clientes de 
servicios que se creen dentro de dicho proyecto siempre se deber&aacute; utilizar la misma librer&iacute;a. Es decir, JAX-RPC y JAX-WS no
pueden coexistir dentro del mismo proyecto.</div>
</div>


</li>

<li>Finalmente, una vez introducidos estos datos pulsaremos el bot&oacute;n <em>Finish</em>, tras lo cual Netbeans lanzar&aacute; la tarea de ant
<span class="codefrag">wsimport</span> para generar el <em>stub</em> del servicio. Una vez generado el <em>stub</em> del cliente, podremos ver en la pesta&ntilde;a <em>Projects</em>, dentro del apartado <em>Web 
Service References</em>, los datos del servicio al que vamos a acceder y las operaciones que ofrece. Sin embargo, no se
muestran las clases Java generadas. Para ver estas clases deberemos ir a la pesta&ntilde;a <em>Files</em>, y dentro de ella al
directorio <span class="codefrag">/build/generated/wsimport/client/</span>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 5." content-width="8cm" height="260" src="imagenes/sesion1/nbcl_4.gif" width="328"></p>


</li>

<li>Una vez creado el <em>stub</em> del cliente, deberemos utilizarlo en nuestra aplicaci&oacute;n para acceder al servicio. Vamos a suponer
que lo queremos invocar desde la clase principal de nuestra aplicaci&oacute;n (<span class="codefrag">Main</span>), aunque lo mismo podr&iacute;a hacerse para invocarlo desde 
cualquier otra clase, o incluso desde un JSP. Para crear el c&oacute;digo que llame al servicio pulsaremos con el bot&oacute;n derecho del rat&oacute;n
en el lugar del fuente de nuestra clase en el que queramos insertar la llamada (dentro del m&eacute;todo <span class="codefrag">main</span>
en nuestro caso), y seleccionaremos la opci&oacute;n <em>Web Service
Client Resources &gt; Call Web Service Operation</em>.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 6." content-width="8cm" height="374" src="imagenes/sesion1/nbcl_5.gif" width="657"></p>


<div class="frame note">
<div class="label">Nota</div>
<div class="content">De forma alternativa podr&iacute;amos a&ntilde;adir el c&oacute;digo que invoca el servicio arrastrando el 
elemento correspondiente a la operaci&oacute;n que queremos invocar desde la ventana de proyectos (<em>Projects</em>)
hasta el lugar del c&oacute;digo donde queremos hacer la invocaci&oacute;n.</div>
</div>


</li>

<li>Se abrir&aacute; una ventana en la que deberemos seleccionar la operaci&oacute;n que queramos invocar. En nuestro caso seleccionaremos
la operaci&oacute;n <span class="codefrag">saluda</span> del servicio <span class="codefrag">HolaMundoSW</span> y pulsamos el bot&oacute;n <em>OK</em>. 

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 7." content-width="8cm" height="271" src="imagenes/sesion1/nbcl_6.gif" width="277"></p>


</li>

<li>Una vez hecho esto se introducir&aacute; en nuestra clase el c&oacute;digo que hace la llamada al servicio. Deberemos editar este c&oacute;digo
para especificar los par&aacute;metros que vamos a proporcionar en la llamada.

<p>
<img alt="Creaci&oacute;n de un cliente desde Netbeans. Paso 8." content-width="8cm" height="270" src="imagenes/sesion1/nbcl_7.gif" width="645"></p>


</li>

<li>Con esto ya podremos ejecutar nuestra aplicaci&oacute;n cliente, que se conectar&aacute; al servicio web <span class="codefrag">HolaMundoSW</span>
para utilizar la operaci&oacute;n <span class="codefrag">saluda</span>.</li>

</ul>
<a name="N10624"></a><a name="Gestor+de+servicios+web+de+Netbeans"></a>
<h4>Gestor de servicios web de Netbeans</h4>
<p>En Netbeans tambi&eacute;n encontramos un gestor de servicios web, en el que tenemos disponibles algunos servicios
web externos proporcionados por terceros (Google, StrikeIron), y al que podemos a&ntilde;adir otros servicios, propios
o ajenos. De esta forma podemos tener un cat&aacute;logo de servicios que podremos incorporar de forma r&aacute;pida a
nuestras aplicaciones, e incluso probarlos desde el propio entorno.</p>
<ul>

<li>Podemos acceder a este gestor de servicios a trav&eacute;s de la secci&oacute;n <em>Web Services</em> de la ventana 
<em>Services</em> de Netbeans. Aqu&iacute; veremos una lista de servicios que ya vienen incluidos en Netbeans y que 
podremos probar o incorporar en nuestras aplicaciones. Vamos a a&ntilde;adir un nuevo servicio. Para ello antes 
creamos un grupo en el que incluirlo. Pulsamos con el bot&oacute;n derecho sobre <em>Web Services</em> y 
seleccionamos <em>Create Group</em> para crear el nuevo grupo.

<p>
<img alt="Gestor de servicios web de Netbeans. Paso 1." content-width="7cm" height="151" src="imagenes/sesion1/nbtest_1.gif" width="331"></p>

</li>

<li>Vamos a a&ntilde;adir un servicio <em>Hola Mundo</em> disponible en la web <em>jTech</em>. Por lo tanto, crearemos un 
grupo de nombre <em>jTech</em> en el que incluiremos los servicios proporcionados por dicha entidad.

<p>
<img alt="Gestor de servicios web de Netbeans. Paso 2." content-width="6cm" height="123" src="imagenes/sesion1/nbtest_2.gif" width="288"></p>

</li>

<li>Pulsamos sobre el grupo con el bot&oacute;n derecho y seleccionamos <em>Add Web Service ...</em> para a&ntilde;adir 
el nuevo servicio.

<p>
<img alt="Gestor de servicios web de Netbeans. Paso 3." content-width="7cm" height="176" src="imagenes/sesion1/nbtest_3.gif" width="331"></p>

</li>

<li>Como datos del servicio proporcionamos la direcci&oacute;n del documento WSDL que lo define. Adem&aacute;s podemos tambi&eacute;n
especificar el paquete en el cual generar&aacute; la librer&iacute;a con el <em>stub</em> necesario para acceder al servicio. 
Cuando terminemos de introducir los datos pulsamos <em>Add</em> para a&ntilde;adir el nuevo servicio.

<p>
<img alt="Gestor de servicios web de Netbeans. Paso 4." content-width="14cm" height="246" src="imagenes/sesion1/nbtest_4.gif" width="700"></p>

</li>

<li>Una vez tenemos el servicio a&ntilde;adido, podemos desplegarlo para ver las operaciones que ofrece y probarlas
pulsando sobre ellas con el bot&oacute;n derecho y seleccionando <em>Test Method</em>


<p>
<img alt="Gestor de servicios web de Netbeans. Paso 5." content-width="6cm" height="205" src="imagenes/sesion1/nbtest_5.gif" width="292"></p>

</li>

<li>Nos aparecer&aacute; una ventana en la que deberemos introducir los par&aacute;metros necesarios para invocar el servicio,
y tras ello pulsar sobre el bot&oacute;n <em>Submit</em> para invocarlo y ver el resultado obtenido.

<p>
<img alt="Gestor de servicios web de Netbeans. Paso 6." content-width="7cm" height="285" src="imagenes/sesion1/nbtest_6.gif" width="345"></p>

</li>

</ul>
<p>Tambi&eacute;n podemos utilizar los servicios del gestor en nuestras aplicaciones de forma sencilla. Simplemente
tendremos que arrastrar la operaci&oacute;n que queramos invocar sobre el lugar del c&oacute;digo fuente en el que queramos
hacer la llamada. Al hacer esto se a&ntilde;adir&aacute; a nuestro proyecto una librer&iacute;a (JAR) con el <em>stub</em> necesario
para acceder al servicio.</p>
<a name="N1069D"></a><a name="JAX-RPC+en+Netbeans"></a>
<h4>JAX-RPC en Netbeans</h4>
<p>A partir de Netbeans 6 este entorno ya no incluye soporte "de serie" para la librer&iacute;a JAX-RPC. De hecho, lo
recomendable es siempre utilizar JAX-WS. Sin embargo, si necesit&aacute;semos utilizar servicios web antiguos, de tipo
<span class="codefrag">rpc/encoded</span>, que no cumplen los est&aacute;ndares actuales, y no tuviesemos la posibilidad de actualizar
dichos servicios para hacer que los cumpliesen, entonces ser&aacute; necesario utilizar JAX-RPC para invocarlos.</p>
<p>Para poder utilizar JAX-RPC dentro de Netbeans deberemos a&ntilde;adir un <em>plugin</em> que incorpore dicha
librer&iacute;a. Para instalar el <em>plugin</em> pulsaremos sobre la opci&oacute;n <em>Plugins</em> del men&uacute; <em>Tools</em>.</p>
<p>
<img alt="Instalaci&oacute;n de plugins." content-width="5cm" height="314" src="imagenes/sesion1/nb_plugins.gif" width="273"></p>
<p>Dentro de la ventana de <em>plugins</em>, iremos a la pesta&ntilde;a <em>Available Plugins</em>, y de la lista de 
<em>plugins</em> disponibles marcaremos <em>JAX-RPC Web Services</em>. Tras hacer esto pulsamos el bot&oacute;n 
<em>Install</em> para comenzar la instalaci&oacute;n, y seguimos los pasos que nos indica.</p>
<p>
<img alt="Instalar el plugin JAX-RPC." content-width="11cm" height="422" src="imagenes/sesion1/nb_plugin_jaxrpc.gif" width="523"></p>
<p>Los <em>stubs</em> generados por JAX-RPC son menos claros que los de JAX-WS, y al a&ntilde;adir el c&oacute;digo
necesario para invocar el servicio se completan menos datos (no se auto-rellenan ni los par&aacute;metros ni el
valor de retorno de la operaci&oacute;n invocada). Adem&aacute;s Netbeans no es capaz de encontrar de forma autom&aacute;tica
las clases del <em>stub</em>, por lo que no puede a&ntilde;adir los <span class="codefrag">import</span> necesarios autom&aacute;ticamente.
Por lo tanto, resulta recomendable importar de forma manual todas las clases del paquete en el que hayamos
generado el <em>stub</em>. Por ejemplo:</p>
<pre class="code">import es.ua.jtech.servcweb.hola.stub.*;</pre>
<p>De esta forma Netbeans localizar&aacute; correctamente las clases necesarias y podremos aprovechar la
caracter&iacute;stica de autocompletar para investigar los tipos de datos que se esperan como par&aacute;metros,
y los tipos de datos que devuelven las funciones invocadas.</p>
<a name="N106F2"></a><a name="Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29"></a>
<h3 class="underlined_5">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</h3>
<p>Mediante esta interfaz ya no utilizaremos un <em>stub</em> para invocar los 
  m&eacute;todos del servicio, sino que nos permitir&aacute; invocar los m&eacute;todos 
  de forma din&aacute;mica, indicando simplemente el nombre del m&eacute;todo 
  que queremos invocar como una cadena de texto, y sus par&aacute;metros como 
  un <em>array</em> de objetos.</p>
<p>Esto nos permitir&aacute; utilizar servicios que no conocemos previamente. 
  De esta forma podremos implementar por ejemplo un <em>broker</em> de servicios. 
  Un <em>broker</em> es un servicio intermediario, al que podemos solicitar alguna 
  tarea que necesitemos. Entonces el <em>broker</em> intentar&aacute; localizar 
  el servicio m&aacute;s apropiado para dicha tarea en un registro de servicios, 
  y lo invocar&aacute; por nosotros. Una vez haya conseguido la informaci&oacute;n 
  que requerimos, nos la devolver&aacute;. De esta forma la localizaci&oacute;n 
  de servicios se hace totalmente transparente para nosotros.</p>
<p>Podremos acceder con esta interfaz tanto si contamos con un documento WSDL 
  como si no contamos con &eacute;l, pero en el caso de que no tengamos el WSDL 
  deberemos especificar en el c&oacute;digo todos los datos incluidos en estos 
  documentos que necesitemos y de los que en este caso no disponemos (<em>endpoint</em>, 
  par&aacute;metros y tipos, etc).</p>
<a name="N10713"></a><a name="A+partir+de+un+documento+WSDL"></a>
<h4>A partir de un documento WSDL</h4>
<p>Vamos a ver el caso en el que contamos con el documento WSDL que describe el 
  servicio. El primer paso ser&aacute; conseguir el objeto <span class="codefrag">Service</span> 
  igual que hicimos en el caso anterior:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance();
Service serv = sf.createService(
  new URL("http://localhost:7001/HolaMundo/hola?WSDL"), 
  new QName("http://jtech.ua.es", "Conversion"));</pre>
<p>Utilizaremos el objeto <span class="codefrag">Call</span> para hacer las llamadas din&aacute;micas 
  a los m&eacute;todos del servicio. Deberemos crear un objeto <span class="codefrag">Call</span> 
  correspondiente a un determinado puerto y operaci&oacute;n de nuestro servicio:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>El &uacute;ltimo paso ser&aacute; invocar la llamada que hemos creado:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
<p>A este m&eacute;todo le debemos proporcionar un <em>array</em> de objetos como 
  par&aacute;metro, ya que debe poder utilizarse para cualquier operaci&oacute;n, 
  con diferente n&uacute;mero y tipo de par&aacute;metros. Como tampoco se conoce<em> 
  a priori</em> el valor devuelto por la llamada, deberemos hacer una conversi&oacute;n 
  <em>cast</em> al tipo que corresponda, ya que nos devuelve un <span class="codefrag">Object</span> 
  gen&eacute;rico.</p>
<a name="N1074F"></a><a name="Sin+un+documento+WSDL"></a>
<h4>Sin un documento WSDL</h4>
<p>Si no contamos con el WSDL del servicio, crearemos un objeto <span class="codefrag">Service</span> 
  proporcionando &uacute;nicamente el nombre del servicio:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance(); 
Service serv = sf.createService( 
  new QName("http://jtech.ua.es", "HolaMundo"));</pre>
<p>A partir de este objeto podremos obtener un objeto <span class="codefrag">Call</span> para 
  realizar una llamada al servicio de la misma forma que vimos en el caso anterior:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>En este caso el objeto <span class="codefrag">Call</span> no tendr&aacute; ninguna informaci&oacute;n 
  sobre las caracter&iacute;sticas del servicio, ya que no tiene acceso al documento 
  WSDL que lo describe, por lo que deberemos proporcion&aacute;rselas nosotros 
  expl&iacute;citamente.</p>
<p>En primer lugar, deberemos especificar el <em>endpoint</em> del servicio, para 
  que sepa a qu&eacute; direcci&oacute;n debe conectarse para acceder a dicho 
  servicio:</p>
<pre class="code">call.<strong>setTargetEndpointAddress</strong>(endpoint);</pre>
<p>Una vez especificada esta informaci&oacute;n, deberemos indicar el tipo de 
  datos que nos devuelve la llamada a la operaci&oacute;n que vamos a invocar 
  (en nuestro ejemplo <span class="codefrag">saluda</span>):</p>
<pre class="code">QName t_int = 
  new QName("http://www.w3.org/2001/XMLSchema", "int");
call.<strong>setReturnType</strong>(t_string);</pre>
<p>Por &uacute;ltimo, indicaremos los par&aacute;metros de entrada que toma la 
  operaci&oacute;n y sus tipos:</p>
<pre class="code">QName t_double = 
  new QName("http://www.w3.org/2001/XMLSchema", "string");
call.<strong>addParameter</strong>("string_1", t_string, ParameterMode.IN);</pre>
<p>Una vez hecho esto, podremos invocar dicha operaci&oacute;n igual que en el 
  caso anterior:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
</div>



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2008-2009 Depto. CCIA</div>
</div>
</body>
</html>
