<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Creaci&oacute;n de Servicios Web</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/j2ee"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web" src="images/baner_j2ee_der.gif" title="Servicios Web"></a>
</div>
<ul id="tabs">
<li>
<a class="base-not-selected" href="javascript:location.href='../index.html'">Home</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-web.html'">Aplicaciones Web</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../aplic-ent.html'">Aplicaciones Enterprise</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../charlas.html'">Charlas</a>
</li>
<li>
<a class="base-not-selected" href="javascript:location.href='../proy-int/index.html'">Proyecto</a>
</li>
<li class="current">
<a class="base-selected" href="index.html">Servicios Web</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Teor&iacute;a</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="sesion01-apuntes.html">Sesion 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Sesion 2</div>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesion 4</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html" title="Roadmap">Roadmap</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.1.3', 'skin/')" id="menu_1.1.3Title" class="menutitle">Ejercicios</div>
<div id="menu_1.1.3" class="menuitemgroup">
<div class="menuitem">
<a href="sesion01-ejercicios.html">Sesion 1</a>
</div>
<div class="menuitem">
<a href="sesion02-ejercicios.html">Sesion 2</a>
</div>
<div class="menuitem">
<a href="sesion03-ejercicios.html">Sesion 3</a>
</div>
<div class="menuitem">
<a href="sesion04-ejercicios.html">Sesion 4</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion02-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Creaci&oacute;n de Servicios Web</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Arquitectura+de+los+Servicios+Web">Arquitectura de los Servicios Web</a>
</li>
<li>
<a href="#Tipos+de+datos+compatibles">Tipos de datos compatibles</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS">Implementaci&oacute;n del servicio: Fichero JWS</a>
<ul class="minitoc">
<li>
<a href="#Anotaciones">Anotaciones</a>
</li>
<li>
<a href="#Estilo+y+codificaci%C3%B3n+del+servicio">Estilo y codificaci&oacute;n del servicio</a>
</li>
</ul>
</li>
<li>
<a href="#Compilaci%C3%B3n+del+fichero+JWS">Compilaci&oacute;n del fichero JWS</a>
<ul class="minitoc">
<li>
<a href="#Compilaci%C3%B3n+del+servicio+con+JDK+1.6">Compilaci&oacute;n del servicio con JDK 1.6</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+web+con+Eclipse+%28Axis%29">Creaci&oacute;n de servicios web con Eclipse (Axis)</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+servicios+web+con+Netbeans">Creaci&oacute;n de servicios web con Netbeans</a>
</li>
</ul>
</li>
<li>
<a href="#Handlers+de+mensajes">Handlers de mensajes</a>
<ul class="minitoc">
<li>
<a href="#Creaci%C3%B3n+de+un+handler">Creaci&oacute;n de un handler</a>
<ul class="minitoc">
<li>
<a href="#Handlers+en+JAX-RPC">Handlers en JAX-RPC</a>
</li>
<li>
<a href="#Handlers+en+JAX-WS">Handlers en JAX-WS</a>
</li>
<li>
<a href="#Creaci%C3%B3n+de+handlers+con+Netbeans">Creaci&oacute;n de handlers con Netbeans</a>
</li>
</ul>
</li>
<li>
<a href="#Registro+de+handlers+en+el+servicio">Registro de handlers en el servicio</a>
<ul class="minitoc">
<li>
<a href="#Registrar+un+handler+mediante+anotaciones">Registrar un handler mediante anotaciones</a>
</li>
<li>
<a href="#Registrar+un+handler+mediante+Netbeans">Registrar un handler mediante Netbeans</a>
</li>
<li>
<a href="#Registrar+el+handler+en+el+cliente">Registrar el handler en el cliente</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>


<p>Vamos a crear nuestros propios Servicios Web, que ofrecer&aacute;n una serie 
  de m&eacute;todos a los que se podr&aacute; llamar mediante RPC desde cualquier 
  lugar de Internet mediante protocolos est&aacute;ndar (mensajes SOAP).</p>

<p>Deberemos por lo tanto ser capaces de interpretar en nuestras aplicaciones 
  los mensajes SOAP entrantes de petici&oacute;n para la invocaci&oacute;n de 
  un m&eacute;todo. Posteriormente, invocaremos el m&eacute;todo solicitado, y 
  con el resultado que nos devuelva deberemos construir un mensaje SOAP de respuesta 
  y devolv&eacute;rselo al cliente.</p>

<p>Si tuvi&eacute;semos que introducir nosotros el c&oacute;digo para interpretar 
  este mensaje de entrada, y generar manualmente el mensaje de respuesta, el desarrollo 
  de Servicios Web ser&iacute;a una tarea altamente costosa.</p>

<p>Es m&aacute;s, si se forzase al programador a componer el mensaje SOAP manualmente 
  cada vez que desarrolle un Servicio Web, es muy probable que cometa alg&uacute;n 
  error y no respete exactamente el est&aacute;ndar SOAP. Esto ser&iacute;a un 
  grave problema para la interoperabilidad de los Servicios Web, que es una de 
  las caracter&iacute;sticas que perseguimos con esta tecnolog&iacute;a.</p>

<p>Para evitar estos problemas, utilizaremos librer&iacute;as que nos permitan 
  leer o generar mensajes SOAP para la invocaci&oacute;n de m&eacute;todos remotos 
  (RPC), como es el caso de la API JAX-WS (anteriormente JAX-WS). </p>

<p>Adem&aacute;s, para facilitar a&uacute;n m&aacute;s la tarea de desarrollar 
  Servicios Web, normalmente contaremos con herramientas que a partir de las clases 
  que implementan nuestro servicio generen autom&aacute;ticamente todo el c&oacute;digo 
  necesario para leer el mensaje SOAP de entrada, invocar el m&eacute;todo, escribir 
  el mensaje SOAP de salida, y devolverlo al cliente.</p>

<p>Por lo tanto, nosotros deberemos centrarnos &uacute;nicamente en la tarea de 
  programar la funcionalidad que implementan nuestros servicios, olvid&aacute;ndonos 
  del mecanismo de invocaci&oacute;n de &eacute;stos.</p>

<p>JAX-WS es una especificaci&oacute;n est&aacute;ndar de Sun Microsystems, pero 
  no todos los servidores de aplicaciones utilizan esta librer&iacute;a para gestionar 
  los Servicios Web. Por ejemplo, es el caso de Weblogic, que aunque est&aacute; basado en 
  JAX-WS, mantiene algunas extensiones propietarias sobre dicha API. Nos centraremos
  por lo tanto en el desarrollo de servicios con Netbeans y Glassfish, que incorpora 
  las &uacute;ltimas versiones de las librer&iacute;as est&aacute;ndar.</p>


<a name="N10024"></a><a name="Arquitectura+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web</h2>
<div class="section">
<p>En las aplicaciones basadas en JAX-RPC/WS encontramos los siguientes elementos:</p>
<ul>
  
<li>
<strong>Servicio</strong>: Elemento del servidor que implementa la funcionalidad 
    de nuestro servicio. Normalmente utilizaremos una clase Java o un EJB.</li>
  
<li>
<strong>Cliente</strong>: Aplicaci&oacute;n cliente que invoca los m&eacute;todos 
    del servicio remoto. La localizaci&oacute;n del servicio ser&aacute; transparente 
    para el desarrollador de esta aplicaci&oacute;n, que invocar&aacute; los m&eacute;todos 
    del servicio de la misma forma que si &eacute;ste fuese local.</li>
  
<li>
<strong>Stub</strong>: Capa en el cliente que implementa la interfaz del 
    servicio, y utiliza internamente JAX-RPC/WS para construir los mensajes SOAP 
    necesarios para invocar cada m&eacute;todo de la interfaz, y para leer el 
    mensaje de respuesta que recibamos. Este <em>stub</em> ser&aacute; el sustituto 
    del servicio en el lado del cliente, la aplicaci&oacute;n cliente ejecutar&aacute; 
    en &eacute;l los m&eacute;todos que ofrece el servicio, haciendo de esta forma 
    transparente la localizaci&oacute;n del servicio para ella.</li>
  
<li>
<strong>Tie</strong>: Capa en el servidor que decodificar&aacute; los mensajes 
    SOAP entrantes con destino a nuestro servicio, y leer&aacute; de ellos el 
    m&eacute;todo que se quiere invocar y los par&aacute;metros de entrada que 
    se proporcionan. Esta capa acceder&aacute; al componente (clase Java o EJB) 
    que implementa nuestro servicio, ejecutando dicho m&eacute;todo en &eacute;l. 
    Una vez obtenido el resultado, generar&aacute; un mensaje SOAP de respuesta 
    y lo devolver&aacute; al cliente. </li>
  
<li>
<strong>JAX-RPC/WS</strong>: Librer&iacute;a que nos permitir&aacute; analizar 
    y componer mensajes SOAP, y enviarlos a trav&eacute;s de 
    protocolo HTTP. Adem&aacute;s proporciona <em>listeners</em> y <em>servlets</em> 
    que permanecer&aacute;n a la escucha en el servidor para recibir mensajes 
    entrantes de peticiones a los servicios. Una vez recibida una petici&oacute;n, 
    utilizar&aacute; la capa <strong>Tie</strong> del servicio correspondiente 
    para invocarlo, proporcion&aacute;ndole a esta capa el mensaje SOAP entrante. 
    A diferencia de las capas anteriores, que son espec&iacute;ficas para un servicio 
    concreto, la librer&iacute;a JAX-RPC/WS es gen&eacute;rica, nos servir&aacute; 
    para cualquier servicio web SOAP.</li>

</ul>
<p>
<img alt="Arquitectura de JAX-RPC" content-width="5cm" height="115" src="imagenes/jaxrpc.gif" width="259"></p>
<p>Las &uacute;nicas capas que debemos implementar nosotros son el <strong>Cliente</strong> 
  y el <strong>Servicio</strong>. En la implementaci&oacute;n de estos componentes 
  el uso de la librer&iacute;a JAX-RPC/WS ser&aacute; totalmente transparente para 
  nosotros. No har&aacute; falta que introduzcamos c&oacute;digo JAX-RPC/WS dentro 
  de ellas. En el servicio simplemente implementaremos los m&eacute;todos que 
  queremos que ofrezca nuestro servicio, como si se tratase de cualquier clase 
  Java, y en el cliente podremos invocar los m&eacute;todos de este servicio como 
  si invoc&aacute;semos directamente los m&eacute;todos de la clase Java.</p>
<p>Las capas <strong>Stub</strong> y <strong>Tie</strong>, son capas construidas 
  a medida para la interfaz de nuestro servicio. Est&aacute;s son las capas que 
  utilizar&aacute;n JAX-RPC/WS para generar y leer los mensajes SOAP que vamos a 
  utilizar para invocar el servicio, y devolver la respuesta al cliente. Generar&aacute;n 
  o ser&aacute;n capaces de leer los mensajes apropiados para el caso concreto 
  de los m&eacute;todos que definimos en nuestro servicio, por lo que deberemos 
  generar estas capas para cada servicio que desarrollemos. Afortunadamente, normalmente 
  contaremos con herramientas que generen de forma autom&aacute;tica estas capas 
  a partir de la interfaz de nuestro servicio, por lo que no ser&aacute; necesario 
  que el desarrollador de servicios trate directamente con JAX-RPC/WS en ning&uacute;n 
  momento.</p>
</div>

<a name="N10070"></a><a name="Tipos+de+datos+compatibles"></a>
<h2 class="underlined_10">Tipos de datos compatibles</h2>
<div class="section">
<p>Cuando trabajamos con JAX-WS, los tipos de datos que podremos utilizar 
  como tipo de los par&aacute;metros y de valor de retorno de los m&eacute;todos 
  de nuestro servicio ser&aacute;n los tipos soportados por JAXB.</p>
<p>Podremos utilizar cualquiera de los tipos b&aacute;sicos de Java:</p>
<pre class="code">boolean
byte
double
float
int
long
short
char</pre>
<p>Adem&aacute;s, tambi&eacute;n podremos utilizar cualquiera de los <em>wrappers</em> 
  de estos tipos b&aacute;sicos:</p>
<pre class="code">java.lang.Boolean
java.lang.Byte
java.lang.Double
java.lang.Float
java.lang.Integer
java.lang.Long
java.lang.Short
java.lang.Character</pre>
<p>Las siguientes clases de Java tambi&eacute;n son aceptadas como tipos v&aacute;lidos 
  por JAX-WS:</p>
<pre class="code">java.lang.String
java.math.BigDecimal
java.math.BigInteger
java.util.Calendar
java.util.Date
javax.xml.namespace.QName
java.net.URI</pre>
<p>Adem&aacute;s de estos datos, se permitir&aacute; el uso de colecciones cuyos elementos podr&aacute;n 
  ser de cualquiera de los tipos admitidos. Estas colecciones podr&aacute;n ser <em>arrays</em>, 
  tanto unidimensionales como multidimensionales, o clases del marco de colecciones de Java:</p>
<pre class="code">
<strong>Listas: List</strong> 
ArrayList 
LinkedList 
Stack 
Vector 
<strong>Mapas: Map</strong> 
HashMap 
Hashtable 
Properties 
TreeMap 
<strong>Conjuntos: Set</strong> 
HashSet 
TreeSet 
</pre>
<p>Las clases desarrolladas por nosotros tambi&eacute;n podr&aacute;n ser usadas 
  si cumplen ciertas condiciones:</p>
<ul>
  
<li>Debe tener al menos un constructor p&uacute;blico sin par&aacute;metros.</li>
  
<li>No debe implementar la interfaz RMI <span class="codefrag">java.rmi.Remote</span>.</li>
  
<li>Todos sus campos deben ser tipos soportados por JAX-WS. Estos campos pueden 
    ser p&uacute;blicos, protegidos o privados. Para que JAX-WS sea capaz de 
    leer o establecer los valores de estos campos deber&aacute; cumplirse que: 
    <ul>
      
<li>Los campos p&uacute;blicos no deben ser ni <span class="codefrag">final</span> ni <span class="codefrag">transient</span>.</li>
      
<li>Los campos no p&uacute;blicos deben tener sus correspondientes <em>getters</em> y <em>setters</em>.</li>
    
</ul>
  
</li>

</ul>
<p>Si nuestros tipos de datos no cumplen estas caracter&iacute;sticas, o bien 
  estamos trabajando con herramientas que no soportan estos tipos, deberemos construir 
  manualmente <em>marshallers</em> y <em>unmarshallers</em> para nuestras clases utilizando JAXB. Su funci&oacute;n 
  ser&aacute; realizar la conversi&oacute;n entre nuestra clase Java y su correspondiente 
  formato como documento XML.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Para que se generen autom&aacute;ticamente los artefactos que permitan tratar nuestros tipos de 
datos propios, estos deben quedar expuestos en la interfaz del servicio (par&aacute;metros o resultados de los 
m&eacute;todos). En estos casos es por lo tanto necesario utilizar arrays o gen&eacute;ricos (por ejemplo <span class="codefrag">Articulo []</span> o 
<span class="codefrag">ArrayList&lt;Articulo&gt;</span> en lugar de <span class="codefrag">ArrayList</span>), ya que de esta manera se especifica de forma expl&iacute;cita el 
tipo de datos utilizado.</div>
</div>
</div>



<a name="N100E1"></a><a name="Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS"></a>
<h2 class="underlined_10">Implementaci&oacute;n del servicio: Fichero JWS</h2>
<div class="section">
<p>Para implementar los servicios deberemos crear una clase <em>JWS</em>, que consiste en una 
clase Java con anotaciones de la API <em>Web Services Metadata for the Java Platform</em> 
(JSR-181). Parte de los m&eacute;todos de esta clase se ofrecer&aacute;n como operaciones del servicio web.
Para poder ofrecer los m&eacute;todos de esta clase como servicio web deberemos
generar las capas vistas anteriormente. Para ello contaremos con diferentes herramientas,
que depender&aacute;n de la plataforma de desarrollo que utilizamos. Posteriormente 
veremos tanto las herramientas incluidas en JDK 1.6 como las herramientas de Weblogic.</p>
<p>La API <em>Web Services 
Metadata for the Java Platform</em> viene a estandarizar la forma en la que se definen 
los Servicios Web en Java. Anteriormente, cada plataforma defin&iacute;a su propia forma de 
crear servicios web, por lo que, por ejemplo, un servicio web desarrollado con el JWSDP 
de Sun no pod&iacute;a desplegarse directamente en Weblogic. Adem&aacute;s, el fichero JWS contendr&aacute; 
toda la informaci&oacute;n necesaria para generar el servicio, 
por lo que no har&aacute; falta tener la informaci&oacute;n sobre el servicio dispersa en diferentes 
ficheros como ocurr&iacute;a antes. </p>
<p>Para crear la clase JWS que implemente el servicio deberemos crear una clase con 
  un constructor sin par&aacute;metros (si no se crea ning&uacute;n constructor por defecto la 
  clase tendr&aacute; un constructor sin par&aacute;metros vac&iacute;o), y con al menos la anotaci&oacute;n 
  <span class="codefrag">@WebService</span>. Los m&eacute;todos p&uacute;blicos que definamos 
  en esta clase ser&aacute;n por defecto las operaciones que ofrecer&aacute; el 
  servicio aunque, como veremos m&aacute;s adelante, tambi&eacute;n podemos especificar mediante 
  anotaciones los m&eacute;todos que queremos que se publiquen como servicio. 
  Por ejemplo, podemos implementar nuestro servicio como:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebService;

<strong>@WebService</strong>
public class ConversionSW { 
  public int euro2ptas(double euro) {	   
    return (int) (euro * 166.386); 
  } 

  public double ptas2euro(int ptas) { 
    return ((double) ptas) / 166.386; 
  }
}</pre>
<p>Con esto habremos implementado la funcionalidad del servicio como una clase 
  Java ordinaria, sin necesitar tener conocimientos de ninguna librer&iacute;a 
  adicional.</p>
<p>De forma opcional, podemos a&ntilde;adir al servicio un campo <span class="codefrag">context</span> en el que se inyectar&aacute; un objeto
<span class="codefrag">WebServiceContext</span> que nos dar&aacute; acceso al contexto del servicio:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebService;

<strong>@WebService</strong>
public class ConversionSW { 
    <strong>@Resource
    private WebServiceContext context;</strong>

    ...
}</pre>
<p>Dado que realmente el servicio es un componente web, a trav&eacute;s de este objeto podremos tener acceso a
componentes de la API de <em>servlets</em> como la petici&oacute;n HTTP (<span class="codefrag">HttpServletRequest</span>), la sesi&oacute;n
(<span class="codefrag">HttpSession</span>), etc.</p>
<a name="N10125"></a><a name="Anotaciones"></a>
<h3 class="underlined_5">Anotaciones</h3>
<p>Podemos especificar la forma en la que se crea el servicio mediante diferentes anotaciones. Las principales anotaciones disponibles son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebService</span></td>
<td colspan="2" rowspan="1">Indica que la clase define un servicio web. Se pueden especificar como par&aacute;metros los nombres del servicio, del puerto, y de su espacio de nombres, que figurar&aacute;n en el documento WSDL del servicio:

<pre class="code">@WebService(name="ConversionPortType", 
    serviceName="ConversionService",
    targetNamespace="http://jtech.ua.es")</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@SOAPBinding</span></td>
<td colspan="2" rowspan="1">Permite especificar el estilo y la codificaci&oacute;n de los mensajes SOAP utilizados para invocar el servicio. Por ejemplo:
<pre class="code">@SOAPBinding(style=SOAPBinding.Style.DOCUMENT,
    use=SOAPBinding.Use.LITERAL,
    parameterStyle=
      SOAPBinding.ParameterStyle.WRAPPED)</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebMethod</span></td>
<td colspan="2" rowspan="1">Indica que un determinado m&eacute;todo debe ser publicado como operaci&oacute;n del servicio. Si no se indica para ning&uacute;n m&eacute;todo, se considerar&aacute; que deben ser publicados todos los m&eacute;todos p&uacute;blicos. Si no, s&oacute;lo se publicar&aacute;n los m&eacute;todos indicados. Adem&aacute;s, de forma opcional se puede indicar como par&aacute;metro el nombre con el que queramos que aparezca la operaci&oacute;n en el documento WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(double euros) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@Oneway</span></td>
<td colspan="2" rowspan="1">Indica que la llamada a la operaci&oacute;n no debe esperar ninguna respuesta. Esto s&oacute;lo lo podremos hacer con m&eacute;todos que devuelvan <span class="codefrag">void</span>. Por ejemplo:
<pre class="code">@Oneway()
@WebMethod()
public void publicarMensaje(String mensaje) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebParam</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute;n los par&aacute;metros en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(
  @WebParam(name="CantidadEuros",
            targetNamespace="http://jtech.ua.es")
  double euros) {
    ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebResult</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute; el mensaje de respuesta en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
@WebResult(name="ResultadoPtas",
    targetNamespace="http://jtech.ua.es")
public int euro2ptas(double euros) {
    ...
}</pre>

</td>

</tr>

</table>
<a name="N101AC"></a><a name="Estilo+y+codificaci%C3%B3n+del+servicio"></a>
<h3 class="underlined_5">Estilo y codificaci&oacute;n del servicio</h3>
<p>Hemos visto que mediante la anotaci&oacute;n <span class="codefrag">@SOAPBinding</span> podemos cambiar el estilo 
y la codificaci&oacute;n del servicio. Los posibles estilos son:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Style.RPC</span>: Se utilizan mensajes SOAP orientados a RPC, en los que 
se codifican en XML las llamadas a m&eacute;todos remotos.</li>

<li>
<span class="codefrag">SOAPBinding.Style.DOCUMENT</span>: Se utilizan mensajes SOAP orientados al documento. 
Dado que en estos mensajes se puede incluir cualquier tipo de documento XML, tambi&eacute;n se pueden 
utilizar para invocar operaciones de servicios.</li>

</ul>
<p>Podemos especificar tambi&eacute;n la codificaci&oacute;n:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Use.LITERAL</span>: Esta es la &uacute;nica codificaci&oacute;n aceptada en el WS-I 
Basic Profile (BP), que da soporte a los servicios de tipo <em>document/literal</em> y 
<em>RPC/literal</em>.</li>

<li>
<span class="codefrag">SOAPBinding.Use.ENCODED</span>: Se trata de una codificaci&oacute;n que permite representar 
una mayor variedad de estructuras de datos que la anterior, pero est&aacute; desaprobada por el 
BP por ser la causa de gran cantidad de incompatibilidades entre servicios. De hecho JAX-WS 
es incompatible con los servicios de este tipo. Esta codificaci&oacute;n se suele utilizar con 
servicios de tipo RPC, dando lugar al tipo <em>RPC/encoded</em>.</li>

</ul>
<p>En el caso de los servicios de tipo <em>document/literal</em>, tambi&eacute;n podemos especificar 
la forma en la que se representan los tipos de datos de los par&aacute;metros de las operaciones:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.BARE</span>: Los par&aacute;metros se pasan directamente.</li>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.WRAPPED</span>: Los par&aacute;metros se pasan envueltos en 
tipos de datos complejos.</li>

</ul>
<p>Por defecto los servicios ser&aacute;n del tipo <em>document/literal/wrapped</em>.</p>
</div>



<a name="N101FB"></a><a name="Compilaci%C3%B3n+del+fichero+JWS"></a>
<h2 class="underlined_10">Compilaci&oacute;n del fichero JWS</h2>
<div class="section">
<p>Para generar y desplegar el servicio no basta con compilar la clase JWS, sino que deberemos
utilizar herramientas espec&iacute;ficas para generar las capas necesarias para ofrecer
los m&eacute;todos de la clase como servicio web. Veremos tanto las herramientas disponibles en
JDK a partir de la versi&oacute;n 1.6, como las herramientas ofrecidas por la plataforma Weblogic. 
Posteriormente veremos como crear los servicios web de forma visual con Netbeans.</p>
<a name="N10204"></a><a name="Compilaci%C3%B3n+del+servicio+con+JDK+1.6"></a>
<h3 class="underlined_5">Compilaci&oacute;n del servicio con JDK 1.6</h3>
<p>Igual que en el caso de los clientes de servicios web, a partir de la versi&oacute;n 1.6
de JDK se incluyen herramientas para generar servicios web. Concretamente la 
herramienta que se utilizar&aacute; para generar el servicio es <span class="codefrag">wsgen</span>, que al 
igual que <span class="codefrag">wsimport</span> se podr&aacute; utilizar tanto en l&iacute;nea de comando como en 
forma de tarea de ant.</p>
<p>Lo primero que deberemos hacer es compilar la clase que implementa el servicio
(fichero JWS) al igual que cualquier otra clase Java, con la herramienta <span class="codefrag">javac</span>. 
Una vez hecho esto, generaremos el servicio con <span class="codefrag">wsgen</span> a partir de la 
clase compilada. Utilizaremos <span class="codefrag">wsgen</span> de la siguiente forma:</p>
<pre class="code">
<strong>wsgen -cp</strong> <em>&lt;classpath&gt;</em> <strong>-s</strong> <em>&lt;src.dir&gt;</em> <strong>-d</strong> <em>&lt;dest.dir&gt;</em> 
      <em>&lt;nombre.clase.servicio&gt;</em>
</pre>
<p>La clase que implementa el servicio (<span class="codefrag">&lt;nombre.clase.servicio&gt;</span>) 
se especificar&aacute; mediante su nombre completo, es decir, incluyendo el nombre del 
paquete al que pertenece. Podemos proporcionar 
otros par&aacute;metros para indicar la forma en la que se deben generar las clases, 
como el directorio donde queremos que guarde los fuentes de las clases generadas 
(<span class="codefrag">&lt;src.dir&gt;</span>), el directorio donde guardar&aacute; estas clases compiladas 
(<span class="codefrag">&lt;dest.dir&gt;</span>), y el <span class="codefrag">classpath</span>, en el que deber&aacute; 
encontrarse la clase especificada.</p>
<p>En el caso concreto del servicio <span class="codefrag">ConversionSW</span> definido anteriormente, 
podr&iacute;amos generar las clases necesarias (despu&eacute;s de haber compilado la clase 
<span class="codefrag">ConversionSW</span>) de la siguiente forma:</p>
<pre class="code">
<strong>wsgen -cp</strong> bin <strong>-s</strong> src <strong>-d</strong> bin 
      es.ua.jtech.servcweb.conversion.ConversionSW</pre>
<p>Tambi&eacute;n podr&iacute;amos utilizar la versi&oacute;n de ant de esta herramienta. Para ello deberemos
declarar previamente la tarea <span class="codefrag">wsgen</span> (teniendo la librer&iacute;a 
<span class="codefrag">jaxws-tools.jar</span> dentro del <span class="codefrag">CLASSPATH</span> de ant):</p>
<pre class="code">&lt;taskdef name="<strong>wsgen</strong>" classname="<strong>com.sun.tools.ws.ant.WsGen</strong>"/&gt;</pre>
<p>Una vez declarada se podr&aacute; utilizar de la siguiente forma:</p>
<pre class="code">&lt;<strong>wsgen classpath</strong>="${bin.home}" 
       <strong>sei</strong>="${service.class.name}" 
       <strong>sourcedestdir</strong>="${src.home}" 
       <strong>destdir</strong>="${bin.home}" /&gt;</pre>
<p>Con esto habremos creado las clases necesarias para publicar el servicio. Con JDK 1.6
no ser&aacute; necesario contar con un servidor de aplicaciones para publicar este servicio, 
sino que lo podremos publicar desde cualquier aplicaci&oacute;n Java. Podemos publicar
el servicio de la siguiente forma:</p>
<pre class="code">package es.ua.jtech.servcweb;

import javax.xml.ws.Endpoint;
import es.ua.jtech.servcweb.conversion.ConversionSW;

public class Servicio {
  public static void main(String[] args) {
    <strong>Endpoint.publish</strong>(
      "http://localhost:8080/ServicioWeb/Conversion",
      new ConversionSW());
  }
}</pre>
<p>Cuando ejecutemos la aplicaci&oacute;n, podremos acceder al WSDL del servicio a trav&eacute;s de 
cualquier navegador en la siguiente direcci&oacute;n:</p>
<pre class="code">http://localhost:8080/ServicioWeb/Conversion?WSDL</pre>
<a name="N10295"></a><a name="Creaci%C3%B3n+de+servicios+web+con+Eclipse+%28Axis%29"></a>
<h3 class="underlined_5">Creaci&oacute;n de servicios web con Eclipse (Axis)</h3>
<p>A parte de las herramientas vistas anteriormente, normalmente los diferentes IDEs (Eclipse, Netbeans, etc)
nos permiten crear servicios web de forma sencilla, mediante asistentes y de forma visual en muchos casos. Vamos
a ver a continuaci&oacute;n c&oacute;mo crear servicios web paso a paso utilizando Eclipse.</p>
<p>Como hemos comentado anteriormente, este IDE utiliza el framework Axis para crear los servicios web. Vamos 
a ver paso a paso c&oacute;mo podr&iacute;amos crear con Eclipse el servicio web de conversi&oacute;n visto en puntos anteriores:</p>
<ul>

<li>En primer lugar, deberemos crear un proyecto web din&aacute;mico en el que introducir el servicio. En &eacute;l crearemos 
una clase Java con los m&eacute;todos que queramos exponer como servicio. En este caso no es necesario que sea un fichero
JWS, Axis simplemente necesita una clase Java:

<pre class="code">public class ConversorSW {

  public int euro2Ptas(double euros) {
    return (int)(euros*166.386);
  }
	
  public double ptas2Euros(int ptas) {
    return ((double)ptas)/166.386;
  }
}</pre>


</li>

<li>Una vez contemos con la clase Java cuyos m&eacute;todos queremos exponer como servicio, pulsaremos el bot&oacute;n derecho del 
rat&oacute;n sobre el proyecto y seleccionaremos <em>New &gt; Other...</em>. En la lista que nos aparece, entramos en la 
secci&oacute;n <em>Web Services</em> y dentro de ella seleccionamos <em>Web Service</em>. Una vez hecho esto pulsamos sobre
<em>Next</em>. 

<p>
<img alt="Creaci&oacute;n de un servicio desde Eclipse Paso 1." content-width="7cm" height="386" src="imagenes/sesion2/axis-8.gif" width="365"></p>


</li>

<li>En la siguiente pantalla deberemos seleccionar la forma en la que crearemos el servicio. Distinguimos dos tipos:

<ul>

<li>
<em>Bottom-up</em>: El servicio se crea a partir de una clase Java. Esta es la forma m&aacute;s sencilla de crear los 
servicios, y la que se suele utilizar normalmente (es la que utilizaremos en este ejemplo). A partir de esta clase Java
se generar&aacute; el documento WSDL que definir&aacute; el servicio.</li>

<li>
<em>Top-down</em>: El servicio se crea a partir de un documento WSDL. A partir de este documento se generar&aacute; un esqueleto
de las clases Java necesarias para implementarlo, que nosotros deberemos rellenar con el c&oacute;digo necesario. La ventaja de 
este m&eacute;todo es que nos asegura que el servicio cumpla con una determinada especificaci&oacute;n. Por esta raz&oacute;n, muchas veces 
se recomienda utilizar esta segunda forma. En Eclipse contamos tambi&eacute;n con un editor visual para componer documentos
WSDL, lo cual nos facilitar&aacute; crear servicios de esta forma.</li>

</ul>

En nuestro caso, dejaremos seleccionado el m&eacute;todo <em>bottom-up</em>, por lo que deberemos especificar la clase Java en
la que se encuentra implementado el servicio. Para ello podemos pulsar sobre el bot&oacute;n <em>Browse...</em> y buscar la 
clase correspondiente. Tambi&eacute;n podremos especificar hasta qu&eacute; punto queremos que Eclipse construya el servicio. En este caso
nos interesar&aacute; seleccionar al menos el nivel <em>Start service</em>, para que se generen todos los componentes necesarios, 
y se ponga en marcha el servicio en nuestro servidor. Tambi&eacute;n podr&iacute;amos ir un paso m&aacute;s all&aacute;, seleccionando <em>Test service</em>, 
de forma que nos abra autom&aacute;ticamente una ventana de <em>Web Services Explorer</em> para probar el servicio. Podemos observar 
que tambi&eacute;n tenemos la opci&oacute;n de monitorizar el servicio (activando la casilla <em>Monitor the Web service</em>). Si lo hacemos, 
se abrir&aacute; un monitor en Eclipse en el que veremos los mensajes de petici&oacute;n y respuesta que se transmiten para invocar nuestro servicio. 
Una vez hayamos terminado de configurar toda esta informaci&oacute;n, pulsaremos sobre <em>Next</em>.

<p>
<img alt="Creaci&oacute;n de un servicio desde Eclipse Paso 2." content-width="9cm" height="709" src="imagenes/sesion2/axis-9.gif" width="469"></p>



</li>

<li>En la siguiente pantalla podremos indicar los m&eacute;todos de la clase especificada que queramos exponer en el servicio web. Tambi&eacute;n
podremos configurar el estilo y codificaci&oacute;n del servicio (es recomendable dejar <em>document/literal</em>). Con esto
podemos pulsar sobre <em>Finish</em> para que se generen todos los artefactos necesarios y se ponga en marcha el servicio.

<p>
<img alt="Creaci&oacute;n de un servicio desde Eclipse Paso 3." content-width="7cm" height="495" src="imagenes/sesion2/axis-10.gif" width="378"></p>


</li>

<li>Una vez tengamos el servicio en marcha, podremos acceder en el navegador al listado de servicios Axis publicados en nuestra
aplicaci&oacute;n web (en la ruta <span class="codefrag">/services</span> de nuestro contexto). Junto a cada servicio veremos un enlace a su documento
WSDL.

<p>
<img alt="Creaci&oacute;n de un servicio desde Eclipse Paso 4." content-width="9cm" height="253" src="imagenes/sesion2/axis-11.gif" width="420"></p>


</li>

</ul>
<a name="N1030F"></a><a name="Creaci%C3%B3n+de+servicios+web+con+Netbeans"></a>
<h3 class="underlined_5">Creaci&oacute;n de servicios web con Netbeans</h3>
<p>Vamos a ver a continuaci&oacute;n c&oacute;mo crear servicios web paso a paso utilizando Netbeans.
Seguiremos tambi&eacute;n el ejemplo del servicio web de conversi&oacute;n (de euros a ptas y viceversa) visto en los puntos
anteriores para ilustrar el procedimiento que utilizaremos en Netbeans para crear un servicio web. 
Seguiremos los siguiente pasos:</p>
<ul>

<li>Lo primero que necesitamos es un contenedor en el que crear nuestros servicios. Este contenedor ser&aacute; normalmente
un proyecto web de Netbeans, aunque tambi&eacute;n podr&iacute;amos utilizar un m&oacute;dulo EJB. Para nuestro ejemplo guiado
vamos a crear un nuevo proyecto web llamado <span class="codefrag">ConversionWeb</span> al que a&ntilde;adiremos nuestro servicio.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 1." content-width="8cm" height="405" src="imagenes/sesion2/nbsw_0.gif" width="531"></p>


</li>

<li>Una vez tenemos el proyecto web en el que introducir el servicio, pinchamos sobre &eacute;l con el bot&oacute;n derecho
y seleccionamos <em>New &gt;  Web Service ...</em> para a&ntilde;adir un servicio web.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 2." content-width="8cm" height="349" src="imagenes/sesion2/nbsw_1.gif" width="631"></p>


</li>

<li>Introduciremos el nombre que le queremos dar al servicio (nombre de la clase JWS) y el paquete en el que 
estar&aacute;. Aqu&iacute; podemos crear un servicio web desde cero, o bien utilizar un EJB de sesi&oacute;n existente. Si utiliz&aacute;semos
esta segunda opci&oacute;n, los m&eacute;todos del EJB se ofrecer&iacute;an como operaciones del servicio web de forma autom&aacute;tica, 
sin necesidad de hacer nada m&aacute;s. Para nuestro ejemplo vamos a quedarnos con la opci&oacute;n por defecto, que es crear
el servicio web desde cero en una nueva clase Java plana.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 3." content-width="8cm" height="361" src="imagenes/sesion2/nbsw_2.gif" width="481"></p>


</li>

<li>Una vez pulsemos el bot&oacute;n <em>Finish</em> se crear&aacute; el servicio y se nos mostrar&aacute; en el entorno la vista
de dise&ntilde;o, mediante la cual podremos a&ntilde;adir operaciones al servicio web pulsando sobre el bot&oacute;n <em>Add
Operation ...</em>.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 4." content-width="8cm" height="360" src="imagenes/sesion2/nbsw_3.gif" width="446"></p>


</li>

<li>Al a&ntilde;adir una operaci&oacute;n deberemos especificar su nombre, el tipo de datos devuelto, y sus par&aacute;metros. En
nuestro caso crearemos la funci&oacute;n <span class="codefrag">euro2ptas</span>, con un par&aacute;metro <span class="codefrag">euros</span> de tipo <span class="codefrag">double</span>,
y que devuelve un valor de tipo <span class="codefrag">int</span>.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 5." content-width="8cm" height="393" src="imagenes/sesion2/nbsw_4.gif" width="342"></p>


</li>

<li>Una vez a&ntilde;adida la operaci&oacute;n, aparecer&aacute; en la lista de operaciones de la vista de dise&ntilde;o con todos sus datos. 
Ahora pasaremos a la vista de c&oacute;digo para a&ntilde;adir la funcionalidad al servicio.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 6." content-width="8cm" height="455" src="imagenes/sesion2/nbsw_5.gif" width="449"></p>


</li>

<li>En la vista de c&oacute;digo vemos el esqueleto del fichero JWS de nuestro servicio. Deberemos introducir en el m&eacute;todo
<span class="codefrag">euro2ptas</span> el c&oacute;digo que realice la conversi&oacute;n de euros a pesetas.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 7." content-width="8cm" height="329" src="imagenes/sesion2/nbsw_6.gif" width="491"></p>


</li>

<li>Con esto ya tenemos implementado el servicio. Ahora podemos probarlo con un cliente de prueba que genera 
autom&aacute;ticamente Netbeans, de forma que no ser&aacute; necesario que implementemos nuestro propio cliente para 
realizar las pruebas. Para ello primero debemos ejecutar la aplicaci&oacute;n web que contiene nuestro servicio.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 8." content-width="8cm" height="254" src="imagenes/sesion2/nbsw_7.gif" width="335"></p>


</li>

<li>Una vez la aplicaci&oacute;n est&eacute; ejecut&aacute;ndose en el servidor, podremos probar el servicio pinchando sobre &eacute;l
con el bot&oacute;n derecho y seleccionando la opci&oacute;n <em>Test Web Service</em>.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 9." content-width="8cm" height="273" src="imagenes/sesion2/nbsw_8.gif" width="341"></p>


</li>

<li>Se abrir&aacute; en el navegador una web desde la que podremos probar el servicio. En ella podremos observar un 
enlace al documento WSDL que define el servicio, el cual nos resultar&aacute; de utilidad cuando queramos crear un cliente
que acceda a &eacute;l, y la lista de operaciones que ofrece. Para cada operaci&oacute;n tendremos cuadros de texto para
introducir el valor de los par&aacute;metros de entrada que necesita, y un bot&oacute;n para invocarla. 

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 10." content-width="8cm" height="219" src="imagenes/sesion2/nbsw_9.gif" width="600"></p>


</li>

<li>Si probamos la operaci&oacute;n <em>euro2ptas</em> pasando como par&aacute;metro <em>18.95</em>, veremos el resultado de
invocar el servicio, y adem&aacute;s abajo en la misma p&aacute;gina se mostrar&aacute;n los mensajes SOAP utilizados para dicha
invocaci&oacute;n.

<p>
<img alt="Creaci&oacute;n de un servicio desde Netbeans. Paso 11." content-width="8cm" height="270" src="imagenes/sesion2/nbsw_10.gif" width="270"></p>


</li>

</ul>
</div>



<a name="N103BC"></a><a name="Handlers+de+mensajes"></a>
<h2 class="underlined_10">Handlers de mensajes</h2>
<div class="section">
<p>Los <em>handlers</em> de mensajes son un componente que podremos utilizar para 
  interceptar los mensajes de petici&oacute;n y respuesta de un servicio. Su funci&oacute;n 
  es similar a la funci&oacute;n de los filtros que interceptan las peticiones 
  al servidor web, pero actuando sobre los mensajes SOAP que se utilizan para 
  invocar y dar la respuestas de un servicio.</p>
<p>Posibles usos de los <em>handlers</em> son:</p>
<ul>
  
<li>
<em>Encriptaci&oacute;n de los mensajes</em>: Podemos escribir un <em>handler</em> 
    que encripte los mensajes de salida, y que desencripte los mensajes de entrada. 
    De esta forma los datos viajar&aacute;n seguros por la red, y esta encriptaci&oacute;n 
    ser&aacute; transparente para JAX-RPC, que ser&aacute; capaz de leer sin problemas 
    los mensajes que le lleguen.</li>
  
<li>
<em>Restricci&oacute;n de acceso</em>: Podemos escribir un <em>handler</em> 
    que evite el paso de ciertos mensajes, como por ejemplo los de usuarios no 
    registrados. En caso de que no queramos admitir un mensaje, podemos contestar 
    directamente mediante un mensaje de error SOAP.</li>
  
<li>
<em>Inspecci&oacute;n de los mensajes</em>: En el momento en que interceptamos 
    un mensaje, podemos acceder a su contenido y consultar el mensaje que se est&aacute; 
    enviando realmente en cada caso.</li>
  
<li>
<em>Registro de mensajes</em>: Si tenemos acceso al mensaje, podremos registrarlos 
    en alguna base de datos por si necesitamos tener un registro de las operaciones 
    que se han invocado sobre nuestro servicio.</li>

</ul>
<p>Estos <em>handlers</em> van a poder ser instalados tanto en el cliente como 
  en el servidor. Sin los <em>handlers</em> no ser&iacute;amos capaces de acceder 
  al mensaje SOAP, ya que es JAX-RPC quien se encarga de componer y analizar el 
  mensaje de forma transparente al usuario. Por lo tanto, necesitaremos utilizar 
  <em>handlers</em> para interceptar este mensaje, ya que de otra forma no podr&iacute;amos 
  acceder a &eacute;l y modificarlo si hiciese falta.</p>
<a name="N103F7"></a><a name="Creaci%C3%B3n+de+un+handler"></a>
<h3 class="underlined_5">Creaci&oacute;n de un handler</h3>
<p>Para crear un <em>handler</em> deberemos crear una clase que implemente la 
  interfaz <span class="codefrag">Handler</span>. Esta interfaz nos obligar&aacute; a definir 
  una serie de m&eacute;todos con los que interceptaremos los distintos mensajes. 
  Esta clase variar&aacute; seg&uacute;n si utilizamos JAX-RPC o JAX-WS.</p>
<a name="N10406"></a><a name="Handlers+en+JAX-RPC"></a>
<h4>Handlers en JAX-RPC</h4>
<p>En JAX-RPC los <em>handlers</em> deber&aacute;n definir los siguientes m&eacute;todos:</p>
<ul>
  
<li>
<span class="codefrag">handleRequest(MessageContext)</span>: Intercepta los mensajes 
    de petici&oacute;n SOAP al servicio.</li>
  
<li>
<span class="codefrag">handleResponse(MessageContext)</span>: Intercepta los mensajes 
    de respuesta SOAP del servicio.</li>
  
<li>
<span class="codefrag">handleFault(MessageContext)</span>: Intercepta los mensajes de 
    error SOAP producidos por el servicio.</li>

</ul>
<p>Adem&aacute;s, deberemos implementar los m&eacute;todos de inicializaci&oacute;n 
  y destrucci&oacute;n del componente, que controlan su ciclo de vida:</p>
<ul>
  
<li>
<span class="codefrag">init(HandlerInfo)</span>: Inicializa el componente. Se proporciona 
    un objeto <span class="codefrag">HandlerInfo</span> con configuraci&oacute;n que se le 
    puede proporcionar a este componente. Este objeto contendr&aacute; informaci&oacute;n 
    sobre la clase del <em>handler</em>, un mapa (<span class="codefrag">Map</span>) con propiedades 
    de configuraci&oacute;n, y la lista con los elementos de la cabecera SOAP 
    que procesa.</li>
  
<li>
<span class="codefrag">destroy()</span>: Se invoca cuando el ciclo de vida del componente 
    termina y debe ser destruido, liberando todos los recursos que estuviese utilizando.</li>

</ul>
<p>Adem&aacute;s tendremos que definir el siguiente m&eacute;todo:</p>
<ul>
  
<li>
<span class="codefrag">getHeaders()</span>: Devolver&aacute; un <em>array</em> de objetos 
    <span class="codefrag">QName</span> indicando los distintos elementos contenidos en la 
    cabecera de los mensajes SOAP (<span class="codefrag">header</span>) que procesar este <em>handler</em>.</li>

</ul>
<p>Existe una forma m&aacute;s sencilla de crear un <em>handler</em>, que es heredando 
  de <span class="codefrag">GenericHandler</span>. Esta es una clase abstracta que implementa 
  <span class="codefrag">Handler</span> y define la mayor&iacute;a de sus m&eacute;todos. De 
  esta forma s&oacute;lo tendremos que redefinir los m&eacute;todos para los que 
  queramos personalizar el comportamiento, sin tener que preocuparnos del resto.</p>
<p>Los <em>handlers</em> est&aacute;n contenidos dentro de una cadena de handlers 
  (<span class="codefrag">HandlerChain</span>). A cada <em>handler</em> de la cadena le llegar&aacute; 
  el resultado producido por el anterior <em>handler</em>. Podremos establecer 
  la ordenaci&oacute;n de <em>handlers</em> dentro de esta cadena en el fichero 
  de configuraci&oacute;n de Servicios Web. El orden de invocaci&oacute;n de los 
  <em>handlers</em> para capturar la respuesta ser&aacute; el inverso del orden 
  en el que se captur&oacute; la petici&oacute;n:</p>
<p>
<img alt="Cadena de handlers en el servidor" content-width="11cm" height="85" src="imagenes/handler-srv.gif" width="538"></p>
<p>Los m&eacute;todos para interceptar la petici&oacute;n, respuesta o error devolver&aacute;n 
  un valor <em>booleano</em>. Seg&uacute;n lo que devuelvan estos m&eacute;todos 
  tendremos diferentes comportamientos de la cadena:</p>
<ul>
  
<li>
<span class="codefrag">true</span>: El mensaje SOAP pasa al siguiente <em>handler</em> 
    de la cadena.</li>
  
<li>
<span class="codefrag">false</span>: Se bloquea la cadena de <em>handlers</em> en este 
    punto. Ser&aacute; el <em>handler</em> actual el responsable de dar manualmente 
    una respuesta al mensaje que le haya llegado.</li>
  
<li>
<span class="codefrag">SOAPFaultException</span>: Si al interceptar la petici&oacute;n 
    <span class="codefrag">handleRequest</span> lanza esta excepci&oacute;n, se indica que se devuelva 
    al cliente un mensaje de error SOAP.</li>
  
<li>
<span class="codefrag">JAXRPCException</span>: Indica que ha ocurrido un error en el 
    procesamiento del mensaje.</li>

</ul>
<p>A estos m&eacute;todos se les pasa un objeto <span class="codefrag">MessageContext</span> 
  como par&aacute;metro. Este objeto contiene una serie de propiedades. Podemos 
  hacer una conversi&oacute;n <em>cast</em> de este objeto a <span class="codefrag">SOAPMessageContext</span>, 
  que es una superclase de <span class="codefrag">MessageContext</span>, y nos proporcionar&aacute; 
  acceso a m&aacute;s informaci&oacute;n. En &eacute;l tendremos definidos los 
  m&eacute;todos <span class="codefrag">getMessage</span> y <span class="codefrag">setMessage</span> con 
  los que podremos obtener el mensaje interceptado, y sustituirlo en caso de que 
  queramos que el <em>handler</em> modifique el mensaje.</p>
<p>Un posible esqueleto para un <em>handler</em> es el siguiente:</p>
<pre class="code">public class MiHandler implements <strong>Handler</strong>

  private <strong>HandlerInfo</strong> handlerInfo;

  public void <strong>init</strong>(<strong>HandlerInfo</strong> hi) {
    handlerInfo = hi;
  }

  public void <strong>destroy</strong>() {}

  public QName[] <strong>getHeaders</strong>() {
    return handlerInfo.<strong>getHeaders</strong>();
  }

  public boolean <strong>handleRequest</strong>(<strong>MessageContext</strong> context) { 
    try { 
      // Accede al mensaje SOAP de peticion
<strong>      SOAPMessageContext</strong> smc = (<strong>SOAPMessageContext</strong>)context;    
<strong>      SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  } 

  public boolean <strong>handleResponse</strong>(<strong>MessageContext</strong> context) { 
    try { 
      // Accede al mensaje SOAP de respuesta
<strong>      SOAPMessageContext</strong> smc = (<strong>SOAPMessageContext</strong>)context;    
<strong>      SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  } 

  public boolean <strong>handleFault</strong>(<strong>MessageContext</strong> context) {
    return true;
  }
}</pre>
<p>Donde una vez obtenido el mensaje podemos leerlo y/o modificarlo, seg&uacute;n 
  la funci&oacute;n que queremos que desempe&ntilde;e el <em>handler</em>. Los 
  m&eacute;todos devuelven <span class="codefrag">true</span> para indicar que se siga procesando la 
  cadena de <em>handlers</em> de forma normal.</p>
<a name="N1051A"></a><a name="Handlers+en+JAX-WS"></a>
<h4>Handlers en JAX-WS</h4>
<p>La principal diferencia de los <em>handlers</em> de JAX-WS respecto a los de JAX-RPC 
es que en el primer caso no se distingue entre mensajes de petici&oacute;n y respuesta. En
los <em>handlers</em> de JAX-WS implementaremos <span class="codefrag">SOAPHandler</span>, en lugar
de <span class="codefrag">Handler</span>, y podremos utilizar gen&eacute;ricos para recibir como par&aacute;metro de
los m&eacute;todos directamente un objeto <span class="codefrag">SOAPMessageContext</span> y no tener que hacer
una conversi&oacute;n <em>cast</em>. Al implementar esta interfaz tendremos 
un &uacute;nico m&eacute;todo <span class="codefrag">handleMessage</span> que
intercepta cualquier mensaje, ya sea de petici&oacute;n o de respuesta.</p>
<pre class="code">public class MiHandler implements <strong>SOAPHandler&lt;SOAPMessageContext&gt;</strong> {
    
  public boolean <strong>handleMessage</strong>(SOAPMessageContext smc) {      
    try {
      // Accede al mensaje SOAP de peticion
      <strong>SOAPMessage</strong> msg = smc.<strong>getMessage</strong>(); 
      // Procesar mensaje SOAP
      ...
      // Si hemos hecho cambios, enviamos el mensaje modificado
      smc.<strong>setMessage</strong>(msg);
    } catch(Exception ex) { } 

    return true; 
  }
    
  public boolean handleFault(SOAPMessageContext context) {
    return true;
  }
    
  public Set&lt;QName&gt; getHeaders() {
    return null;
  }
    
  public void close(MessageContext context) {
  }    
}
</pre>
<p>Por ejemplo podr&iacute;amos definir un <em>handler</em> esp&iacute;a que intercepte los mensajes SOAP
y que muestre su contenido en la consola. Este <em>handler</em> se podr&iacute;a implementar
de la siguiente forma:</p>
<pre class="code">public class HandlerEspia implements SOAPHandler&lt;SOAPMessageContext&gt; {
    
  public boolean handleMessage(SOAPMessageContext context) {
    System.out.println("Mensaje interceptado :");
        
    try {
      SOAPMessageContext smc = (SOAPMessageContext)context;
      SOAPMessage msg = smc.getMessage();
            
      ByteArrayOutputStream baos = new ByteArrayOutputStream();
      msg.writeTo(baos);
      System.out.println(baos.toString());
    } catch(Exception ex) { }
        
    return true;
  }
    
  public boolean handleFault(SOAPMessageContext context) {
    return true;
  }
    
  public Set&lt;QName&gt; getHeaders() {
    return null;
  }
    
  public void close(MessageContext context) {
  }    
}
</pre>
<a name="N10559"></a><a name="Creaci%C3%B3n+de+handlers+con+Netbeans"></a>
<h4>Creaci&oacute;n de handlers con Netbeans</h4>
<p>Dentro del entorno Netbeans contamos con un asistente para crear <em>handlers</em> de mensajes SOAP. Para crear
un <em>handler</em> en Netbeans seguiremos los siguientes pasos:</p>
<ul>

<li>Pinchamos sobre nuestro proyecto con el bot&oacute;n derecho y seleccionamos <em>New &gt; Other ...</em>.

<p>
<img alt="Creaci&oacute;n de handlers con Netbeans. Paso 1." content-width="12cm" height="376" src="imagenes/sesion2/nbsh_1.gif" width="614"></p>


</li>

<li>Seleccionamos la categor&iacute;a <em>Web Services</em> y dentro de ella <em>Message Handler</em>.

<p>
<img alt="Creaci&oacute;n de handlers con Netbeans. Paso 2." content-width="13cm" height="445" src="imagenes/sesion2/nbsh_2.gif" width="647"></p>

</li>

<li>Indicamos el nombre de la clase del <em>handler</em> y el paquete en el que la incluiremos.

<p>
<img alt="Creaci&oacute;n de handlers con Netbeans. Paso 3." content-width="11cm" height="326" src="imagenes/sesion2/nbsh_3.gif" width="528"></p>

</li>

<li>Con esto nos crear&aacute; el esqueleto de un <em>handler</em> SOAP b&aacute;sico. Ahora deberemos implementar su 
funcionalidad. A&ntilde;adiremos el c&oacute;digo necesario en el m&eacute;todo <span class="codefrag">handleMessage</span>. En el caso de nuestro
ejemplo, a&ntilde;adimos el siguiente c&oacute;digo:
<pre class="code">public boolean <strong>handleMessage</strong>(SOAPMessageContext messageContext) {
  SOAPMessage msg = messageContext.getMessage();

  System.out.println("Mensaje interceptado :");

  try {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    msg.writeTo(baos);
    System.out.println(baos.toString());
  } catch (Exception ex) {
    ex.printStackTrace();
  }

  return true;
}</pre>

</li>

<li>Una vez implementado el <em>handler</em>, deberemos registrarlo en nuestro servicio o cliente de servicios,
tal como veremos en los siguientes apartados.</li>


</ul>
<a name="N105B0"></a><a name="Registro+de+handlers+en+el+servicio"></a>
<h3 class="underlined_5">Registro de handlers en el servicio</h3>
<p>Deberemos registrar los <em>handlers</em> que queramos que intercepten 
  los mensajes en el servidor. Para hacer esto podremos utilizar la anotaci&oacute;n <span class="codefrag">SOAPMessageHandlers</span>, 
  o bien utilizar el asistente de Netbeans para registrar los <em>handlers</em>.</p>
<a name="N105C2"></a><a name="Registrar+un+handler+mediante+anotaciones"></a>
<h4>Registrar un handler mediante anotaciones</h4>
<p>Podremos registrar un <em>handler</em> en un servicio mediante el uso de anotaciones 
tal como se muestra a continuaci&oacute;n:</p>
<pre class="code">
<strong>@SOAPMessageHandlers</strong> ( {
  <strong>@SOAPMessageHandler</strong> (
    className="utils.MiHandler"),
  <strong>@SOAPMessageHandler</strong> (
    className="utils.MiSegundoHandler")
} )</pre>
<p>Mediante esta anotaci&oacute;n definiremos la cadena de <em>handlers</em> que interceptar&aacute; las llamadas a nuestros servicio. Deberemos especificar los <em>handlers</em> que formar&aacute;n parte de esta cadena mediante la anotaci&oacute;n <span class="codefrag">SOAPMessageHandler</span>, indicando para cada uno de ellos el nombre de la clase en la que est&aacute; implementado.
Estas clases deber&aacute;n encontrarse entre las clases de la aplicaci&oacute;n que se despliegue en el servidor. </p>
<a name="N105E7"></a><a name="Registrar+un+handler+mediante+Netbeans"></a>
<h4>Registrar un handler mediante Netbeans</h4>
<p>Para registrar un <em>handler</em> en nuestro servicio mediante Netbeans seguiremos los siguientes pasos:</p>
<ul>

<li>Pulsamos con el bot&oacute;n derecho sobre el servicio web en el que queramos registrar el
<em>handler</em> y seleccionamos la opci&oacute;n <em>Configure Handlers ...</em>


<p>
<img alt="Registro de handlers con Netbeans. Paso 1." content-width="7cm" height="303" src="imagenes/sesion2/nbsh_4.gif" width="333"></p>

</li>

<li>Pulsamos sobre el bot&oacute;n <em>Add ...</em> para a&ntilde;adir un nuevo <em>handler</em> al servicio.

<p>
<img alt="Registro de handlers con Netbeans. Paso 2." content-width="10cm" height="324" src="imagenes/sesion2/nbsh_5.gif" width="493"></p>

</li>

<li>Seleccionamos el fichero en el que est&aacute; implementado el <em>handler</em> que queremos a&ntilde;adir (dicho fichero deber&aacute; estar dentro de 
las clases de nuestro proyecto). Pulsamos <em>OK</em> para a&ntilde;adir el <em>handler</em> seleccionado.

<p>
<img alt="Registro de handlers con Netbeans. Paso 3." content-width="6cm" height="263" src="imagenes/sesion2/nbsh_6.gif" width="297"></p>

</li>

<li>Veremos en la lista de <em>handlers</em> registrados el <em>handler</em> que acabamos de a&ntilde;adir. Pulsamos <em>OK</em> para finalizar el proceso.

<p>
<img alt="Registro de handlers con Netbeans. Paso 4." content-width="10cm" height="324" src="imagenes/sesion2/nbsh_7.gif" width="493"></p>

</li>

</ul>
<p>Con esto tendremos el <em>handler</em> registrado. Cada vez que se acceda al servicio web sobre el que lo hemos registrado dicho
<em>handler</em> interceptar&aacute; los mensajes de petici&oacute;n y respuesta.</p>
<a name="N1064A"></a><a name="Registrar+el+handler+en+el+cliente"></a>
<h4>Registrar el handler en el cliente</h4>
<p>Tambi&eacute;n podremos registrar los <em>handlers</em> en el lado del
  cliente del servicio, de forma que cuando entre o salga un mensaje sea interceptado 
  por nuestro <em>handler</em>. La forma de registrar el <em>handler</em> en el
  lado del cliente tambi&eacute;n variar&aacute; seg&uacute;n si utilizamos JAX-RPC o 
  JAX-WS. A continuaci&oacute;n mostraremos las dos formas de hacerlo.</p>
<a name="N1065C"></a><a name="Registro+de+handlers+con+JAX-RPC"></a>
<h5>Registro de handlers con JAX-RPC</h5>
<p>El <em>handler</em> deber&aacute; ser registrado 
  dentro del objeto <span class="codefrag">Service</span> correspondiente al servicio que estemos 
  invocando:</p>
<pre class="code">
<strong>Service</strong> serv = ... // Obtener servicio</pre>
<p>En el caso en el que accedamos mediante un <em>stub</em> est&aacute;tico, no 
  se usa directamente un objeto <span class="codefrag">Service</span>, sino una subclase del 
  mismo, adaptada al caso concreto de nuestro servicio. En este caso podremos 
  utilizar este objeto para registrarlo, ya que al ser subclase de <span class="codefrag">Service</span> 
  podremos utilizarlo de la misma forma.</p>
<p>A trav&eacute;s de este objeto <span class="codefrag">Service</span> podremos acceder al 
  registro de <em>handlers</em> (<span class="codefrag">HandlerRegistry</span>) de la siguiente 
  forma:</p>
<pre class="code">
<strong>HandlerRegistry</strong> hr = serv.<strong>getHandlerRegistry</strong>();</pre>
<p>A partir de este registro podremos obtener la cadena (<em>chain</em>) de <em>handlers</em> 
  instalados en este servicio. Proporcionaremos el nombre del puerto para el que 
  queremos registrar el <em>handler</em>, mediante un objeto <span class="codefrag">QName</span>:</p>
<pre class="code">List chain = hr.<strong>getHandlerChain</strong>(
             new QName("http://jtech.ua.es", 
                       "ConversionPortTypeSoapPort"));</pre>
<p>Esto nos devolver&aacute; una lista con informaci&oacute;n sobre todos los 
  <em>handlers</em> instalados en el cliente para el servicio y puerto indicados. 
  Esta lista nos dar&aacute; el orden de invocaci&oacute;n de la cadena de <em>handlers</em> 
  en el cliente, tal como se muestra en la siguiente figura:</p>
<p>
<img alt="Cadena de handlers en el cliente" content-width="11cm" height="84" src="imagenes/handler-cli.gif" width="536"></p>
<p>Cada elemento de esta lista ser&aacute; un objeto <span class="codefrag">HandlerInfo</span>, 
  que contendr&aacute; informaci&oacute;n sobre cada <em>handler</em> instalado. 
  Para registrar un nuevo <em>handler</em> deberemos crearnos un objeto <span class="codefrag">HandlerInfo</span> 
  que haga referencia a nuestro <em>handler</em>. En dicho objeto deberemos indicar 
  la clase de nuestro <em>handler</em>, y adem&aacute;s podemos proporcionar una 
  serie de par&aacute;metros de configuraci&oacute;n gen&eacute;ricos que se enviar&aacute;n 
  al <em>handler</em> en el momento de su creaci&oacute;n.</p>
<pre class="code">
<strong>HandlerInfo</strong> hi = new <strong>HandlerInfo</strong>(HandlerEspia.class,null,null);</pre>
<p>Una vez hecho esto, el &uacute;ltimo paso ser&aacute; a&ntilde;adir este objeto 
  a la cadena de <em>handlers</em>:</p>
<pre class="code">chain.add(hi);</pre>
<p>Con esto tendremos ya nuestro <em>handler</em> registrado. A continuaci&oacute;n 
  deberemos acceder al puerto correspondiente para hacer la llamada al servicio, 
  con cualquiera de los tres m&eacute;todos que hemos visto anteriormente (<em>stub</em> 
  est&aacute;tico, <em>proxy</em> din&aacute;mico, o DII). En el momento en el 
  que se env&iacute;e el mensaje SOAP con la petici&oacute;n, nuestro <em>handler</em> 
  lo interceptar&aacute; justo antes de que salga a trav&eacute;s de la red. Cuando 
  llegue la respuesta, el <em>handler</em> tambi&eacute;n la interceptar&aacute; 
  antes de que la lea nuestra aplicaci&oacute;n cliente. </p>
<a name="N106F7"></a><a name="Registro+de+handlers+con+JAX-WS"></a>
<h5>Registro de handlers con JAX-WS</h5>
<p>En este caso no registraremos el <em>handler</em> en el objeto 
<span class="codefrag">Service</span>, sino que lo haremos directamente en el <em>stub</em> (<span class="codefrag">port</span>).
Por ejemplo, para registrar el mismo <em>handler</em> que en el caso anterior lo 
har&iacute;amos de la siguiente forma:</p>
<pre class="code">HandlerEspia handler = new HandlerEspia();
List&lt;Handler&gt; cadena = new ArrayList&lt;Handler&gt;();
cadena.add(handler);
((BindingProvider)port).getBinding().<strong>setHandlerChain</strong>(cadena);</pre>
</div>


<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2008-2009 Depto. CCIA</div>
</div>
</body>
</html>
