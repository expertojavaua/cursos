<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.7">
<meta name="Forrest-skin-name" content="pelt">
<title>Introducci&oacute;n a los Servicios Web Seguros</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<div class="header">
<div class="grouplogo">
<a href="http://www.jtech.ua.es/cursos/sws"><img class="logoImage" alt="jtech" src="images/baner_j2ee_izq.gif" title="Especialista Universitario Java Enterprise"></a>
</div>
<div class="projectlogoA1">
<a href="http://www.dccia.ua.es/"><img class="logoImage" alt="Servicios Web seguros" src="images/baner_j2ee_der.gif" title="Servicios Web seguros"></a>
</div>
<ul id="tabs">
<li class="current">
<a class="base-selected" href="index.html">Apuntes</a>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="publishedStrip">
<div id="level2tabs"></div>
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="breadtrail">
             
             &nbsp;
           </div>
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Servicios Web seguros</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html" title="Servicios Web seguros">&Iacute;ndice</a>
</div>
<div onclick="SwitchMenu('menu_selected_1.1.2', 'skin/')" id="menu_selected_1.1.2Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Sesiones</div>
<div id="menu_selected_1.1.2" class="selectedmenuitemgroup" style="display: block;">
<div class="menupage">
<div class="menupagetitle">Sesi&oacute;n 1</div>
</div>
<div class="menuitem">
<a href="sesion02-apuntes.html">Sesi&oacute;n 2</a>
</div>
<div class="menuitem">
<a href="sesion03-apuntes.html">Sesi&oacute;n 3</a>
</div>
<div class="menuitem">
<a href="sesion04-apuntes.html">Sesi&oacute;n 4</a>
</div>
<div class="menuitem">
<a href="sesion05-apuntes.html">Sesi&oacute;n 5</a>
</div>
<div class="menuitem">
<a href="sesion06-apuntes.html">Sesi&oacute;n 6</a>
</div>
<div class="menuitem">
<a href="sesion07-apuntes.html">Sesi&oacute;n 7</a>
</div>
<div class="menuitem">
<a href="sesion08-apuntes.html">Sesi&oacute;n 8</a>
</div>
<div class="menuitem">
<a href="sesion09-apuntes.html">Sesi&oacute;n 9</a>
</div>
<div class="menuitem">
<a href="sesion10-apuntes.html">Sesi&oacute;n 10</a>
</div>
<div class="menuitem">
<a href="sesion11-apuntes.html">Sesi&oacute;n 11</a>
</div>
<div class="menuitem">
<a href="sesion12-apuntes.html">Sesi&oacute;n 12</a>
</div>
<div class="menuitem">
<a href="roadmap-apuntes.html" title="Roadmap">Roadmap</a>
</div>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<div id="credit2"></div>
</div>
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="sesion01-apuntes.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Introducci&oacute;n a los Servicios Web Seguros</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#%C2%BFQu%C3%A9+es+un+Servicio+Web%3F">&iquest;Qu&eacute; es un Servicio Web?</a>
</li>
<li>
<a href="#Caracter%C3%ADsticas+de+los+Servicios+Web">Caracter&iacute;sticas de los Servicios Web</a>
</li>
<li>
<a href="#Arquitecturas+Orientadas+a+Servicios">Arquitecturas Orientadas a Servicios</a>
</li>
<li>
<a href="#Arquitectura+de+los+Servicios+Web">Arquitectura de los Servicios Web</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+b%C3%A1sicas">Tecnolog&iacute;as b&aacute;sicas</a>
<ul class="minitoc">
<li>
<a href="#SOAP">SOAP</a>
</li>
<li>
<a href="#WSDL">WSDL</a>
</li>
<li>
<a href="#Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n">Tecnolog&iacute;as de segunda generaci&oacute;n</a>
</li>
<li>
<a href="#WS-I+Basic+Profile">WS-I Basic Profile</a>
</li>
</ul>
</li>
<li>
<a href="#Tecnolog%C3%ADas+J2EE+para+Servicios+Web">Tecnolog&iacute;as J2EE para Servicios Web</a>
<ul class="minitoc">
<li>
<a href="#JAXP">JAXP</a>
</li>
<li>
<a href="#JAXM">JAXM</a>
</li>
<li>
<a href="#JAX-RPC+%2F+JAX-WS">JAX-RPC / JAX-WS</a>
</li>
<li>
<a href="#JAXR">JAXR</a>
</li>
<li>
<a href="#JAXB">JAXB</a>
</li>
<li>
<a href="#Otras+librer%C3%ADas">Otras librer&iacute;as</a>
<ul class="minitoc">
<li>
<a href="#WSDL4J">WSDL4J</a>
</li>
<li>
<a href="#WSIF">WSIF</a>
</li>
<li>
<a href="#UDDI4J">UDDI4J</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Invocaci%C3%B3n+de+Servicios">Invocaci&oacute;n de Servicios</a>
<ul class="minitoc">
<li>
<a href="#Tipos+de+acceso">Tipos de acceso</a>
</li>
<li>
<a href="#Invocaci%C3%B3n+mediante+stub+est%C3%A1tico">Invocaci&oacute;n mediante stub est&aacute;tico</a>
</li>
<li>
<a href="#Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</a>
<ul class="minitoc">
<li>
<a href="#A+partir+de+un+documento+WSDL">A partir de un documento WSDL</a>
</li>
<li>
<a href="#Sin+un+documento+WSDL">Sin un documento WSDL</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Implementaci%C3%B3n+de+los+Servicios+Web+en+Java">Implementaci&oacute;n de los Servicios Web en Java</a>
</li>
<li>
<a href="#Tipos+de+datos+compatibles">Tipos de datos compatibles</a>
</li>
<li>
<a href="#Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS">Implementaci&oacute;n del servicio: Fichero JWS</a>
<ul class="minitoc">
<li>
<a href="#Anotaciones">Anotaciones</a>
</li>
<li>
<a href="#Estilo+y+codificaci%C3%B3n+del+servicio">Estilo y codificaci&oacute;n del servicio</a>
</li>
<li>
<a href="#Tratamiento+de+errores">Tratamiento de errores</a>
</li>
</ul>
</li>
<li>
<a href="#Servicios+Web+Avanzados">Servicios Web Avanzados</a>
<ul class="minitoc">
<li>
<a href="#Optimizaci%C3%B3n+de+mensajes">Optimizaci&oacute;n de mensajes</a>
</li>
<li>
<a href="#Servicios+web+seguros">Servicios web seguros</a>
</li>
<li>
<a href="#Confidencialidad+e+integridad">Confidencialidad e integridad</a>
</li>
<li>
<a href="#Autentificaci%C3%B3n">Autentificaci&oacute;n</a>
</li>
<li>
<a href="#Frameworks+Java+para+Servicios+Web+Seguros">Frameworks Java para Servicios Web Seguros</a>
<ul class="minitoc">
<li>
<a href="#El+framework+Metro">El framework Metro</a>
</li>
<li>
<a href="#El+framework+Axis+2">El framework Axis 2</a>
</li>
<li>
<a href="#El+framework+CXF">El framework CXF</a>
</li>
<li>
<a href="#Comparativa">Comparativa</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#Ejercicios">Ejercicios</a>
<ul class="minitoc">
<li>
<a href="#Seguridad+para+servicios+web+con+Rampart">Seguridad para servicios web con Rampart</a>
</li>
</ul>
</li>
</ul>
</div>


<p>El dise&ntilde;o del software tiende a ser cada vez m&aacute;s modular. Las 
  aplicaciones se componen de una serie de componentes (servicios) reutilizables, 
  que pueden encontrarse distribuidos a lo largo de una serie de m&aacute;quinas 
  conectadas en red.</p>

<p>Los Servicios Web nos permitir&aacute;n distribuir nuestra aplicaci&oacute;n 
  a trav&eacute;s de Internet, pudiendo una aplicaci&oacute;n utilizar los servicios 
  ofrecidos por cualquier servidor conectado a Internet.</p>

<p>Dado el car&aacute;cter distribuido de las aplicaciones empresariales que utilizan
  servicios web, es natural que &eacute;stas se extiendan fuera del &aacute;mbito de la intranet
  empresarial. Llegado este punto, es imprescindible utilizar tecnolog&iacute;as de 
  seguridad para asegurar que otros no puedan leer el contenido, o bien para
  asegurar que el emisor y el receptor son quienes dicen ser (garantizar 
  la confidencialidad y la integridad).</p>


<a name="N10015"></a><a name="%C2%BFQu%C3%A9+es+un+Servicio+Web%3F"></a>
<h2 class="underlined_10">&iquest;Qu&eacute; es un Servicio Web?</h2>
<div class="section">
<p>Un Servicio Web es un componente al que podemos acceder mediante protocolos 
  Web est&aacute;ndar, utilizando XML para el intercambio de informaci&oacute;n.</p>
<p>Normalmente nos referimos con Servicio Web a una colecci&oacute;n de procedimientos 
  (m&eacute;todos) a los que podemos llamar desde cualquier lugar de Internet 
  o de nuestra intranet, siendo este mecanismo de invocaci&oacute;n totalmente 
  independiente de la plataforma que utilicemos y del lenguaje de programaci&oacute;n 
  en el que se haya implementado internamente el servicio.</p>
<p>Cuando conectamos a un servidor web desde nuestro navegador, el servidor nos 
  devuelve la p&aacute;gina web solicitada, que es un documento que se mostrar&aacute; 
  en el navegador para que lo visualice el usuario, pero es dif&iacute;cilmente 
  entendible por una m&aacute;quina. Podemos ver esto como web para humanos. En 
  contraposici&oacute;n, los Servicios Web ofrecen informaci&oacute;n con un formato 
  est&aacute;ndar que puede ser entendido f&aacute;cilmente por una aplicaci&oacute;n. 
  En este caso estar&iacute;amos ante una web para m&aacute;quinas. </p>
</div>

<a name="N10025"></a><a name="Caracter%C3%ADsticas+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Caracter&iacute;sticas de los Servicios Web</h2>
<div class="section">
<p>Las caracter&iacute;sticas deseables de un Servicio Web son:</p>
<ul>
  
<li>Un servicio debe poder ser <strong>accesible a trav&eacute;s de la Web</strong>. 
    Para ello debe utilizar protocolos de transporte est&aacute;ndares como HTTP, 
    y codificar los mensajes en un lenguaje est&aacute;ndar que pueda conocer 
    cualquier cliente que quiera utilizar el servicio.</li>
  
<li>Un servicio debe contener una <strong>descripci&oacute;n de s&iacute; mismo</strong>. 
    De esta forma, una aplicaci&oacute;n podr&aacute; saber cu&aacute;l es la 
    funci&oacute;n de un determinado Servicio Web, y cu&aacute;l es su interfaz, 
    de manera que pueda ser utilizado de forma autom&aacute;tica por cualquier 
    aplicaci&oacute;n, sin la intervenci&oacute;n del usuario.</li>
  
<li>Debe poder <strong>ser localizado</strong>. Deberemos tener alg&uacute;n 
    mecanismo que nos permita encontrar un Servicio Web que realice una determinada 
    funci&oacute;n. De esta forma tendremos la posibilidad de que una aplicaci&oacute;n 
    localice el servicio que necesite de forma autom&aacute;tica, sin tener que 
    conocerlo previamente el usuario.</li>

</ul>
</div>

<a name="N10044"></a><a name="Arquitecturas+Orientadas+a+Servicios"></a>
<h2 class="underlined_10">Arquitecturas Orientadas a Servicios</h2>
<div class="section">
<p>Las arquitecturas orientadas a servicios (SOA) se basan en el desarrollo de servicios altamente reutilizables, y en la combinaci&oacute;n de estos servicios para dar lugar a nuestra aplicaci&oacute;n.</p>
<p>Estos servicios idealmente deber&iacute;an tener una interfaz est&aacute;ndar bien definida, de forma que se pueda integrar f&aacute;cilmente en cualquier aplicaci&oacute;n. Adem&aacute;s no debe tener estado, ni depender del estado de otros componentes. Debe recibir toda la informaci&oacute;n necesaria en la petici&oacute;n.
</p>
<p>Se conoce como <em>orquestaci&oacute;n</em> de servicios la secuenciaci&oacute;n de llamadas a diferentes servicios para realizar un determinado proceso de negocio. Al no tener estado, los servicios se podr&aacute;n secuenciar en cualquier orden, pudiendo formar as&iacute; diferentes flujos que implementen la l&oacute;gica de negocio.</p>
<p>Normalmente cuando hablamos de arquitecturas orientadas a servicios pensamos en su implementaci&oacute;n mediante servicios web. Sin embargo, estas arquitecturas puedes estar formadas por cualquier tipo de servicio, como pueden ser por ejemplo servicios accesibles mediante JMS. En el caso de una SOA implementada mediante Servicios Web, sus servicios ser&aacute;n accesibles a trav&eacute;s de la web.</p>
<p>En una arquitectura orientada a servicios podemos distinguir tres agentes con diferentes funciones:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Proveedor de servicio</strong> </td>
    <td colspan="2" rowspan="1">Implementa unas determinadas operaciones (servicio). Un cliente 
      podr&aacute; solicitar uno de estos servicios a este proveedor. </td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Cliente del servicio</strong></td>
    <td colspan="2" rowspan="1">Invoca a un proveedor de servicio para la realizaci&oacute;n de alguna 
      de los operaciones que proporciona.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Registro de servicios</strong></td>
    <td colspan="2" rowspan="1">Mantiene una lista de proveedores de servicios disponibles, junto a sus 
      descripciones.</td>
  
</tr>

</table>
<p>El mecanismo b&aacute;sico de invocaci&oacute;n de servicios consistir&aacute; 
  en que un cliente solicitar&aacute; un determinado servicio a un proveedor, 
  efectuando el proveedor dicho servicio. El servidor devolver&aacute; una respuesta 
  al cliente como resultado del servicio invocado.</p>
<p>Esto podremos hacerlo as&iacute; si el cliente conoce de antemano el proveedor 
  del cual va a obtener el servicio. Pero hemos de pensar que en Internet encontraremos 
  una gran cantidad de Servicios Web dispersos, lo cual har&aacute; dif&iacute;cil 
  localizar el que busquemos. Adem&aacute;s, si hemos localizado uno que realiza 
  la funci&oacute;n que necesitamos, si dicho servicio no est&aacute; mantenido 
  por nosotros puede ocurrir que en alg&uacute;n momento este servicio cambie 
  de lugar, de interfaz o simplemente desaparezca, por lo que no podremos confiar 
  en que vayamos a poder utilizar siempre este mismo servicio.</p>
<p>Los registros de servicios nos permiten automatizar la localizaci&oacute;n 
  de Servicios Web. Un proveedor puede <em>anunciarse </em>en un determinado registro, 
  de forma que figurar&aacute; en dicho registro la localizaci&oacute;n de este 
  servicio junto a una descripci&oacute;n de su funcionalidad y de su interfaz, 
  que podr&aacute; ser entendida por una aplicaci&oacute;n.</p>
<p>Cuando un cliente necesite un determinado servicio, puede acudir directamente 
  a un registro y solicitar el tipo de servicio que necesita. Para ello es importante 
  establecer un determinada sem&aacute;ntica sobre las posibles descripciones 
  de funcionalidades de servicios, evitando las posibles ambig&uuml;edades.</p>
<p>El registro devolver&aacute; entonces una lista de servicios que realicen la 
  funci&oacute;n deseada, de los cuales el cliente podr&aacute; elegir el m&aacute;s 
  apropiado, analizar su interfaz, e invocarlo.</p>
</div>

<a name="N100A8"></a><a name="Arquitectura+de+los+Servicios+Web"></a>
<h2 class="underlined_10">Arquitectura de los Servicios Web</h2>
<div class="section">
<p>Los protocolos utilizados en los Servicios Web se organizan en una serie de 
  capas:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
  
<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><strong>Capa</strong></td>
    <td colspan="2" rowspan="1"><strong>Descripci&oacute;n</strong></td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Transporte de servicios</em></td>
    <td colspan="2" rowspan="1">Es la capa que se encarga de transportar los mensajes entre aplicaciones. 
      Normalmente se utiliza el protocolo <strong>HTTP</strong> para este transporte, 
      aunque los servicios web pueden viajar mediante otros protocolos de transferencia 
      de hipertexto como SMTP, FTP o BEEP.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Mensajer&iacute;a XML</em></td>
    <td colspan="2" rowspan="1">Es la capa responsable de codificar los mensajes en XML de forma que puedan 
      ser entendidos por cualquier aplicaci&oacute;n. Puede implementar los protocolos 
      XML-RPC o<strong> SOAP</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Descripci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga de definir la interfaz p&uacute;blica de un determinado servicio. 
      Est&aacute; definici&oacute;n se realiza mediante <strong>WSDL</strong>.</td>
  
</tr>
  
<tr> 
    
<td colspan="1" rowspan="1"><em>Localizaci&oacute;n de servicios</em></td>
    <td colspan="2" rowspan="1">Se encarga del registro centralizado de servicios, permitiendo que estos 
      sean anunciados y localizados. Para ello se utiliza el protocolo <strong>UDDI</strong>.</td>
  
</tr>

</table>
<p>M&aacute;s adelante describiremos cada una de las tecnolog&iacute;as para Servicios 
  Web vistas en las distintas capas.</p>
</div>

<a name="N10116"></a><a name="Tecnolog%C3%ADas+b%C3%A1sicas"></a>
<h2 class="underlined_10">Tecnolog&iacute;as b&aacute;sicas</h2>
<div class="section">
<p>Tenemos una serie de tecnolog&iacute;as, todas ellas basadas en XML, que son 
  fundamentales para el desarrollo de Servicios Web. Estas tecnolog&iacute;as 
  son independientes tanto del SO como del lenguaje de programaci&oacute;n utilizado 
  para implementar dichos servicios. Por lo tanto, ser&aacute;n utilizadas para 
  cualquier Servicio Web, independientemente de la plataforma sobre la que construyamos 
  dichos servicios (como puede ser J2EE o .NET). </p>
<a name="N1011F"></a><a name="SOAP"></a>
<h3 class="underlined_5">SOAP</h3>
<p>Se trata de un protocolo derivado de XML que nos sirve para intercambiar informaci&oacute;n 
  entre aplicaciones.</p>
<p>Normalmente utilizaremos SOAP para conectarnos a un servicio e invocar m&eacute;todos 
  remotos, aunque puede ser utilizado de forma m&aacute;s gen&eacute;rica para 
  enviar cualquier tipo de contenido. Podemos distinguir dos tipos de mensajes 
  seg&uacute;n su contenido:</p>
<ul>
  
<li>
<strong>Mensajes orientados al documento</strong>: Contienen cualquier tipo 
    de contenido que queramos enviar entre aplicaciones.</li>
  
<li>
<strong>Mensajes orientados a RPC</strong>: Este tipo de mensajes servir&aacute; 
    para invocar procedimientos de forma remota (<em>Remote Procedure Calls</em>). 
    Podemos verlo como un tipo m&aacute;s concreto dentro del tipo anterior, ya 
    que en este caso como contenido del mensaje especificaremos el m&eacute;todo 
    que queremos invocar junto a los par&aacute;metros que le pasamos, y el servidor 
    nos deber&aacute; devolver como respuesta un mensaje SOAP con el resultado 
    de invocar el m&eacute;todo.</li>

</ul>
<p>Puede ser utilizado sobre varios protocolos de transporte, aunque est&aacute; 
  especialmente dise&ntilde;ado para trabajar sobre HTTP.</p>
<p>Dentro del mensaje SOAP podemos distinguir los siguientes elementos:</p>
<p>
<img alt="Elementos de un mensaje SOAP" content-width="4cm" height="225" src="imagenes/soap.gif" width="203"></p>
<ul>
  
<li>Un sobre (<span class="codefrag">Envelope</span>), que describe el mensaje, a quien va 
    dirigido, y c&oacute;mo debe ser procesado. El sobre incluye las definiciones 
    de tipos que se usar&aacute;n en el documento. Contiene una cabecera de forma 
    opcional, y el cuerpo del mensaje.</li>
  
<li>Una cabecera (<span class="codefrag">Header</span>) opcional, donde podemos incluir informaci&oacute;n 
    sobre el mensaje. Por ejemplo, podemos especificar si el mensaje es obligatorio 
    (debe ser entendido de forma obligatoria por el destinatario), e indicar los 
    actores (lugares por donde ha pasado el mensaje).</li>
  
<li>El cuerpo del mensaje (<span class="codefrag">Body</span>), que contiene el mensaje en 
    si. En el caso de los mensajes RPC se define una convenci&oacute;n sobre como 
    debe ser este contenido, en el que se especificar&aacute; el m&eacute;todo 
    al que se invoca y los valores que se pasan como par&aacute;metros. Puede 
    contener un error de forma opcional.</li>
  
<li>Un error (<span class="codefrag">Fault</span>) en el cuerpo del mensaje de forma opcional. 
    Nos servir&aacute; para indicar en una respuesta SOAP que ha habido un error 
    en el procesamiento del mensaje de petici&oacute;n que mandamos.</li>

</ul>
<p>Hemos visto como los mensajes SOAP nos sirven para intercambiar cualquier documento 
  XML entre aplicaciones. Pero puede ocurrir que necesitemos enviar en el mensaje 
  datos que no son XML, como puede ser una imagen. En ese caso tendremos que recurrir 
  a la especificaci&oacute;n de mensajes SOAP con anexos.</p>
<p>Los mensajes SOAP con anexos a&ntilde;aden un elemento m&aacute;s al mensaje:</p>
<p>
<img alt="Elementos de un mensaje SOAP con Anexos" content-width="4cm" height="269" src="imagenes/swa.gif" width="203"></p>
<ul>
  
<li>El anexo (<span class="codefrag">Attachment</span>), puede contener cualquier tipo de 
    contenido (incluido el XML). De esta forma podremos enviar cualquier tipo 
    de contenido junto a un mensaje SOAP.</li>

</ul>
<p>Nuestro mensaje podr&aacute; contener tantos anexos como queramos.</p>
<p>Un ejemplo de mensaje SOAP es el siguiente:</p>
<pre class="code">&lt;SOAP-ENV:Envelope 
 xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"    
 SOAP-ENV:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;    
    &lt;SOAP-ENV:Body&gt; 
        &lt;ns:getTemperatura xmlns:ns="http://j2ee.ua.es/ns"&gt;    
            &lt;area&gt;Alicante&lt;/area&gt; 
        &lt;/ns:getTemperatura&gt; 
    &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;</pre>
<p>En &eacute;l estamos llamando a nuestro m&eacute;todo <span class="codefrag">getTemperatura</span> 
  para obtener informaci&oacute;n meteorol&oacute;gica, proporcionando como par&aacute;metro 
  el &aacute;rea de la que queremos obtener la temperatura.</p>
<p>Podemos encontrar la especificaci&oacute;n de SOAP y SOAP con anexos publicada 
  en la p&aacute;gina del W3C, en las direcciones <span class="codefrag">http://www.w3.org/TR/SOAP/</span> 
  y <span class="codefrag">http://www.w3.org/TR/SOAP-attachments</span> respectivamente.</p>
<p></p>
<a name="N10197"></a><a name="WSDL"></a>
<h3 class="underlined_5">WSDL</h3>
<p>Es otro lenguaje derivado de XML, que se utiliza para describir los Servicios 
  Web, de forma que una aplicaci&oacute;n pueda conocer de forma autom&aacute;tica 
  la funci&oacute;n de un Servicio Web, as&iacute; como la forma de uso de dicho 
  Servicio Web.</p>
<p>El fichero WSDL describir&aacute; la interfaz del Servicio Web, con los m&eacute;todos 
  a los que podemos invocar, los par&aacute;metros que debemos proporcionarles 
  y los tipos de datos de dichos par&aacute;metros.</p>
<p>Si desarrollamos un Servicio Web, y queremos que otras personas sean capaces 
  de utilizar nuestro servicio para sus aplicaciones, podremos proporcionar un 
  documento WSDL describiendo nuestro servicio. De esta forma, a partir de este 
  documento otros usuarios podr&aacute;n generar aplicaciones clientes en cualquier 
  plataforma (ya que WSDL se define como un est&aacute;ndar) que se ajusten a 
  nuestro servicio.</p>
<p>El elemento ra&iacute;z dentro de este fichero es <span class="codefrag">definitions</span>, 
  donde se especifican los espacios de nombres que utilizamos en nuestro servicio. 
  Dentro de este elemento ra&iacute;z encontramos los siguientes elementos:</p>
<ul>
  
<li>
<span class="codefrag">types</span>: Se utiliza para definir los tipos de datos que se 
    intercambiar&aacute;n en el mensaje.</li>
  
<li>
<span class="codefrag">message</span>: Define los distintos mensajes que se intercambiaran 
    durante el proceso de invocaci&oacute;n del servicio. Se deber&aacute;n definir 
    los mensajes de entrada y salida para cada operaci&oacute;n que ofrezca el 
    servicio. En el caso de mensajes RPC, en el mensaje de entrada se definir&aacute;n 
    los tipos de par&aacute;metros que se proporcionan, y en el de salida el tipo 
    del valor devuelto.</li>
  
<li>
<span class="codefrag">portType</span>: Define las operaciones que ofrece el servicio. 
    De cada operaci&oacute;n indica cuales son los mensajes de entrada y salida, 
    de entre los mensajes definidos en el apartado anterior.</li>
  
<li>
<span class="codefrag">binding</span>: Indica el protocolo y el formato de los datos 
    para cada mensaje de los definidos anteriormente. Este formato puede ser orientado 
    al documento u orientado a RPC. Si es orientado al documento tanto el mensaje 
    de entrada como el de salida contendr&aacute;n un documento XML. Si es orientado 
    a RPC el mensaje de entrada contendr&aacute; el m&eacute;todo invocado y sus 
    par&aacute;metros, y el de salida el resultado de invocar dicho m&eacute;todo, 
    siguiendo una estructura m&aacute;s restrictiva.</li>
  
<li>
<span class="codefrag">service</span>: Define el servicio como una colecci&oacute;n de 
    puertos a los que se puede acceder. Un puerto es la direcci&oacute;n (URL) 
    donde el servicio act&uacute;a. Esta ser&aacute; la direcci&oacute;n a la 
    que las aplicaciones deber&aacute;n conectarse para acceder al servicio. Adem&aacute;s 
    contiene la documentaci&oacute;n en lenguaje natural del servicio.</li>

</ul>
<p>Un documento WSDL de ejemplo es el siguiente:</p>
<pre class="code">&lt;?xml version="1.0" encoding="utf-8" ?&gt; 
  &lt;<strong>definitions</strong> xmlns:s="http://www.w3.org/2001/XMLSchema"
     xmlns:http="http://schemas.xmlsoap.org/wsdl/http/"    
     xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" 
     xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/"
     xmlns:tns="http://j2ee.ua.es/wsdl"
     xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" 
     targetNamespace="http://j2ee.ua.es/wsdl"
     xmlns="http://schemas.xmlsoap.org/wsdl/"&gt;
   &lt;<strong>message</strong> name="getTempRequest"&gt;
     &lt;part name="string_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:string" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>message</strong> name="getTempResponse"&gt;
     &lt;part name="double_1" 
           xmlns:partns="http://www.w3.org/2001/XMLSchema"
           type="partns:double" /&gt; 
   &lt;/<strong>message</strong>&gt;
   &lt;<strong>portType</strong> name="TempPortType"&gt;
     &lt;operation name="getTemp"&gt;
       &lt;input message="tns:getTempRequest" /&gt; 
       &lt;output message="tns:getTempResponse" /&gt; 
     &lt;/operation&gt;
   &lt;/<strong>portType</strong>&gt;
   &lt;<strong>binding</strong> name="TempPortSoapBinding" type="tns:TempPortType"&gt;
     &lt;soap:binding style="rpc" 
         transport="http://schemas.xmlsoap.org/soap/http" /&gt; 
     &lt;operation name="getTemp"&gt;
       &lt;soap:operation soapAction=" style="rpc" /&gt; 
       &lt;input&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl" 
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/input&gt;
       &lt;output&gt;
         &lt;soap:body use="encoded" 
         namespace="http://j2ee.ua.es/wsdl"    
         encodingStyle=
           "http://schemas.xmlsoap.org/soap/encoding/" /&gt; 
       &lt;/output&gt;
     &lt;/operation&gt;
   &lt;/<strong>binding</strong>&gt;
   &lt;<strong>service</strong> name="Temp"&gt;
     &lt;documentation&gt;Documentacion&lt;/documentation&gt;    
     &lt;port name="TempPort" binding="tns:TempPortSoapBinding"&gt;
       &lt;soap:address 
           location="http://localhost:7001/sw_temp/Temp" /&gt; 
     &lt;/port&gt;
   &lt;/<strong>service</strong>&gt;
&lt;/<strong>definitions</strong>&gt;</pre>
<p>En el que se define un servicio que proporciona el m&eacute;todo <span class="codefrag">getTemp</span>, 
  que toma como par&aacute;metro una cadena con el nombre del &aacute;rea que 
  queremos consultar, y nos devuelve un valor real. </p>
<p>En los elementos <span class="codefrag">message</span> vemos que tenemos dos mensajes: los 
  mensajes de entrada y salida de la operaci&oacute;n <span class="codefrag">getTemp</span> de nuestro 
  servicio. El mensaje de entrada contiene un dato de tipo <span class="codefrag">string</span> (el 
  par&aacute;metro del m&eacute;todo), y el de salida es de tipo <span class="codefrag">double</span> 
  (la temperatura que devuelve el servicio).</p>
<p>El elemento <span class="codefrag">portType</span> define la operaci&oacute;n <span class="codefrag">getTemp</span> 
  a partir de los mensajes de entrada y salida que la componen, y en <span class="codefrag">binding</span> 
  se establece esta operaci&oacute;n como de estilo <span class="codefrag">rpc</span>, con codificaci&oacute;n 
  <span class="codefrag">encoded</span>. Esto es lo que se conoce como tipo <span class="codefrag">rpc/encoded</span>. Actualmente
  dicho tipo de servicios est&aacute; desaprobado. Los servicios web deben ser en su lugar de
  tipo <span class="codefrag">document/literal</span>.</p>
<p>Por &uacute;ltimo en el apartado <span class="codefrag">service</span> se especifica el 
  puerto al que podemos conectar para usar el servicio, dando la URL a la que 
  nuestro cliente deber&aacute; acceder. </p>
<p>Podemos encontrar la especificaci&oacute;n de WSDL publicada en la p&aacute;gina 
  del W3C, en la direcci&oacute;n <span class="codefrag">http://www.w3.org/TR/wsdl</span>.</p>
<p></p>
<a name="N1022F"></a><a name="Tecnolog%C3%ADas+de+segunda+generaci%C3%B3n"></a>
<h3 class="underlined_5">Tecnolog&iacute;as de segunda generaci&oacute;n</h3>
<p>Una vez asentadas las tecnolog&iacute;as b&aacute;sicas para servicios web que hemos visto en los puntos anteriores, se empiezan a desarrollar extensiones sobre ellas para cubrir las necesidades que van apareciendo, entre las que encontramos:</p>
<ul>

<li>
<em>WS-Policy</em> y <em>WS-PolicyAttachment</em> nos permitir&aacute;n describir funcionalidades que no pod&iacute;amos especificar con WSDL.</li>

<li>
<em>WS-Security</em> nos permitir&aacute; a&ntilde;adir caracter&iacute;sticas de seguridad adaptadas a las necesidades de seguridad de los Servicios Web. Con esta API podemos utilizar seguridad a nivel de mensaje (encriptando s&oacute;lo determinadas partes del mensaje SOAP), mientras que con SSL s&oacute;lo podr&iacute;amos hacer que fuese seguro a nivel de transporte.</li>

<li>
<em>WS-Addressing</em> y <em>WS-ReliableMessaging</em> nos permitir&aacute;n especificar la direcci&oacute;n de un servicio y realizar un control de flujo de los mensajes respectivamente. Gracias a esto se podr&aacute; por ejemplo implementar servicios con estado, o servicios que funcionen de forma as&iacute;ncrona. Podremos hacer una petici&oacute;n sin quedarnos bloqueados esperando una respuesta, y recibir la respuesta mediante un <em>callback</em>.</li>

<li>
<em>WS-Coordination</em> o <em>BPEL</em> nos permitir&aacute;n orquestar servicios web.</li>

</ul>
<a name="N1025C"></a><a name="WS-I+Basic+Profile"></a>
<h3 class="underlined_5">WS-I Basic Profile</h3>
<p>La <em>Web Services Interoperability Organization</em> (WS-I) vela por
el cumplimiento de los est&aacute;ndares en los servicios web, de forma que se garantice
la interoperabilidad entre servicios web desarrollados en diferentes plataformas.</p>
<p>Hemos visto hasta el momento diferentes est&aacute;ndares que dan soporte a los
servicios web (SOAP, WSDL). El problema es que dichos est&aacute;ndares contienen
algunas ambig&uuml;edades, que pueden ser interpretadas de forma diferente por los
desarrolladores de diferentes plataformas, y que tampoco se especifica como
usar las tres tecnolog&iacute;as de forma conjunta para el desarrollo de servicios web
(s&oacute;lo se dan las especificaciones por separado). Para solucionar este 
problema la WS-I crea la especificaci&oacute;n WS-I Basic Profile, para aclarar
la forma en la que estas tecnolog&iacute;as deben ser utilizadas cuando las utilizamos
para construir servicios web.</p>
<p>En el WS-I Basic Profile tambi&eacute;n se especifica como deben combinarse
las tecnolog&iacute;as SOAP, WSDL y UDDI para el desarrollo de servicios web. Utilizaremos
un registro UDDI para publicar los servicios. De estos servicios se publicar&aacute; un
documento WSDL como instrucciones de uso. En el WSDL figurar&aacute; la interfaz del
servicio, y la forma de acceder a &eacute;l, que ser&aacute; mediante protocolo SOAP.</p>
<p>Por lo tanto, cuando desarrollemos servicios web que cumplan con dicho 
perfil, podremos tener la certeza de que podr&aacute;n ser accedidos por clientes
que tambi&eacute;n lo cumplan.</p>
</div>

<a name="N10273"></a><a name="Tecnolog%C3%ADas+J2EE+para+Servicios+Web"></a>
<h2 class="underlined_10">Tecnolog&iacute;as J2EE para Servicios Web</h2>
<div class="section">
<p>Hemos visto las tecnolog&iacute;as en las que se basan los Servicios Web, y 
  que los hacen independientes de la plataforma y del lenguaje de programaci&oacute;n 
  utilizado. Sin embargo, escribir manualmente los mensajes SOAP desde nuestras 
  aplicaciones puede ser una tarea tediosa. Por ello, las distintas plataformas 
  existentes incorporan librer&iacute;as y utilidades que se encargan de realizar 
  esta tarea por nosotros.</p>
<p>En este tema veremos las librer&iacute;as que incorpora Java EE para la generaci&oacute;n 
  y el procesamiento de c&oacute;digo XML, que nos servir&aacute;n para implementar 
  y utilizar Servicios Web.</p>
<p>Hemos de destacar que las tecnolog&iacute;as Java para servicios web cumplen con el
WS-I Basic Profile, por lo que tenemos garantizada la interoperabilidad con
gran parte de los servicios web desarrollados en otras plataformas.</p>
<a name="N10282"></a><a name="JAXP"></a>
<h3 class="underlined_5">JAXP</h3>
<p>La API JAXP nos permite procesar cualquier documento XML desde lenguaje Java. 
  Tiene en cuenta los espacios de nombres, lo cual nos permite trabajar con DTDs 
  que podr&iacute;an tener conflictos de nombres si estos no estuviesen soportados. 
  Adem&aacute;s, soporta XSLT, lo cual nos permitir&aacute; convertir un documento 
  XML a otro formato, como por ejemplo HTML.</p>
<p>Esta es una librer&iacute;a gen&eacute;rica, para procesar cualquier documento 
  XML. A continuaci&oacute;n veremos una serie de librer&iacute;as, para tareas 
  m&aacute;s especificas, que se apoyan en JAXP para realizar el procesado de 
  diferentes lenguajes como SOAP, WSDL y UDDI, todos ellos derivados de XML. Por 
  lo tanto, todas estas librer&iacute;as depender&aacute;n de JAXP para su correcto 
  funcionamiento.</p>
<a name="N1028F"></a><a name="JAXM"></a>
<h3 class="underlined_5">JAXM</h3>
<p>La API JAXM implementa la mensajer&iacute;a XML en Java orientada al documento. 
  Nos permitir&aacute; de forma sencilla crear mensajes XML, insertando el contenido 
  que queramos en ellos, y enviarlos a cualquier destinatario, as&iacute; como 
  extraer el contenido de los mensajes que recibamos. Permite enviar y recibir 
  los mensajes de forma s&iacute;ncrona (modelo petici&oacute;n-respuesta) o as&iacute;ncrona 
  (env&iacute;o de mensaje sin esperar respuesta).</p>
<p>Los mensajes XML con los que trabaja JAXM siguen la especificaci&oacute;n SOAP 
  y SOAP con anexos. Dentro de JAXM encontramos dos APIs:</p>
<ul>
  
<li>SAAJ (<em>SOAP with Attachmets API for Java</em>) es la API que se utiliza 
    para construir mensajes SOAP y para extraer la informaci&oacute;n que contienen. 
    Esta API es independiente, y suficiente para enviar mensajes de tipo petici&oacute;n-respuesta 
    (s&iacute;ncronos).</li>
  
<li>JAXM proporciona un proveedor de mensajer&iacute;a XML, con el que podremos 
    enviar y recibir mensajes de forma as&iacute;ncrona, sin necesidad de esperar 
    una respuesta de la otra parte. Esta API depender&aacute; de SAAJ para funcionar, 
    ya que SAAJ es la que se encargar&aacute; de crear y manipular los mensajes.</li>

</ul>
<a name="N102A8"></a><a name="JAX-RPC+%2F+JAX-WS"></a>
<h3 class="underlined_5">JAX-RPC / JAX-WS</h3>
<p>La API JAX-RPC implementa la infraestructura para realizar llamadas a procedimiento 
  remoto (RPC) mediante XML. En este caso se enviar&aacute; un mensaje SOAP con 
  el m&eacute;todo que queremos invocar junto a los par&aacute;metros que le pasamos, 
  y nos devolver&aacute; de forma s&iacute;ncrona una respuesta SOAP con el valor 
  devuelto por el m&eacute;todo tras su ejecuci&oacute;n. </p>
<p>Por lo tanto, JAX-RPC depender&aacute; de SAAJ para construir los mensajes 
  SOAP, para enviarlos, y para extraer la informaci&oacute;n del mensaje SOAP 
  que nos devuelve como resultado.</p>
<p>Esta API nos permitir&aacute;, de forma sencilla, invocar Servicios Web, 
  as&iacute; como crear nuestros propios Servicios Web a partir 
  de clases Java que tengamos implementadas.</p>
<p>A partir de la versi&oacute;n 2.0, esta API pasa a recibir el nombre JAX-WS. Esta nueva versi&oacute;n se basa en JAXB para manipular los datos. Adem&aacute;s permite el uso de la API <em>Web Services Metadata for the Java Platform</em> que permite construir los servicios web utilizando anotaciones.</p>
<a name="N102BE"></a><a name="JAXR"></a>
<h3 class="underlined_5">JAXR</h3>
<p>La API JAXR nos permitir&aacute; acceder a registros XML a trav&eacute;s de 
  una API est&aacute;ndar Java. Esta API pretende proporcionar una interfaz &uacute;nica 
  para acceder a distintos tipos de registros, cada uno de los cuales tiene un 
  protocolo distinto.</p>
<p>Actualmente JAXR es capaz de trabajar con registros UDDI y ebXML. Podremos 
  realizar dos tipos de tareas distintas cuando accedamos a un registro mediante 
  JAXR:</p>
<ul>
  
<li>Consultar el registro, para localizar los servicios que necesitemos.</li>
  
<li>Publicar un servicio en el registro, para que otros clientes sean capaces 
    de localizarlo cuando lo necesiten, as&iacute; como modificar o eliminar los 
    servicios publicados que sean de nuestra propiedad.</li>

</ul>
<a name="N102D4"></a><a name="JAXB"></a>
<h3 class="underlined_5">JAXB</h3>
<p>La API de JAXB (<em>Java API for Binding</em>) nos permite asociar esquemas 
  XML y c&oacute;digo Java. A partir de un esquema XML, podremos generar una clase 
  Java que represente dicho esquema. </p>
<p>De esta forma podremos convertir un documento XML a una serie de objetos Java 
  que contendr&aacute;n la informaci&oacute;n de dicho documento (<em>unmarshalling</em>). 
  Podremos entonces trabajar desde nuestra aplicaci&oacute;n con estos objetos, 
  accediendo y modificando sus valores. Finalmente, podremos volver a obtener 
  un documento XML a partir de los objetos Java (<em>marshalling</em>).</p>
<p>Esto nos va a simplificar la tarea de utilizar tipos de datos propios en llamadas 
  a Servicios Web, ya que utilizando JAXB podremos realizar de forma sencilla 
  la conversi&oacute;n entre nuestra clase Java y un documento XML con la informaci&oacute;n 
  de dicha clase.</p>
<a name="N102ED"></a><a name="Otras+librer%C3%ADas"></a>
<h3 class="underlined_5">Otras librer&iacute;as</h3>
<p>Adem&aacute;s de las APIs Java est&aacute;ndar para servicios web, encontramos tambi&eacute;n algunas
librer&iacute;as adicionales desarrolladas por terceros que pueden sernos de utilidad. 
Por ejemplo, vamos a ver una serie de librer&iacute;as para trabajar con servicios web
que se encuentran enmarcadas dentro del proyecto Apache. M&aacute;s adelante estudiaremos 
el framework Axis, tambi&eacute;n de Apache, que es uno de los frameworks m&aacute;s utilizados
para el desarrollo de servicios web en Java.
</p>
<a name="N102F6"></a><a name="WSDL4J"></a>
<h4>WSDL4J</h4>
<p>La API de Java para WSDL (WSDL4J) nos permite de forma sencilla analizar documentos 
  WSDL, y de esa forma poder descubrir las caracter&iacute;sticas de un servicio 
  en tiempo de ejecuci&oacute;n. </p>
<p>Mediante esta API, podremos <em>"interrogar"</em> un servicio a partir 
  de su especificaci&oacute;n WSDL, y obtener informaci&oacute;n como las operaciones 
  que podemos invocar en este servicio, los par&aacute;metros que deberemos proporcionar 
  a cada una de ellas, y el tipo de datos resultante que nos devuelven. </p>
<p>De esta forma podremos realizar la integraci&oacute;n de la aplicaci&oacute;n 
  en tiempo de ejecuci&oacute;n, ya que no ser&aacute; necesario indicar al programa 
  c&oacute;mo debe acceder a un servicio, ni los m&eacute;todos a los que debe 
  llamar, sino que el programa ser&aacute; capaz de determinar esta informaci&oacute;n 
  analizando la especificaci&oacute;n WSDL del servicio. Si estamos interesados en 
  acceder a los servicios web de esta forma, lo m&aacute;s inmediato ser&aacute; utilizar directamente
  la siguiente API.</p>
<a name="N10309"></a><a name="WSIF"></a>
<h4>WSIF</h4>
<p>La API <em>Web Services Invocation Framework</em> (WSIF) nos va a permitir acceder
a los servicios web directamente a partir del WSDL, sin tener que programar el 
acceso mediante SOAP, ni crear ning&uacute;n <em>stub</em> que haga esto. Gracias a esta
API podremos hacer de forma sencilla una integraci&oacute;n din&aacute;mica y muy d&eacute;bilmente acoplada 
de cualquier servicio web en nuestras aplicaciones. </p>
<a name="N10319"></a><a name="UDDI4J"></a>
<h4>UDDI4J</h4>
<p>Otra de las librer&iacute;as para servicios web de Apache es UDDI4J. Esta librer&iacute;a
nos permite acceder a registros UDDI desde Java. Los registros UDDI se utilizan
para localizar servicios web. A diferencia de JAXR, esta
librer&iacute;a se centra &uacute;nicamente en UDDI, sin pretender ser una librer&iacute;a gen&eacute;rica
para acceso a registros XML. Esto hace que resulte m&aacute;s sencillo trabajar con 
ella, ya que est&aacute; adaptada a la nomenclatura utilizada en UDDI.</p>
</div>



<a name="N10325"></a><a name="Invocaci%C3%B3n+de+Servicios"></a>
<h2 class="underlined_10">Invocaci&oacute;n de Servicios</h2>
<div class="section">
<p>Vamos a ver ahora c&oacute;mo invocar Servicios Web desde 
  Java. Para ello contamos con la API JAX-WS (o JAX-RPC en versiones anteriores). 
  Con esta librer&iacute;a podremos ejecutar procedimientos de forma remota, simplemente haciendo 
  una llamada a dicho procedimiento, sin tener que introducir apenas c&oacute;digo 
  adicional. Ser&aacute; JAX-WS quien se encargue de gestionar internamente la 
  conexi&oacute;n con el servicio y el manejo de los mensajes SOAP de llamada 
  al procedimiento y de respuesta.</p>
<p>Podemos encontrar las clases de la API de JAX-WS dentro del paquete<span class="codefrag"> 
  javax.xml.ws</span> y en subpaquetes de &eacute;ste. </p>
<p>Nuestro cliente Java realizado con JAX-WS ser&aacute; interoperable con pr&aacute;cticamente 
  todos los servicios creados desde otras plataformas que cumplan el est&aacute;ndar WS-I.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Con JAX-WS no podremos invocar servicios que utilicen codificaci&oacute;n <span class="codefrag">rpc/encoded</span>, ya que el uso
  de esta codificaci&oacute;n est&aacute; desaconsejado por los est&aacute;ndares actuales. En estos casos deberemos utilizar
  la antigua librer&iacute;a JAX-RPC, que si que es compatible con este tipo de servicios.</div>
</div>
<a name="N1033D"></a><a name="Tipos+de+acceso"></a>
<h3 class="underlined_5">Tipos de acceso</h3>
<p>Tenemos dos formas diferentes de invocar un Servicio Web utilizando JAX-WS o JAX-RPC:</p>
<ul>
  
<li>
<strong>Creaci&oacute;n de un stub est&aacute;tico</strong>: Consiste en 
    generar una capa de <em>stub</em> por debajo del cliente de forma autom&aacute;tica. 
    Dicho <em>stub</em> implementar&aacute; la misma interfaz que el servicio, 
    lo cu&aacute;l nos permitir&aacute; desde nuestro cliente acceder al Servicio 
    Web a trav&eacute;s del <em>stub</em> tal y como si estuvi&eacute;ramos accediendo 
    directamente al servicio. 
    <p>Para utilizar este mecanismo es recomendable contar con alguna herramienta 
      dentro de nuestra plataforma que nos permita generar dicho <em>stub</em>, 
      para no tener que encargarnos nosotros de realizar esta tarea manualmente.</p>
  
</li>
  
<li>
<strong>Utilizaci&oacute;n de la Interfaz de Invocaci&oacute;n Din&aacute;mica 
    (DII)</strong>: Esta forma de acceso nos permitir&aacute; hacer llamadas a 
    procedimientos de nuestro Servicio Web de forma din&aacute;mica, sin crear 
    un <em>stub</em> para ello. Utilizaremos este tipo de invocaci&oacute;n cuando 
    no conozcamos la interfaz del servicio <em>a priori</em>, para invocarlo deberemos 
    proporcionar &uacute;nicamente los nombres de los m&eacute;todos a utilizar 
    mediante una cadena de texto. 
    <p>Podremos utilizar esta interfaz din&aacute;mica aunque no contemos con 
      un documento WSDL que nos indique la interfaz y datos de nuestro servicio. 
      En este caso, deberemos proporcionar manualmente esta informaci&oacute;n, 
      de forma que sea capaz de acceder al servicio correctamente.</p>
  
</li>

</ul>
<a name="N1036C"></a><a name="Invocaci%C3%B3n+mediante+stub+est%C3%A1tico"></a>
<h3 class="underlined_5">Invocaci&oacute;n mediante stub est&aacute;tico</h3>
<p>Est&aacute; ser&aacute; la forma m&aacute;s sencilla de acceder siempre que 
  contemos con una herramienta que genera el <em>stub</em> de forma autom&aacute;tica. 
</p>
<p>De esta forma, una vez generado el <em>stub</em>, s&oacute;lo tendremos que 
  utilizar este <em>stub</em> como si se tratase de nuestro servicio directamente. 
  En el <em>stub</em> podremos hacer las mismas llamadas a m&eacute;todos que 
  har&iacute;amos directamente en la clase que implemente nuestro servicio, ya 
  que ambos implementar&aacute;n la misma interfaz.</p>
<p>Las herramientas para generar este <em>stub</em> variar&aacute;n seg&uacute;n la plataforma con la 
  que trabajemos. A partir de JDK 1.6 se incluye en Java SE la librer&iacute;a JAX-WS y las herramientas
  necesarias para crear e invocar servicios. En el caso de contar con versiones anteriores de JDK, 
  podemos o bien incorporar a nuestro proyecto las librer&iacute;as necesarias (JAX-WS o JAX-RPC), o bien 
  utilizar herramientas y librer&iacute;as similares proporcionadas por los servidores de aplicaciones, como es el 
  caso de Weblogic 9.2, o desarrolladas por terceros, como es el caso de Apache Axis, y de CXF.</p>
<a name="N1038B"></a><a name="Interfaz+de+invocaci%C3%B3n+din%C3%A1mica+%28DII%29"></a>
<h3 class="underlined_5">Interfaz de invocaci&oacute;n din&aacute;mica (DII)</h3>
<p>Mediante esta interfaz ya no utilizaremos un <em>stub</em> para invocar los 
  m&eacute;todos del servicio, sino que nos permitir&aacute; invocar los m&eacute;todos 
  de forma din&aacute;mica, indicando simplemente el nombre del m&eacute;todo 
  que queremos invocar como una cadena de texto, y sus par&aacute;metros como 
  un <em>array</em> de objetos.</p>
<p>Esto nos permitir&aacute; utilizar servicios que no conocemos previamente. 
  De esta forma podremos implementar por ejemplo un <em>broker</em> de servicios. 
  Un <em>broker</em> es un servicio intermediario, al que podemos solicitar alguna 
  tarea que necesitemos. Entonces el <em>broker</em> intentar&aacute; localizar 
  el servicio m&aacute;s apropiado para dicha tarea en un registro de servicios, 
  y lo invocar&aacute; por nosotros. Una vez haya conseguido la informaci&oacute;n 
  que requerimos, nos la devolver&aacute;. De esta forma la localizaci&oacute;n 
  de servicios se hace totalmente transparente para nosotros.</p>
<p>Podremos acceder con esta interfaz tanto si contamos con un documento WSDL 
  como si no contamos con &eacute;l, pero en el caso de que no tengamos el WSDL 
  deberemos especificar en el c&oacute;digo todos los datos incluidos en estos 
  documentos que necesitemos y de los que en este caso no disponemos (<em>endpoint</em>, 
  par&aacute;metros y tipos, etc).</p>
<a name="N103AC"></a><a name="A+partir+de+un+documento+WSDL"></a>
<h4>A partir de un documento WSDL</h4>
<p>Vamos a ver el caso en el que contamos con el documento WSDL que describe el 
  servicio. El primer paso ser&aacute; conseguir el objeto <span class="codefrag">Service</span> 
  igual que hicimos en el caso anterior:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance();
Service serv = sf.createService(
  new URL("http://localhost:7001/HolaMundo/hola?WSDL"), 
  new QName("http://jtech.ua.es", "Conversion"));</pre>
<p>Utilizaremos el objeto <span class="codefrag">Call</span> para hacer las llamadas din&aacute;micas 
  a los m&eacute;todos del servicio. Deberemos crear un objeto <span class="codefrag">Call</span> 
  correspondiente a un determinado puerto y operaci&oacute;n de nuestro servicio:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>El &uacute;ltimo paso ser&aacute; invocar la llamada que hemos creado:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
<p>A este m&eacute;todo le debemos proporcionar un <em>array</em> de objetos como 
  par&aacute;metro, ya que debe poder utilizarse para cualquier operaci&oacute;n, 
  con diferente n&uacute;mero y tipo de par&aacute;metros. Como tampoco se conoce<em> 
  a priori</em> el valor devuelto por la llamada, deberemos hacer una conversi&oacute;n 
  <em>cast</em> al tipo que corresponda, ya que nos devuelve un <span class="codefrag">Object</span> 
  gen&eacute;rico.</p>
<a name="N103E8"></a><a name="Sin+un+documento+WSDL"></a>
<h4>Sin un documento WSDL</h4>
<p>Si no contamos con el WSDL del servicio, crearemos un objeto <span class="codefrag">Service</span> 
  proporcionando &uacute;nicamente el nombre del servicio:</p>
<pre class="code">ServiceFactory sf = ServiceFactory.newInstance(); 
Service serv = sf.createService( 
  new QName("http://jtech.ua.es", "HolaMundo"));</pre>
<p>A partir de este objeto podremos obtener un objeto <span class="codefrag">Call</span> para 
  realizar una llamada al servicio de la misma forma que vimos en el caso anterior:</p>
<pre class="code">
<strong>Call</strong> call = serv.<strong>createCall</strong>(
  new QName("http://jtech.ua.es", "HolaMundoPortTypeSoapPort"),
  new QName("http://jtech.ua.es", "saluda"));</pre>
<p>En este caso el objeto <span class="codefrag">Call</span> no tendr&aacute; ninguna informaci&oacute;n 
  sobre las caracter&iacute;sticas del servicio, ya que no tiene acceso al documento 
  WSDL que lo describe, por lo que deberemos proporcion&aacute;rselas nosotros 
  expl&iacute;citamente.</p>
<p>En primer lugar, deberemos especificar el <em>endpoint</em> del servicio, para 
  que sepa a qu&eacute; direcci&oacute;n debe conectarse para acceder a dicho 
  servicio:</p>
<pre class="code">call.<strong>setTargetEndpointAddress</strong>(endpoint);</pre>
<p>Una vez especificada esta informaci&oacute;n, deberemos indicar el tipo de 
  datos que nos devuelve la llamada a la operaci&oacute;n que vamos a invocar 
  (en nuestro ejemplo <span class="codefrag">saluda</span>):</p>
<pre class="code">QName t_int = 
  new QName("http://www.w3.org/2001/XMLSchema", "int");
call.<strong>setReturnType</strong>(t_string);</pre>
<p>Por &uacute;ltimo, indicaremos los par&aacute;metros de entrada que toma la 
  operaci&oacute;n y sus tipos:</p>
<pre class="code">QName t_double = 
  new QName("http://www.w3.org/2001/XMLSchema", "string");
call.<strong>addParameter</strong>("string_1", t_string, ParameterMode.IN);</pre>
<p>Una vez hecho esto, podremos invocar dicha operaci&oacute;n igual que en el 
  caso anterior:</p>
<pre class="code">Integer result = (Integer) call.<strong>invoke</strong>(
                 new Object[] { "Miguel" });</pre>
</div>


<a name="N1043E"></a><a name="Implementaci%C3%B3n+de+los+Servicios+Web+en+Java"></a>
<h2 class="underlined_10">Implementaci&oacute;n de los Servicios Web en Java</h2>
<div class="section">
<p>En las aplicaciones basadas en JAX-RPC/WS encontramos los siguientes elementos:</p>
<ul>
  
<li>
<strong>Servicio</strong>: Elemento del servidor que implementa la funcionalidad 
    de nuestro servicio. Normalmente utilizaremos una clase Java o un EJB.</li>
  
<li>
<strong>Cliente</strong>: Aplicaci&oacute;n cliente que invoca los m&eacute;todos 
    del servicio remoto. La localizaci&oacute;n del servicio ser&aacute; transparente 
    para el desarrollador de esta aplicaci&oacute;n, que invocar&aacute; los m&eacute;todos 
    del servicio de la misma forma que si &eacute;ste fuese local.</li>
  
<li>
<strong>Stub</strong>: Capa en el cliente que implementa la interfaz del 
    servicio, y utiliza internamente JAX-RPC/WS para construir los mensajes SOAP 
    necesarios para invocar cada m&eacute;todo de la interfaz, y para leer el 
    mensaje de respuesta que recibamos. Este <em>stub</em> ser&aacute; el sustituto 
    del servicio en el lado del cliente, la aplicaci&oacute;n cliente ejecutar&aacute; 
    en &eacute;l los m&eacute;todos que ofrece el servicio, haciendo de esta forma 
    transparente la localizaci&oacute;n del servicio para ella.</li>
  
<li>
<strong>Tie</strong>: Capa en el servidor que decodificar&aacute; los mensajes 
    SOAP entrantes con destino a nuestro servicio, y leer&aacute; de ellos el 
    m&eacute;todo que se quiere invocar y los par&aacute;metros de entrada que 
    se proporcionan. Esta capa acceder&aacute; al componente (clase Java o EJB) 
    que implementa nuestro servicio, ejecutando dicho m&eacute;todo en &eacute;l. 
    Una vez obtenido el resultado, generar&aacute; un mensaje SOAP de respuesta 
    y lo devolver&aacute; al cliente. </li>
  
<li>
<strong>JAX-RPC/WS</strong>: Librer&iacute;a que nos permitir&aacute; analizar 
    y componer mensajes SOAP, y enviarlos a trav&eacute;s de 
    protocolo HTTP. Adem&aacute;s proporciona <em>listeners</em> y <em>servlets</em> 
    que permanecer&aacute;n a la escucha en el servidor para recibir mensajes 
    entrantes de peticiones a los servicios. Una vez recibida una petici&oacute;n, 
    utilizar&aacute; la capa <strong>Tie</strong> del servicio correspondiente 
    para invocarlo, proporcion&aacute;ndole a esta capa el mensaje SOAP entrante. 
    A diferencia de las capas anteriores, que son espec&iacute;ficas para un servicio 
    concreto, la librer&iacute;a JAX-RPC/WS es gen&eacute;rica, nos servir&aacute; 
    para cualquier servicio web SOAP.</li>

</ul>
<p>
<img alt="Arquitectura de JAX-RPC" content-width="5cm" height="115" src="imagenes/jaxrpc.gif" width="259"></p>
<p>Las &uacute;nicas capas que debemos implementar nosotros son el <strong>Cliente</strong> 
  y el <strong>Servicio</strong>. En la implementaci&oacute;n de estos componentes 
  el uso de la librer&iacute;a JAX-RPC/WS ser&aacute; totalmente transparente para 
  nosotros. No har&aacute; falta que introduzcamos c&oacute;digo JAX-RPC/WS dentro 
  de ellas. En el servicio simplemente implementaremos los m&eacute;todos que 
  queremos que ofrezca nuestro servicio, como si se tratase de cualquier clase 
  Java, y en el cliente podremos invocar los m&eacute;todos de este servicio como 
  si invoc&aacute;semos directamente los m&eacute;todos de la clase Java.</p>
<p>Las capas <strong>Stub</strong> y <strong>Tie</strong>, son capas construidas 
  a medida para la interfaz de nuestro servicio. Est&aacute;s son las capas que 
  utilizar&aacute;n JAX-RPC/WS para generar y leer los mensajes SOAP que vamos a 
  utilizar para invocar el servicio, y devolver la respuesta al cliente. Generar&aacute;n 
  o ser&aacute;n capaces de leer los mensajes apropiados para el caso concreto 
  de los m&eacute;todos que definimos en nuestro servicio, por lo que deberemos 
  generar estas capas para cada servicio que desarrollemos. Afortunadamente, normalmente 
  contaremos con herramientas que generen de forma autom&aacute;tica estas capas 
  a partir de la interfaz de nuestro servicio, por lo que no ser&aacute; necesario 
  que el desarrollador de servicios trate directamente con JAX-RPC/WS en ning&uacute;n 
  momento.</p>
</div>

<a name="N1048A"></a><a name="Tipos+de+datos+compatibles"></a>
<h2 class="underlined_10">Tipos de datos compatibles</h2>
<div class="section">
<p>Cuando trabajamos con JAX-WS, los tipos de datos que podremos utilizar 
  como tipo de los par&aacute;metros y de valor de retorno de los m&eacute;todos 
  de nuestro servicio ser&aacute;n los tipos soportados por JAXB.</p>
<p>Podremos utilizar cualquiera de los tipos b&aacute;sicos de Java:</p>
<pre class="code">boolean
byte
double
float
int
long
short
char</pre>
<p>Adem&aacute;s, tambi&eacute;n podremos utilizar cualquiera de los <em>wrappers</em> 
  de estos tipos b&aacute;sicos:</p>
<pre class="code">java.lang.Boolean
java.lang.Byte
java.lang.Double
java.lang.Float
java.lang.Integer
java.lang.Long
java.lang.Short
java.lang.Character</pre>
<p>Las siguientes clases de Java tambi&eacute;n son aceptadas como tipos v&aacute;lidos 
  por JAX-WS:</p>
<pre class="code">java.lang.String
java.math.BigDecimal
java.math.BigInteger
java.util.Calendar
java.util.Date
javax.xml.namespace.QName
java.net.URI</pre>
<p>Adem&aacute;s de estos datos, se permitir&aacute; el uso de colecciones cuyos elementos podr&aacute;n 
  ser de cualquiera de los tipos admitidos. Estas colecciones podr&aacute;n ser <em>arrays</em>, 
  tanto unidimensionales como multidimensionales, o clases del marco de colecciones de Java:</p>
<pre class="code">
<strong>Listas: List</strong> 
ArrayList 
LinkedList 
Stack 
Vector 
<strong>Mapas: Map</strong> 
HashMap 
Hashtable 
Properties 
TreeMap 
<strong>Conjuntos: Set</strong> 
HashSet 
TreeSet 
</pre>
<p>Las clases desarrolladas por nosotros tambi&eacute;n podr&aacute;n ser usadas 
  si cumplen ciertas condiciones:</p>
<ul>
  
<li>Debe tener al menos un constructor p&uacute;blico sin par&aacute;metros.</li>
  
<li>No debe implementar la interfaz RMI <span class="codefrag">java.rmi.Remote</span>.</li>
  
<li>Todos sus campos deben ser tipos soportados por JAX-WS. Estos campos pueden 
    ser p&uacute;blicos, protegidos o privados. Para que JAX-WS sea capaz de 
    leer o establecer los valores de estos campos deber&aacute; cumplirse que: 
    <ul>
      
<li>Los campos p&uacute;blicos no deben ser ni <span class="codefrag">final</span> ni <span class="codefrag">transient</span>.</li>
      
<li>Los campos no p&uacute;blicos deben tener sus correspondientes <em>getters</em> y <em>setters</em>.</li>
    
</ul>
  
</li>

</ul>
<p>Si nuestros tipos de datos no cumplen estas caracter&iacute;sticas, o bien 
  estamos trabajando con herramientas que no soportan estos tipos, deberemos construir 
  manualmente <em>marshallers</em> y <em>unmarshallers</em> para nuestras clases utilizando JAXB. Su funci&oacute;n 
  ser&aacute; realizar la conversi&oacute;n entre nuestra clase Java y su correspondiente 
  formato como documento XML.</p>
<div class="frame note">
<div class="label">Nota</div>
<div class="content">Para que se generen autom&aacute;ticamente los artefactos que permitan tratar nuestros tipos de 
datos propios, estos deben quedar expuestos en la interfaz del servicio (par&aacute;metros o resultados de los 
m&eacute;todos). En estos casos es por lo tanto necesario utilizar arrays o gen&eacute;ricos (por ejemplo <span class="codefrag">Articulo []</span> o 
<span class="codefrag">ArrayList&lt;Articulo&gt;</span> en lugar de <span class="codefrag">ArrayList</span>), ya que de esta manera se especifica de forma expl&iacute;cita el 
tipo de datos utilizado.</div>
</div>
</div>



<a name="N104FB"></a><a name="Implementaci%C3%B3n+del+servicio%3A+Fichero+JWS"></a>
<h2 class="underlined_10">Implementaci&oacute;n del servicio: Fichero JWS</h2>
<div class="section">
<p>Para implementar los servicios deberemos crear una clase <em>JWS</em>, que consiste en una 
clase Java con anotaciones de la API <em>Web Services Metadata for the Java Platform</em> 
(JSR-181). Parte de los m&eacute;todos de esta clase se ofrecer&aacute;n como operaciones del servicio web.
Para poder ofrecer los m&eacute;todos de esta clase como servicio web deberemos
generar las capas vistas anteriormente. Para ello contaremos con diferentes herramientas,
que depender&aacute;n de la plataforma de desarrollo que utilizamos. Posteriormente 
veremos tanto las herramientas incluidas en JDK 1.6 como las herramientas de Weblogic.</p>
<p>La API <em>Web Services 
Metadata for the Java Platform</em> viene a estandarizar la forma en la que se definen 
los Servicios Web en Java. Anteriormente, cada plataforma defin&iacute;a su propia forma de 
crear servicios web, por lo que, por ejemplo, un servicio web desarrollado con el JWSDP 
de Sun no pod&iacute;a desplegarse directamente en Weblogic. Adem&aacute;s, el fichero JWS contendr&aacute; 
toda la informaci&oacute;n necesaria para generar el servicio, 
por lo que no har&aacute; falta tener la informaci&oacute;n sobre el servicio dispersa en diferentes 
ficheros como ocurr&iacute;a antes. </p>
<p>Para crear la clase JWS que implemente el servicio deberemos crear una clase con 
  un constructor sin par&aacute;metros (si no se crea ning&uacute;n constructor por defecto la 
  clase tendr&aacute; un constructor sin par&aacute;metros vac&iacute;o), y con al menos la anotaci&oacute;n 
  <span class="codefrag">@WebService</span>. Los m&eacute;todos p&uacute;blicos que definamos 
  en esta clase ser&aacute;n por defecto las operaciones que ofrecer&aacute; el 
  servicio aunque, como veremos m&aacute;s adelante, tambi&eacute;n podemos especificar mediante 
  anotaciones los m&eacute;todos que queremos que se publiquen como servicio. 
  Por ejemplo, podemos implementar nuestro servicio como:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebService;

<strong>@WebService</strong>
public class ConversionSW { 
  public int euro2ptas(double euro) {	   
    return (int) (euro * 166.386); 
  } 

  public double ptas2euro(int ptas) { 
    return ((double) ptas) / 166.386; 
  }
}</pre>
<p>Con esto habremos implementado la funcionalidad del servicio como una clase 
  Java ordinaria, sin necesitar tener conocimientos de ninguna librer&iacute;a 
  adicional.</p>
<p>De forma opcional, podemos a&ntilde;adir al servicio un campo <span class="codefrag">context</span> en el que se inyectar&aacute; un objeto
<span class="codefrag">WebServiceContext</span> que nos dar&aacute; acceso al contexto del servicio:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebService;

<strong>@WebService</strong>
public class ConversionSW { 
    <strong>@Resource
    private WebServiceContext context;</strong>

    ...
}</pre>
<p>Dado que realmente el servicio es un componente web, a trav&eacute;s de este objeto podremos tener acceso a
componentes de la API de <em>servlets</em> como la petici&oacute;n HTTP (<span class="codefrag">HttpServletRequest</span>), la sesi&oacute;n
(<span class="codefrag">HttpSession</span>), etc.</p>
<a name="N1053F"></a><a name="Anotaciones"></a>
<h3 class="underlined_5">Anotaciones</h3>
<p>Podemos especificar la forma en la que se crea el servicio mediante diferentes anotaciones. Las principales anotaciones disponibles son:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>
<th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th><th colspan="1" rowspan="1"></th>
</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebService</span></td>
<td colspan="2" rowspan="1">Indica que la clase define un servicio web. Se pueden especificar como par&aacute;metros los nombres del servicio, del puerto, y de su espacio de nombres, que figurar&aacute;n en el documento WSDL del servicio:

<pre class="code">@WebService(name="ConversionPortType", 
    serviceName="ConversionService",
    targetNamespace="http://jtech.ua.es")</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@SOAPBinding</span></td>
<td colspan="2" rowspan="1">Permite especificar el estilo y la codificaci&oacute;n de los mensajes SOAP utilizados para invocar el servicio. Por ejemplo:
<pre class="code">@SOAPBinding(style=SOAPBinding.Style.DOCUMENT,
    use=SOAPBinding.Use.LITERAL,
    parameterStyle=
      SOAPBinding.ParameterStyle.WRAPPED)</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebMethod</span></td>
<td colspan="2" rowspan="1">Indica que un determinado m&eacute;todo debe ser publicado como operaci&oacute;n del servicio. Si no se indica para ning&uacute;n m&eacute;todo, se considerar&aacute; que deben ser publicados todos los m&eacute;todos p&uacute;blicos. Si no, s&oacute;lo se publicar&aacute;n los m&eacute;todos indicados. Adem&aacute;s, de forma opcional se puede indicar como par&aacute;metro el nombre con el que queramos que aparezca la operaci&oacute;n en el documento WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(double euros) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@Oneway</span></td>
<td colspan="2" rowspan="1">Indica que la llamada a la operaci&oacute;n no debe esperar ninguna respuesta. Esto s&oacute;lo lo podremos hacer con m&eacute;todos que devuelvan <span class="codefrag">void</span>. Por ejemplo:
<pre class="code">@Oneway()
@WebMethod()
public void publicarMensaje(String mensaje) {
   ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebParam</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute;n los par&aacute;metros en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
public int euro2ptas(
  @WebParam(name="CantidadEuros",
            targetNamespace="http://jtech.ua.es")
  double euros) {
    ...
}</pre>

</td>

</tr>

<tr>

<td colspan="1" rowspan="1"><span class="codefrag">@WebResult</span></td>
<td colspan="2" rowspan="1">Permite indicar el nombre que recibir&aacute; el mensaje de respuesta en el fichero WSDL:
<pre class="code">@WebMethod(operationName="eurosAptas")
@WebResult(name="ResultadoPtas",
    targetNamespace="http://jtech.ua.es")
public int euro2ptas(double euros) {
    ...
}</pre>

</td>

</tr>

</table>
<a name="N105C6"></a><a name="Estilo+y+codificaci%C3%B3n+del+servicio"></a>
<h3 class="underlined_5">Estilo y codificaci&oacute;n del servicio</h3>
<p>Hemos visto que mediante la anotaci&oacute;n <span class="codefrag">@SOAPBinding</span> podemos cambiar el estilo 
y la codificaci&oacute;n del servicio. Los posibles estilos son:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Style.RPC</span>: Se utilizan mensajes SOAP orientados a RPC, en los que 
se codifican en XML las llamadas a m&eacute;todos remotos.</li>

<li>
<span class="codefrag">SOAPBinding.Style.DOCUMENT</span>: Se utilizan mensajes SOAP orientados al documento. 
Dado que en estos mensajes se puede incluir cualquier tipo de documento XML, tambi&eacute;n se pueden 
utilizar para invocar operaciones de servicios.</li>

</ul>
<p>Podemos especificar tambi&eacute;n la codificaci&oacute;n:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.Use.LITERAL</span>: Esta es la &uacute;nica codificaci&oacute;n aceptada en el WS-I 
Basic Profile (BP), que da soporte a los servicios de tipo <em>document/literal</em> y 
<em>RPC/literal</em>.</li>

<li>
<span class="codefrag">SOAPBinding.Use.ENCODED</span>: Se trata de una codificaci&oacute;n que permite representar 
una mayor variedad de estructuras de datos que la anterior, pero est&aacute; desaprobada por el 
BP por ser la causa de gran cantidad de incompatibilidades entre servicios. De hecho JAX-WS 
es incompatible con los servicios de este tipo. Esta codificaci&oacute;n se suele utilizar con 
servicios de tipo RPC, dando lugar al tipo <em>RPC/encoded</em>.</li>

</ul>
<p>En el caso de los servicios de tipo <em>document/literal</em>, tambi&eacute;n podemos especificar 
la forma en la que se representan los tipos de datos de los par&aacute;metros de las operaciones:</p>
<ul>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.BARE</span>: Los par&aacute;metros se pasan directamente.</li>

<li>
<span class="codefrag">SOAPBinding.ParameterStyle.WRAPPED</span>: Los par&aacute;metros se pasan envueltos en 
tipos de datos complejos.</li>

</ul>
<p>Por defecto los servicios ser&aacute;n del tipo <em>document/literal/wrapped</em>.</p>
<a name="N10612"></a><a name="Tratamiento+de+errores"></a>
<h3 class="underlined_5">Tratamiento de errores</h3>
<p>Cuando se produzca un error en nuestro servicio, podemos lanzar una excepci&oacute;n de tipo 
<span class="codefrag">SOAPFaultException</span> para notificar al cliente del error producido. Al lanzar
esta excepci&oacute;n se devolver&aacute; al cliente un mensaje <em>SOAP Fault</em>. Podemos 
lanzar esta excepci&oacute;n de la siguiente forma:</p>
<pre class="code">package es.ua.jtech.servcweb.conversion;

import javax.jws.WebMethod;
import javax.jws.WebService;
import javax.xml.namespace.QName;
import javax.xml.rpc.soap.SOAPFaultException;
import javax.xml.soap.Detail;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPFactory;

@WebService
public class ConversionSW {

  @WebMethod
  public int euro2ptas(double euro) {	   
    if(euro&lt;0) {
      lanzarExcepcion("La cantidad de euros debe ser positiva");
    }
    return (int) (euro * 166.386); 
  } 

  @WebMethod
  public double ptas2euro(int ptas) { 
    if(ptas&lt;0) {
      lanzarExcepcion("La cantidad de ptas debe ser positiva");
    }
    return ((double) ptas) / 166.386; 
  }

  private void <strong>lanzarExcepcion</strong>(String mensaje) {
    Detail detail = null;

    try {
      SOAPFactory soapFactory = SOAPFactory.newInstance();
      detail = soapFactory.createDetail();
    } catch (SOAPException e) { }

    QName faultCode = null;
    String faultString = mensaje;
    String faultActor = "Servicio Conversion";
    throw new SOAPFaultException(faultCode, faultString, 
                                 faultActor, detail);
  }
}</pre>
</div>


<a name="N1062A"></a><a name="Servicios+Web+Avanzados"></a>
<h2 class="underlined_10">Servicios Web Avanzados</h2>
<div class="section">
<p>Vamos a ver una serie de caracter&iacute;sticas avanzadas de los Servicios Web SOAP dirigidas a mejorar
su calidad, lo que se conoce como <em>Quality of Service</em> (QoS). Estas caracter&iacute;sticas vendr&aacute;n dadas 
por tecnolog&iacute;as de segunda generaci&oacute;n, que se a&ntilde;aden a los lenguajes SOAP y WSDL para dotarlos de 
capacidades adicionales. Estudiaremos las siguientes caracter&iacute;sticas:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<td colspan="1" rowspan="1">Optimizaci&oacute;n de mensajes</td>
<td colspan="1" rowspan="1">MTOM, Fast Infoset</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Fiabilidad en la transmisi&oacute;n de mensajes</td>
<td colspan="1" rowspan="1">WS-ReliableMessaging</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Servicios con estado</td>
<td colspan="1" rowspan="1">Basados en WS-Addressing</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Seguridad a nivel de mensaje</td>
<td colspan="1" rowspan="1">WS-Security, WS-Trust</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Transacciones at&oacute;micas</td>
<td colspan="1" rowspan="1">WS-AtomicTransactions</td>

</tr>

</table>
<p>Estas caracter&iacute;sticas avanzadas se implementan en Java dentro de lo que se conoce como WSIT (<em>Web 
Services Interoperability Technologies</em>). Esta plataforma desarrollada por Sun, adem&aacute;s de dar soporte
a las anteriores tecnolog&iacute;as de segunda generaci&oacute;n, tiene como objetivo hacer que los servicios desarrollados
en ella sean interoperables con los servicios de Microsoft .NET 3.0. Estos &uacute;ltimos servicios se implementan
en la plataforma <em>Windows Communication Foundation</em> (WCF), que es el producto equivalente a WSIT en
las tecnolog&iacute;as de Microsoft. </p>
<p>En anteriores sesiones estudiamos JAX-WS, que nos permite trabajar con las tecnolog&iacute;as b&aacute;sicas para 
servicios web (SOAP y WSDL). En esta sesi&oacute;n vamos a estudiar las caracter&iacute;sticas avanzadas que ofrece
WSIT. Para m&aacute;s informaci&oacute;n sobre WSIT, se puede consultar el siguiente tutorial de Sun:</p>
<p>
<a href="http://java.sun.com/webservices/reference/tutorials/wsit/doc/">http://java.sun.com/webservices/reference/tutorials/wsit/doc/</a>
</p>
<a name="N1068B"></a><a name="Optimizaci%C3%B3n+de+mensajes"></a>
<h3 class="underlined_5">Optimizaci&oacute;n de mensajes</h3>
<p>Cuando hablamos de optimizaci&oacute;n de mensajes nos referimos a conseguir que los mensajes sean enviados
de forma eficiente a trav&eacute;s de la red. En los servicios SOAP los mensajes son documentos XML que requieren
una gran cantidad de informaci&oacute;n para cumplir con el est&aacute;ndar. Es decir, no tenemos &uacute;nicamente los datos 
que nos interesa comunicar, sino que estos datos se ven envueltos por varias etiquetas XML con informaci&oacute;n
sobre el nombre de la operaci&oacute;n, el espacio de nombres en el que se encuentra, las distintas partes del
documento SOAP, etc.</p>
<p>Toda esta informaci&oacute;n transmitida como texto en formato XML podr&iacute;a ser codificada en otros formatos
m&aacute;s compactos, para de esta forma ganar eficiencia en su transmisi&oacute;n a trav&eacute;s de la red. Esto es 
precisamente en lo que consiste la optimizaci&oacute;n de mensajes.</p>
<p>Un caso en el que la transmisi&oacute;n en XML resulta especialmente poco eficiente es en el que tratamos
con un volumen elevado de datos binarios. Para poder incluir informaci&oacute;n binaria en un mensaje de texto
debemos utilizar una codificaci&oacute;n como <em>base64</em>, que transforme la informaci&oacute;n binaria a un conjunto
de caracteres imprimibles, lo cual produce que este contenido ocupe un espacio considerablemente mayor.</p>
<p>Podemos optimizar el env&iacute;o de datos binarios mediante MTOM (<em>Message Transmission Optimization Mechanism</em>).
Este mecanismo de optimizaci&oacute;n de mensajes SOAP lo que har&aacute; ser&aacute; enviar los datos binarios como un anexo al 
mensaje, en lugar de enviarlo dentro del mismo texto. De esta forma los datos binarios se pueden enviar en
su formato original, sin necesidad de convertirlos a texto.</p>
<a name="N106A4"></a><a name="Servicios+web+seguros"></a>
<h3 class="underlined_5">Servicios web seguros</h3>
<p>Antes de empezar, vamos a recordar una serie de conceptos necesarios para entender los distintos 
mecanismos para dotar de seguridad a los servicios web.</p>
<ul>

<li>
<em>Cifrado con clave sim&eacute;trica</em>: Se utiliza una misma clave para cifrar y descifrar los datos. En
este caso esa clave debe ser conocida por los dos extremos de la comunicaci&oacute;n.</li>

<li>
<em>Cifrado con clave asim&eacute;trica</em>: Se tienen dos claves, una p&uacute;blica y otra privada. La clave p&uacute;blica 
puede ser difundida, pero la privada nunca se le comunicar&aacute; a nadie. Lo que se cifra con la clave p&uacute;blica, s&oacute;lo
puede ser discifrado con la privada, y viceversa. Por lo tanto, si queremos que los datos que nos env&iacute;en vengan
cifrados, deberemos proporcionar nuestra clave p&uacute;blica al otro extremo de la comunicaci&oacute;n, el emisor en este
caso, que utilizar&aacute; la clave para cifrar los datos y envi&aacute;rnoslos. Nosotros podremos descifrarlos con nuestra
clave privada, que nunca habremos entregado a nadie.</li>

<li>
<em>Huella digital</em>: Consiste en un c&oacute;digo de una determinada longitud (por ejemplo 128bits) generado
a partir de un documento mediante un algoritmo conocido como <em>digest</em>, como por ejemplo MD5 o SHA. Dos
documentos exactos tendr&aacute;n la misma huella, pero cualquier peque&ntilde;o cambio que se produzca alterar&aacute; fuertemente
dicha huella. Una misma huella podr&iacute;a corresponder a varios documentos diferentes.</li>

<li>
<em>Firma digital</em>: Consiste en cifrar la huella de los datos que estamos env&iacute;ando mediante nuestra
clave privada. El receptor de dicho documento podr&aacute; recuperar la huella descifr&aacute;ndola mediante nuestra clave 
p&uacute;blica, pero nunca podr&aacute; generar una nueva firma ya que no cuenta con nuestra clave privada. Una vez descifrada
la huella, podr&aacute; generar la huella de los datos recibidos y comprobar si coincide con la que le env&iacute;amos. Esto
le garantizar&aacute; que los datos no hayan sido modificados por nadie m&aacute;s a parte de nosotros, ya que somos los 
&uacute;nicos que tenemos en nuestro poder la clave privada necesaria para firmarlos.</li>

<li>
<em>Certificado digital</em>: Un certificado digital relaciona una clave p&uacute;blica con una determinada
entidad. Es un documento en el que figuran los datos de la entidad y su clave p&uacute;blica (necesaria para 
poder validar los datos recibidos de dicha entidad, o para enviarle informaci&oacute;n propia cifrada). Adem&aacute;s, 
dicho certificado habr&aacute; sido emitido por una Autoridad Certificadora (CA), y estar&aacute; firmado por ella, para 
as&iacute; poder confiar en su autenticidad. El protocolo m&aacute;s utilizado para certificar es el X.509.</li>

<li>
<em>Certificado ra&iacute;z</em>: Son los certificados correspondientes a las CAs, que contienen la clave p&uacute;blica
necesaria para validar los certificados emitidos por ellas. Son un caso especial de certificados, ya que
representan a la misma entidad que los ha emitido, por lo que no hay forma de validarlos, estos certificados
se presuponen v&aacute;lidos. Suelen venir ya instalados en las aplicaciones o dispositivos que utilizamos para
conectarnos, como son los navegadores web o dispositivos m&oacute;viles.</li>

</ul>
<p>Cuando hablamos de seguridad en el intercambio de informaci&oacute;n encontramos tres aspectos que 
debemos diferenciar:</p>
<ul>

<li>
<em>Confidencialidad</em>: Se trata de evitar que la informaci&oacute;n privada pueda ser vista por 
personas no autorizadas. Esto se resuelve mediante el cifrado de los datos (con clave sim&eacute;trica o 
asim&eacute;trica).</li>

<li>
<em>Integridad</em>: Se trata de evitar que los datos sean alterados indebidamente. Esto se resuelve
mediante el uso de una huella digital. Normalmente esta huella se encuentra cifrada mediante la 
clave privada de quien envi&oacute; estos datos, dando lugar a lo que se conoce como firma digital.</li>

<li>
<em>Autentificaci&oacute;n</em>: Se trata de verificar la identidad del otro extremo. Para autentificar a los
usuarios normalmente basta con que proporcionen <em>login</em> y <em>password</em>. Si se requiere
un mayor nivel de seguridad, se puede proporcionar al usuario un certificado firmado digitalmente
(como por ejemplo los certificados extendidos por la FNMT que nos permiten acceder a servicios para presentar
la declaraci&oacute;n de la renta). Para autentificar
a los sitios web (por ejemplo, cuando accedemos a nuestro banco, saber que realmente nos estamos 
comunicando con &eacute;l), tambi&eacute;n se utilizar&aacute; la firma digital (la informaci&oacute;n que nos proporcione
el servidor vendr&aacute; firmada por un certificado de su propiedad).</li>

</ul>
<p>En el caso de los servicios web debemos tener tambi&eacute;n en cuenta
  que estamos permitiendo invocar procedimientos remotos mediante 
  protocolo HTTP, que en un principio fue dise&ntilde;ado para la extracci&oacute;n 
  de documentos. Por lo tanto, sus puertos no suelen ser cortados por ning&uacute;n 
  <em>firewall</em>, de forma cualquiera podr&aacute; utilizar estos servicios 
  libremente, sin que los <em>firewalls</em> puedan controlarlo. Esto tambi&eacute;n
  podr&iacute;a suponer un problema de seguridad en la red si no tenemos cuidado.</p>
<a name="N106F6"></a><a name="Confidencialidad+e+integridad"></a>
<h3 class="underlined_5">Confidencialidad e integridad</h3>
<p>Cuando un cliente utiliza un Servicio Web, deber&aacute; enviarle un mensaje 
  a este servicio a trav&eacute;s de la red, y el servicio le responder&aacute; 
  mediante otro mensaje. Estos mensajes contendr&aacute;n informaci&oacute;n que 
  puede ser confidencial. En los casos en los que estemos transmitiendo informaci&oacute;n
  sensible en la invocaci&oacute;n al servicio, deberemos contar con m&eacute;todos para cifrar
  estos datos.</p>
<p>Dado que estos mensajes se env&iacute;an mediante protocolo HTTP, al igual que en el
  caso de las aplicaciones web podr&aacute;n ser encriptados mediante SSL (HTTPS), evitando 
  de esta forma que puedan ser le&iacute;dos o modificados por un tercero. El protocolo SSL en l&iacute;neas 
  generales consiste en los siguientes pasos:</p>
<ul>
  
<li>El cliente negocia con el servidor una clave sim&eacute;trica para cifrar la informaci&oacute;n (<em>handshake</em>). 
  Esta negociaci&oacute;n se hace utilizando la clave p&uacute;blica del certificado del servidor (el cliente obtiene 
  la clave p&uacute;blica del certificado del servidor, genera una clave sim&eacute;trica para la sesi&oacute;n, y se la env&iacute;a 
  cifrada al servidor mediante su clave p&uacute;blica). De forma opcional, el cliente podr&iacute;a autentificarse 
  mediante su propio certificado si fuese necesario. </li>
  
<li>Cliente y servidor intercambian la informaci&oacute;n cifr&aacute;ndola y firmandola mediante la clave sim&eacute;trica
  acordada. De esta manera dicho protocolo nos proporciona confidencialidad e integridad en las
  comunicaciones.</li>

</ul>
<p>Sin embargo, en aplicaciones en las que el mensaje deba atravesar una cadena 
  de nodos intermedios, este mensaje deber&aacute; desencriptarse y volverse a encriptar 
  entero en cada uno de estos servicios, por lo que los datos estar&aacute;n inseguros 
  dentro de cada nodo. Es decir, SSL nos proporciona seguridad a nivel de transporte, pero
  una vez el mensaje haya llegado a un nodo se descodificar&aacute; completamente, quedando as&iacute; 
  expuesto en su totalidad. Esto nos puede plantear un problema cuando el mensaje contenga 
  informaci&oacute;n destinada a diferentes servicios, y no queramos que desde uno de ellos se pueda
  acceder a informaci&oacute;n dirigida a los dem&aacute;s.</p>
<p>Este problema se puede solucionar cifrando por separado cada elemento del mensaje, y 
  permitiendo que se cada nodo descifre s&oacute;lo la parte del mensaje que le ata&ntilde;e, pero que no 
  pueda acceder al resto de elementos del mensaje que no le conciernen. Esto es lo que se 
  conoce como seguridad a nivel de mensaje.</p>
<p>Por lo tanto, encontramos dos formas para cifrar y firmar la informaci&oacute;n intercambiada en
la invocaci&oacute;n del servicio:</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">

<tr>

<th colspan="1" rowspan="1">Seguridad a nivel de transporte</th>
<th colspan="1" rowspan="1">Seguridad a nivel de mensaje</th>

</tr>

<tr>

<td colspan="1" rowspan="1">Se implementa mediante SSL.</td>
<td colspan="1" rowspan="1">Basada en la especificaci&oacute;n WS-Security.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Es dependiente del protocolo de transporte.</td>
<td colspan="1" rowspan="1">Es independiente del protocolo de transporte utilizado.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Resulta m&aacute;s eficiente.</td>
<td colspan="1" rowspan="1">Tiene un mayor coste.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Se puede aplicar a cualquier servicio accesible mediante HTTP.</td>
<td colspan="1" rowspan="1">Requiere que los actores soporten WS-Security.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Se protege el mensaje HTTP completo s&oacute;lo en su transmisi&oacute;n por la red.</td>
<td colspan="1" rowspan="1">Se protegen partes determinadas del mensaje hasta su llegada al <em>endpoint</em>.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">Si el cliente debe autentificarse mediante un certificado, s&oacute;lo podr&aacute; hacerlo ante el primer intermediario.</td>
<td colspan="1" rowspan="1">La autentificaci&oacute;n del cliente valdr&aacute; para todos los destinatarios.</td>

</tr>

<tr>

<td colspan="1" rowspan="1">No plantea problemas cuando tengamos una conexi&oacute;n punto-a-punto.</td>
<td colspan="1" rowspan="1">No plantea problemas ni aunque haya intermediarios.</td>

</tr>

</table>
<a name="N10786"></a><a name="Autentificaci%C3%B3n"></a>
<h3 class="underlined_5">Autentificaci&oacute;n</h3>
<p>Puede que necesitemos identificar a un usuario para prestarle un determinado 
  servicio, o bien para saber si tiene autorizaci&oacute;n para acceder a dicho 
  servicio. </p>
<p>Para identificar al usuario podemos simplemente solicitar un <em>login</em>
y <em>password</em>. En general, lo que haremos ser&aacute; proporcionar al servicio un
<em>token</em> con el que se identificar&aacute; al cliente. Encontramos los siguientes
tipos de <em>tokens</em>:</p>
<ul>

<li>
<em>Username token</em>: Consiste en un <em>login</em> y un <em>password</em>.</li>

<li>
<em>SAML token</em>: Un <em>token</em> SAML (<em>Security Assertion Markup Language</em>) est&aacute;
basado en XML y nos permitir&aacute; intercambiar informaci&oacute;n de autentificaci&oacute;n y autorizaci&oacute;n.</li>

<li>
<em>X.509 token</em>: Se autentifica al cliente mediante un certificado digital de su propiedad.</li>

</ul>
<p>Al aplicar la autentificaci&oacute;n a servicios web, al igual que en el caso anterior, tambi&eacute;n encontramos
un problema. Si necesitamos invocar un conjunto de servicios, deberemos autentificarnos por 
separado para cada uno de ellos, ya que pueden estar distribuidos en distintos servidores 
a trav&eacute;s de Internet. Para solucionar este problema, deber&iacute;amos contar con un contexto compartido 
global (gestor de identidades) de donde cualquier servicio pudiese obtener esta informaci&oacute;n de 
autentificaci&oacute;n, y de esta manera no tener que autentificarse por separado con cada servicio 
individual. Esto es lo que se conoce como <em>Single Sign On</em> (SSO).</p>
<p>Tanto <em>Microsoft Passport</em> como <em>Liberty Project</em> (formado por una 
alianza de empresas entre las que se encuentra Sun) pretenden dar soluci&oacute;n a este problema, 
proporcionando un servicio de autentificaci&oacute;n centralizado. De esta forma podremos acceder 
a diferentes servicios utilizando siempre el mismo <em>login</em>, ya que todos podr&iacute;an 
utilizar el mismo servidor de identidades para autentificarnos.</p>
<p>Para implementar SSO podemos utilizar los <em>tokens</em> SAML. Para acceder a un servicio lo que
haremos ser&aacute;:</p>
<ul>

<li>Acceder a un proveedor de identidades proporcionando nuestros credenciales.</li>

<li>El proveedor de identidades env&iacute;a al cliente un aserto SAML con la informaci&oacute;n de autentificaci&oacute;n y autorizaci&oacute;n.</li>

<li>El cliente podr&aacute; utilizar el aserto SAML para acceder al servicio.</li>

</ul>
<p>Glassfish nos permite instalar como a&ntilde;adido opcional <em>Sun Java System Access Manager</em>, un gestor
de identidades con el que podremos implementar SSO. Hemos de destacar que SSO es tanto aplicable a servicios 
web como a aplicaciones web. En este &uacute;ltimo caso los mensajes SAML se suelen pasar como campos ocultos
en formularios HTML, haciendo redirecciones entre el proveedor de identidades y el proveedor del servicio.</p>
<p>Tambi&eacute;n podemos proporcionar asertos SAML mediante un <em>Security Token Service</em> (STS). Un STS es un
servicio web que nos proporciona un <em>token</em> de seguridad. De esta forma puede proporcionar <em>tokens</em>
SAML que podamos utilizar para autentificarnos. Nuestro cliente acceder&aacute; al STS para obtener un <em>token</em>
de seguridad, y utilizar&aacute; dicho <em>token</em> para conectarse al servicio.</p>
<a name="N107F9"></a><a name="Frameworks+Java+para+Servicios+Web+Seguros"></a>
<h3 class="underlined_5">Frameworks Java para Servicios Web Seguros</h3>
<a name="N107FF"></a><a name="El+framework+Metro"></a>
<h4>El framework Metro</h4>
<p>Metro es la pila de tecnolog&iacute;as para servicios web Java desarrollada por Sun. El componente b&aacute;sico de esta
pila es la especificaci&oacute;n JAX-WS, la librer&iacute;a Java para servicios web que est&aacute; incluida dentro de Java SE desde
su versi&oacute;n 6. La forma de crear servicios con esta librer&iacute;a es mediante anotaciones en objetos java ordinarios
(POJOs).</p>
<p>Pero JAX-WS es s&oacute;lo un elemento de Metro. Esta pila proporciona numerosos servicios adicionales para los
servicios web:</p>
<ul>

<li>WS-Addressing</li>

<li>WS-Policy</li>

<li>WS-Security</li>

<li>WS-Transaction</li>

<li>WS-Reliable Messaging</li>

<li>WS-Trust</li>

<li>WS-SecureConversation</li>

</ul>
<p>Una de las ventajas de este framework es la gran facilidad con la que se pueden crear y consumir servicios,
especialmente si se utiliza el entorno Netbeans. Dentro de este entorno contamos con numeroso asistentes
que nos permiten no s&oacute;lo crear servicios, sino adem&aacute;s configurar la seguridad, fiabilidad, transacciones, y otras
caracter&iacute;sticas avanzadas proporcionadas por Metro. Metro puede ser utilizado tambi&eacute;n en otros entornos,
como Eclipse, aunque en este caso no tendr&iacute;amos todas las facilidades que proporciona Netbeans.
</p>
<a name="N10827"></a><a name="El+framework+Axis+2"></a>
<h4>El framework Axis 2</h4>
<p>Axis 2 es un proyecto de Apache, sucesor de Axis, aunque cambia completamente su arquitectura respecto a
este &uacute;ltimo. Axis 2 proporciona un mecanismo muy sencillo para el despliegue de servicios. Cuenta con un
entorno de ejecuci&oacute;n de servicios que puede ser instalado como una aplicaci&oacute;n web en cualquier servidor de
aplicaciones Java EE, que actuar&aacute; como contenedor de servicios web.
</p>
<p>Dentro de este contenedor podremos desplegar servicios de forma muy sencilla, como m&oacute;dulos
independientes empaquetados en ficheros aar. Esto hace que desplegar y configurar servicios Axis 2 sea una
tarea muy sencilla, independiente del servidor de aplicaciones utilizado.
</p>
<p>Otra ventaja de Axis 2 es que cuenta con una gran base de usuarios, muchos de ellos procedentes de Axis, y
que podemos encontrar una bibliograf&iacute;a bastante amplia sobre dicha tecnolog&iacute;a.
</p>
<p>Como punto negativo, el desarrollo de servicios con Axis 2 no es tan sencillo como en el caso de Metro, ya que
no cuenta con asistentes para configurar las caracter&iacute;sticas avanzadas de estos servicios, y para ello debemos
editar directamente el XML.
</p>
<p>Tambi&eacute;n encontramos el problema de no soportar todas las caracter&iacute;sticas avanzadas de los servicios web
directamente, sino que deberemos instalar m&oacute;dulos adicionales para cada una de ellas:
</p>
<ul>

<li>Rampart para seguridad</li>

<li>Kandula2 para coordinaci&oacute;n y transacciones</li>

<li>Sandesha2 para fiabilidad</li>

</ul>
<a name="N10849"></a><a name="El+framework+CXF"></a>
<h4>El framework CXF</h4>
<p>Este framework es tambi&eacute;n un proyecto de Apache, pensado para integrarse con otros sistemas. Utiliza el
framework de Spring, y cuenta tanto con una API propietaria para el desarrollo de servicios web como con el
est&aacute;ndar JAX-WS.
</p>
<p>Mientras Axis 2 produce servicios altamente modulares que se despliegan de forma independiente. CXF nos
permitir&aacute; tener los servicios integrados en aplicaciones existentes, estando especialmente preparados para el
framework Spring.
</p>
<a name="N10856"></a><a name="Comparativa"></a>
<h4>Comparativa</h4>
<p>Todos los frameworks tratados permiten crear y consumir servicios web b&aacute;sicos. Sin embargo, en los &uacute;ltimos
a&ntilde;os han aparecido una serie de tecnolog&iacute;as de servicios web de segunda generaci&oacute;n que no siempre est&aacute;n
disponibles. Estas tecnolog&iacute;as son las que nos permiten por ejemplo crear servicios web seguros (WS-Security)
y fiables (WS-ReliableMessaging) y utilizar transacciones de negocio (WS-Transaction). A continuaci&oacute;n
mostramos una comparativa de las tecnolog&iacute;as de segunda generaci&oacute;n soportadas por cada uno de los
frameworks anteriores:
</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
                     
<tr>
                        
<th colspan="1" rowspan="1">Standards (*)</th>
                        <th colspan="1" rowspan="1">Axis2</th>
                        <th colspan="1" rowspan="1">CXF</th>
                        <th colspan="1" rowspan="1">JAX-WS/Metro</th>
                     
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Addressing</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Coordination</td>
                           <td colspan="1" rowspan="1">X(2)</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-MetadataExchange</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Policy</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-ReliableMessaging</td>
                           <td colspan="1" rowspan="1">X(3)</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">Web Services Security</td>
                           <td colspan="1" rowspan="1">X(1)</td>
                           <td colspan="1" rowspan="1">X(4)</td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-SecureConversation</td>
                           <td colspan="1" rowspan="1">X(1)</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-SecurityPolicy</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Transaction</td>
                           <td colspan="1" rowspan="1">X(2)</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Trust</td>
                           <td colspan="1" rowspan="1">X</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1">X</td>
                        
</tr>
                        
<tr>
                           
<td colspan="1" rowspan="1">WS-Federation</td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1"></td>
                           <td colspan="1" rowspan="1"></td>
                        
</tr>

</table>
<ul>

<li>(1) Necesita el m&oacute;dulo adicional Apache Rampart</li>

<li>(2) Necesita el m&oacute;dulo adicional Apache Kandula2</li>

<li>(3) Necesita el m&oacute;dulo adicional Apache Sandesha2</li>

<li>(4) Proporcionado por Apache WSS4J Interceptor</li>

<li>(*) Extra&iacute;do del informe "Apache Axis2, CXF and Sun JAX-WS RI in comparison",
de Thomas Bayer, 20/10/2008</li>

</ul>
<p>Tambi&eacute;n es importante comparar el rendimiento obtenido en cada caso. En un reciente estudio publicado por
IBM, "Java Web services: Metro vs. Axis2 performance" por Dennis Sosnoski (Enero de 2010), se compara el tiempo de respuesta obtenido con Axis 2 y con Metro. En el caso de no utilizar seguridad
se obtuvieron tiempos similares:
</p>
<p>
<img alt="Rendimientos sin seguridad" content-width="8cm" src="imagenes/sws/text-times.png" width="456"></p>
<p>Sin embargo, utilizando servicios web seguros Metro proporciona una mejora notable en el tiempo de
respuesta, tanto para respuestas cortas,
</p>
<p>
<img alt="Rendimientos para respuestas cortas" content-width="8cm" src="imagenes/sws/small-times2.png" width="462"></p>
<p>como para respuestas largas:</p>
<p>
<img alt="Rendimiento para respuestas largas" content-width="8cm" src="imagenes/sws/large-times3.png" width="462"></p>
</div>


<p class="pageBreakAfter"></p>


<a name="N109A2"></a><a name="Ejercicios"></a>
<h2 class="underlined_10">Ejercicios</h2>
<div class="section">
<a name="N109A8"></a><a name="Seguridad+para+servicios+web+con+Rampart"></a>
<h3 class="underlined_5">Seguridad para servicios web con Rampart</h3>
<p>A lo largo de este curso vamos a utilizar el m&oacute;dulo y las librer&iacute;as de Rampart
para incorporar seguridad a nuestros servicios web. Rampart usa la pol&iacute;tica
est&aacute;ndar WS-SecurityPolicy. 
</p>
<ol>

<li>Descargad la documentaci&oacute;n de la WS-SecurityPolicy de 2005 y la de 2007 y
dejadlos guardados para futuras consultas. Comparad ambos documentos.</li>

<li>Descargad la documentaci&oacute;n de la WS-Policy de 2006, ya que en la definici&oacute;n
del WSDL utilizaremos las Policy con frecuencia. Mirad los principales ejemplos
de uso. &iquest;Para qu&eacute; sirven las etiquetas <span class="codefrag">&lt;wsp:ExactlyOne&gt;</span> y 
<span class="codefrag">&lt;wsp:All&gt;</span>?</li>

<li>Rampart utiliza la WS-SecurityPolicy est&aacute;ndar, pero tambi&eacute;n define
algunas sentencias propias. &Eacute;stas se encuentran documentadas en la 
web oficial del proyecto, 
<a href="http://ws.apache.org/rampart/rampartconfig-guide.html">http://ws.apache.org/rampart/rampartconfig-guide.html</a>.
Est&uacute;diese el Schema de RampartConfig.</li>

</ol>
</div> 



<p class="pageBreakAfter"></p>


</div>
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("<text>Last Published:</text> " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2010 Depto. CCIA</div>
</div>
</body>
</html>
