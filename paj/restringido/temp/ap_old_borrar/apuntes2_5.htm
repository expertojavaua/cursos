<html>
<head>
<title>Tema 2: Caracter&iacute;sticas b&aacute;sicas</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="../../apuntes.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<h2><span class="section">2.5. Entrada/Salida</span> </h2>
<p>Los programas muy a menudo necesitan enviar datos a un determinado destino, o
bien leerlos de una determinada fuente externa, como por ejemplo puede ser un
fichero para almacenar datos de forma permanente, o bien enviar datos a través
de la red, a memoria, o a otros programas. Esta entrada/salida de datos en Java
la realizaremos por medio de <i>flujos (streams)</i> de datos, a través de los
cuales un programa podrá recibir o enviar datos en serie.&nbsp;</p>
<h3 class="subsection">2.5.1 Flujos de datos de entrada/salida</h3>
<p>Existen varios objetos que hacen de flujos de datos, y que se distinguen por
la finalidad del flujo de datos y por el tipo de datos que viajen a través de
ellos. Según el tipo de datos&nbsp; que transporten podemos distinguir:</p>
<ul>
  <li>Flujos de caracteres</li>
  <li>Flujos de bytes</li>
</ul>
<p>Dentro de cada uno de estos grupos tenemos varios pares de objetos, de los
cuales uno nos servirá para leer del flujo y el otro para escribir en él. Cada
par de objetos será utilizado para comunicarse con distintos elementos
(memoria, ficheros, red u otros programas). Estas clases, según sean de entrada
o salida y según sean de caracteres o de bytes llevarán distintos sufijos,
según se muestra en la siguiente tabla:</p>
<table border="1" width="100%">
  <tr>
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Flujo de entrada / lector</b></td>
    <td width="34%"><b>Flujo de salida / escritor</b></td>
  </tr>
  <tr>
    <td width="33%"><b>Caractéres</b></td>
    <td width="33%">XXXXReader</td>
    <td width="34%">XXXXWriter</td>
  </tr>
  <tr>
    <td width="33%"><b>Bytes</b></td>
    <td width="33%">XXXXInputStream</td>
    <td width="34%">XXXXOutputStream</td>
  </tr>
</table>
<p>Donde XXXX se referirá a la fuente o sumidero de los datos que puede tomar
valores como los que se muestran a continuación:</p>
<table border="1" width="100%">
  <tr>
    <td width="18%"><b>File</b></td>
    <td width="82%">Acceso a ficheros</td>
  </tr>
  <tr>
    <td width="18%"><b>Piped</b></td>
    <td width="82%">Comunicación entre programas mediante tuberías (pipes)</td>
  </tr>
  <tr>
    <td width="18%"><b>String</b></td>
    <td width="82%">Acceso a una cadena en memoria (solo caracteres)</td>
  </tr>
  <tr>
    <td width="18%"><b>CharArray</b></td>
    <td width="82%">Acceso a un array de caracteres en memoria (solo caracteres)</td>
  </tr>
  <tr>
    <td width="18%"><b>ByteArray</b></td>
    <td width="82%">Acceso a un array de bytes en memoria (solo bytes)</td>
  </tr>
</table>
<p>Además podemos distinguir los flujos de datos según su propósito, pudiendo
ser:</p>
<ul>
  <li>Canales de datos, simplemente para leer o escribir datos directamente en
    una fuente o sumidero externo.</li>
  <li>Flujos de procesamiento, que además de enviar o recibir datos realizan
    algún procesamiento con ellos. Tenemos por ejemplo flujos que realizan un
    filtrado de los datos que viajan a través de ellos (con prefijo Filter),
    conversores datos (con prefijo Data), bufferes de datos (con prefijo
    Buffered), preparados para la impresión de elementos (con prefijo Print), etc.</li>
</ul>
<p>Un tipo de filtros de procesamiento a destacar son aquellos que nos permiten
convertir un flujo de bytes a flujo de caracteres. Estos objetos son <b>InputStreamReader</b>
y <b>OutputStreamWriter</b>. Como podemos ver en su sufijo, son flujos de
caracteres, pero se construyen a partir de flujos de bytes, permitiendo de esta
manera acceder a nuestro flujo de bytes como si fuese un flujo de caracteres.</p>
<p>Para cada uno de los tipos básicos de flujo que hemos visto existe una
superclase, de la que heredaran todos sus subtipos, y que contienen una serie de
métodos que serán comunes a todos ellos. Entre estos métodos encontramos los
métodos básicos para leer o escribir caracteres o bytes en el flujo a bajo
nivel. En la siguiente tabla se muestran los métodos más importantes de cada
objeto:</p>
<table border="1" width="100%">
  <tr>
    <td width="29%"><b>InputStream</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>available</b>(), <b>close</b>()</td>
  </tr>
  <tr>
    <td width="29%"><b>OutputStream</b></td>
    <td width="71%"><b>write</b>(int b), <b>flush</b>(), <b>close</b>()</td>
  </tr>
  <tr>
    <td width="29%"><b>Reader</b></td>
    <td width="71%"><b>read</b>(), <b>reset</b>(), <b>close</b>()</td>
  </tr>
  <tr>
    <td width="29%"><b>Writer</b></td>
    <td width="71%"><b>write</b>(int c), <b>flush</b>(), <b>close</b>()</td>
  </tr>
</table>
<p>A parte de estos métodos podemos encontrar variantes de los métodos de
lectura y escritura, otros métodos, y además cada tipo específico de flujo
contendrá sus propios métodos. Todas estas clases se encuentran en el paquete <b>java.io</b>.
Para más detalles sobre ellas se puede consultar la especificación de la API
de Java.</p>
<h3 class="subsection">2.5.2. Entrada, salida y salida de error estándar</h3>
<p>Al igual que en C, en Java también existen los conceptos de entrada, salida,
y salida de error estándar. La entrada estándar normalmente se refiere a lo
que el usuario escribe en la consola, aunque el sistema operativo puede hacer
que se tome de otra fuente. De la misma forma la salida y la salida de error
estándar lo que hacen normalmente es mostrar los mensajes y los errores del
programa respectivamente en la consola, aunque el sistema operativo también
podrá redirigirlas a otro destino.</p>
<p>En Java esta entrada, salida y salida de error estándar se tratan de la
misma forma que cualquier otro flujo de datos, estando estos tres elementos
encapsulados en tres objetos de flujo de datos que se encuentran como
propiedades estáticas de la clase <b>System</b>:</p>
<table border="1" width="61%">
  <tr>
    <td width="52%">&nbsp;</td>
    <td width="23%"><b>Tipo</b></td>
    <td width="25%"><b>Objeto</b></td>
  </tr>
  <tr>
    <td width="52%"><b>Entrada estándar</b></td>
    <td width="23%">InputStream</td>
    <td width="25%">System.<b>in</b></td>
  </tr>
  <tr>
    <td width="52%"><b>Salida estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>out</b></td>
  </tr>
  <tr>
    <td width="52%"><b>Salida de error estándar</b></td>
    <td width="23%">PrintStream</td>
    <td width="25%">System.<b>err</b></td>
  </tr>
</table>
<p>Para la entrada estándar vemos que se utiliza un objeto <b>InputStream</b>
básico, sin embargo para la salida se utilizan objetos <b>PrintWriter</b> que
facilitan la impresión de texto ofreciendo a parte del método común de bajo
nivel <i>write(int b)</i> <b> </b>para escribir bytes, dos métodos más: <i>print(s)</i> <b> </b>y
<i>println(s)</i>. Estas funciones nos permitirán escribir cualquier cadena, tipo
básico, o bien cualquier objeto que defina el método <i>toString()</i> que
devuelva una representación del objeto en forma de cadena. La única diferencia
entre los dos métodos es que el segundo añade automáticamente un salto de
línea al final del texto impreso, mientras que en el primero deberemos
especificar explícitamente este salto.</p>
<p>Para escribir texto en la consola normalmente utilizaremos:</p>
<pre class="codigo">System.out.println(&quot;Hola mundo&quot;);</pre>
<p>En el caso de la impresión de errores por la salida de error de estándar,
deberemos utilizar:&nbsp;</p>
<pre class="codigo">System.err.println(&quot;Error: Se ha producido un error&quot;);</pre>
<p>Además la clase <b>System</b> nos permite sustituir estos
flujos por defecto por otros flujos, cambiando de esta forma la entrada, salida
y salida de error estándar.</p>
<h3 class="subsection">2.5.3. Acceso a ficheros</h3>
<p>Podremos acceder a ficheros bien por caracteres, o bien de forma binaria (por
bytes). Las clases que utilizaremos en cada caso son:</p>
<table border="1" width="100%">
  <tr>
    <td width="33%">&nbsp;</td>
    <td width="33%"><b>Lectura</b></td>
    <td width="34%"><b>Escritura</b></td>
  </tr>
  <tr>
    <td width="33%"><b>Caracteres</b></td>
    <td width="33%">FileReader</td>
    <td width="34%">FileWriter</td>
  </tr>
  <tr>
    <td width="33%"><b>Binarios</b></td>
    <td width="33%">FileInputStream</td>
    <td width="34%">FileOutputStream</td>
  </tr>
</table>
<p>Para crear un lector o escritor de ficheros deberemos proporcionar al
constructor el fichero del que queremos leer o en el que queramos escribir.
Podremos proporcionar esta información bien como una cadena de texto con el
nombre del fichero, o bien construyendo un objeto <b>File</b> representando al
fichero al que queremos acceder. Este objeto nos permitirá obtener información
adicional sobre el fichero, a parte de permitirnos realizar operaciones sobre el
sistema de ficheros.</p>
<p>A continuación vemos un ejemplo simple de la copia de un fichero carácter a
carácter:</p>
<pre class="codigo">public void copia_fichero() {
&nbsp;&nbsp;&nbsp; int c;
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <b>FileReader</b> in = new <b>FileReader</b>(&quot;fuente.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp; <b>&nbsp;&nbsp;&nbsp;FileWriter</b> out = new <b>FileWriter</b>(&quot;destino.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while( (c = in.<b>read</b>()) != -1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.write(c);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in.<b>close</b>();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out.<b>close</b>();
&nbsp;&nbsp;&nbsp; } catch(<b>FileNotFoundException</b> e1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(&quot;Error: No se encuentra el fichero&quot;);
&nbsp;&nbsp;&nbsp; } catch(<b>IOException</b> e2) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(&quot;Error leyendo/escribiendo fichero&quot;);
&nbsp;&nbsp;&nbsp; }
}</pre>
<p>
En el ejemplo podemos ver que para el acceso a un fichero es necesario
capturar dos excepciones, para el caso de que no exista el fichero al que
queramos acceder y por si se produce un error en la E/S.</p>
<p>Para la escritura podemos
utilizar el método anterior, aunque muchas veces nos
resultará mucho más cómodo utilizar un objeto <b>PrintWriter </b>con el que
podamos escribir directamente líneas de texto:</p>
<pre class="codigo">public void escribe_fichero() {
&nbsp;&nbsp;&nbsp; <b>FileWriter</b> out = null;
&nbsp;&nbsp;&nbsp; <b>PrintWriter</b> p_out = null;
&nbsp;&nbsp;&nbsp; try {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out = new <b>FileWriter</b>(&quot;result.txt&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out = new <b>PrintWriter</b>(out);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out.<b>println</b>(
            &quot;Este texto será escrito en el fichero de salida&quot;);
&nbsp;&nbsp;&nbsp; } catch(<b>IOException</b> e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.err.println(&quot;Error al escribir en el fichero&quot;);
&nbsp;&nbsp;&nbsp; } finally {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; p_out.<b>close</b>();
&nbsp;&nbsp;&nbsp; }
}</pre>
<h3 class="subsection">2.5.4. Lectura de tokens</h3>
<p>Hemos visto como leer un fichero carácter a carácter, pero en el caso de
ficheros con una gramática medianamente compleja, esta lectura a bajo nivel
hará muy difícil el análisis de este fichero de entrada. Necesitaremos leer
del fichero elementos de la gramática utilizada, los llamados <b>tokens</b>,
como pueden ser palabras, número y otros símbolos.</p>
<p>La clase <b>StreamTokenizer </b>se encarga de partir la entrada en <b>tokens</b>
y nos permitirá realizar la lectura del fichero directamente como una secuencia
de <b>tokens</b>. Esta clase tiene una serie de constantes identificando los
tipos de <b>tokens</b> que puede leer:</p>
<table border="1" width="100%">
  <tr>
    <td width="28%">StreamTokenizer.<b>TT_WORD</b></td>
    <td width="72%">Palabra</td>
  </tr>
  <tr>
    <td width="28%">StreamTokenizer.<b>TT_NUMBER</b></td>
    <td width="72%">Número real o entero</td>
  </tr>
  <tr>
    <td width="28%">StreamTokenizer.<b>TT_EOL</b></td>
    <td width="72%">Fin de línea</td>
  </tr>
  <tr>
    <td width="28%">StreamTokenizer.<b>TT_EOF</b></td>
    <td width="72%">Fin de fichero</td>
  </tr>
  <tr>
    <td width="28%">Carácter de comillas establecido</td>
    <td width="72%">Cadena de texto encerrada entre comillas</td>
  </tr>
  <tr>
    <td width="28%">Símbolos</td>
    <td width="72%">Vendrán representados por el código del carácter ASCII
      del símbolo</td>
  </tr>
</table>
<p>Dado que un <b>StreamTokenizer </b>se utiliza para analizar un fichero de
texto, siempre habrá que crearlo a partir de un objeto <b>Reader</b> (o
derivados).</p>
<pre class="codigo">StreamTokenizer st = new StreamTokenizer(reader);</pre>
<p>El método <b>nextToken() </b>leerá el siguiente token que encuentre en el
fichero y nos devolverá el tipo de <b> token</b> del que se trata. Según este tipo
podremos consultar las propiedades <b>sval </b>o <b>nval</b> para ver qué
cadena o número respectivamente se ha leído del fichero. Tanto cuando se lea
un <b> token</b> de tipo <b>TT_WORD </b>como de tipo cadena de texto entre comillas el
valor de este <b> token</b> estará almacenado en <b>sval</b>. En caso de la lectura de
un número, su valor se almacenará en <b>nval </b>que es de tipo <b>double</b>.
Como los demás símbolos ya devuelven el código del símbolo como tipo de <b>
token</b> no será necesario acceder a su valor por separado. Podremos consultar el
tipo del último <b> token</b> leído en la propiedad <b>ttype</b>.</p>
<p>Un bucle de procesamiento básico será el siguiente:</p>
<pre class="codigo">while(st.<b>nextToken</b>() != StreamTokenizer.<b>TT_EOF</b>) {
&nbsp;&nbsp;&nbsp; switch(st.<b>ttype</b>) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case StreamTokenizer.<b>TT_WORD</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Leida cadena: &quot; + st.<b>sval</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case StreamTokenizer.<b>TT_NUMBER</b>:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(&quot;Leido numero: &quot; + st.<b>nval</b>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;
&nbsp;&nbsp;&nbsp; }
}&nbsp;</pre>
<p>Podemos distinguir tres tipos de caracteres:</p>
<table border="1" width="100%" height="71">
  <tr>
    <td width="36%" height="17">Ordinarios (<b>ordinaryChars</b>)</td>
    <td width="64%" height="17">Caracteres que forman parte de los <i>tokens</i>.</td>
  </tr>
  <tr>
    <td width="36%" height="18">De palabra (<b>wordChars</b>)</td>
    <td width="64%" height="18">Una secuencia formada enteramente por este tipo
      de caracteres se considerará una palabra.</td>
  </tr>
  <tr>
    <td width="36%" height="18">De espacio en blanco (<b>whitespaceChars</b>)</td>
    <td width="64%" height="18">Estos caracteres no son interpretados como <i>tokens</i>, simplemente se utilizan para separar
      <i>tokens</i>. Normalmente estos
      caracteres son el espacio, tabulador, y salto de línea.</td>
  </tr>
</table>
<p>Para establecer qué caracteres pertenecerán a cada uno de estos tipos
utilizaremos los métodos <i>ordinaryChars</i>, <i>wordChars</i> y <i>whitespaceChars</i>
del objeto <b>StreamTokenizer<i> </i></b>respectivamente. A cada uno de estos
métodos le pasamos un rango de caracteres (según su código ASCII), que serán
establecidos al tipo correspondiente al método que hayamos llamado. Por
ejemplo, si queremos que una palabra sea una secuencia de cualquier carácter
imprimible (con códigos ASCII desde 32 a 127) haremos lo siguiente:</p>
<pre class="codigo">st.<strong>wordChars</strong>(32,127);</pre>
<p>Los caracteres pueden ser especificados tanto por su código ASCII numérico
como especificando ese carácter entre comillas simples. Si ahora queremos hacer
que las palabras sean separadas por el caracter ':' (dos puntos) hacemos la
siguiente llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>(':', ':');</pre>
<p>De esta forma, si hemos hecho las llamadas anteriores el <i>tokenizer</i>
leerá palabras formadas por cualquier carácter imprimible separadas por los
dos puntos ':'. Al querer cambiar un único carácter, como siempre deberemos
especificar un rango, deberemos especificar un rango formado por ese único
carácter como inicial y final del rango. Si además quisieramos utilizar el
guión '-' para separar palabras, no siendo caracteres consecutivos guión y dos
puntos en la tabla ASCII, tendremos que hacer una tercera llamada:</p>
<pre class="codigo">st.<strong>whitespaceChars</strong>('-', '-');</pre>
<p>Así tendremos tanto el guión como los dos puntos como separadores, y el
resto de caracteres imprimibles serán caracteres de palabra. Podemos ver que el
<b>StreamTokenizer</b> internamente implementa una tabla, en la que asocia a
cada carácter uno de los tres tipos mencionados. Al llamar a cada uno de los
tres métodos cambiará el tipo de todo el rango especificado al tipo
correspondiente al método. Por ello es importante el orden en el que invoquemos
este método. Si en el ejemplo en el que hemos hecho estas tres llamadas las
hubiésemos hecho en orden inverso, al establecer todo el rango de caracteres
imprimibles como <i>wordChars</i> hubiésemos sobrescrito el resultado de las
otras dos llamadas y por lo tanto el guión y los dos puntos no se
considerarían separadores.</p>
<p>Podremos personalizar el <i> tokenizer</i> indicando para cada carácter a que tipo
pertenece. Además de con los tipos anteriores, podemos especificar el carácter que se utilice para encerrar
las cadenas de texto (<b>quoteChar</b>), mediante el método <i>quoteChar</i>, y el carácter para los comentarios (<b>commentChar</b>),
mediante <i>commentChar</i>. Esto nos permitirá definir comentarios de una
línea que comiencen por un determinado carácter, como por ejemplo los
comentarios estilo Pascal comenzados por el carácter almohadilla ('#'). Además
tendremos otros métodos para activar comentarios tipo C como los comentarios <i>barra-barra
</i>(<i>//</i>)<i> </i>y <i>barra-estrella </i>(<i>/* */</i>).</p>
<h3 class="subsection">2.5.5. Serialización de objetos</h3>
<p>Si queremos enviar un objeto a través de un flujo de datos, deberemos
convertirlo en una serie de bytes. Esto es lo que se conoce como serialización
de objetos, que nos permitirá leer y escribir objetos. </p>
<p>Para leer o escribir objetos podemos utilizar los objetos <b>ObjectInputStream
</b>y <b>ObjectOutputStream</b> que incorporan los métodos <b>readObject() </b>y
<b>writeObject(Object obj) </b>respectivamente. Los objetos que escribamos en
dicho flujo deben tener la capacidad de ser <i>serializables</i>. </p>
<p>Serán <i>serializables </i>aquellos objetos que implementan la interfaz <b>Serializable</b>.
Cuando queramos hacer que una clase definida por nosotros sea <i>serializable </i>deberemos
implementar dicho interfaz, que no define ninguna función, sólo se utiliza
para identificar las clases que son <i>serializables</i>. Para que nuestra clase
pueda ser <i>serializable</i>, todas sus propiedades deberán ser de tipos de
datos básicos o bien objetos que también sean<i><b> </b>serializables</i>. </p>
</body>
</html>
